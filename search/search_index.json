{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Wannier90 documentation","text":"<p>This is the home of the documenation of Wannier90, which a computer program for maximally-localised Wannier functions (MLWFs).</p> <ul> <li>User guide</li> <li>Tutorials</li> </ul>"},{"location":"tutorials/preliminaries/","title":"Preliminaries","text":"<p>Welcome to <code>wannier90</code>! The examples contained in these tutorials are designed to help you become familiar with the procedure of generating, analysing and using maximally-localised Wannier functions (MLWFs). As a first step, install <code>wannier90</code>\u00a0following the instructions in the <code>README</code> file of the <code>wannier90</code>\u00a0distribution. For an introduction to the theory underlying MLWFs, you are encouraged to refer to the brief overview given in the <code>wannier90</code> User Guide, to the two seminal papers of Refs.\u00a0<sup>1</sup><sup>2</sup>, a recent review article\u00a0<sup>3</sup> and to a paper\u00a0<sup>4</sup> describing <code>wannier90</code>.</p> <p>The following additional programs may be installed in order to visualise the output of <code>wannier90</code>\u00a0(they are optional, not all of them are necessary)</p> <ul> <li> <p><code>gnuplot</code> is used to plot bandstructures. It is available for many     operating systems and is often installed by default on Unix/Linux     distributions  http://www.gnuplot.info</p> </li> <li> <p><code>xmgrace</code> may also be used to plot bandstructures. http://plasma-gate.weizmann.ac.il/Grace</p> </li> <li> <p><code>XCrySDen</code> is used to visualise crystal structures, MLWFs, and Fermi     surfaces. It is available for Unix/Linux, Windows (using cygwin),     and OSX. To correctly display files from <code>wannier90</code>, version 1.4 or     later must be used. http://www.xcrysden.org</p> </li> <li> <p><code>vmd</code> can also be used to visualise crystal structures and MLWFs. http://www.ks.uiuc.edu/Research/vmd</p> </li> <li> <p><code>python</code> with the <code>numpy</code> and <code>matplotlib</code> modules is used in     tutorials 17 \u2014 19 http://www.python.org http://www.numpy.org http://matplotlib.org</p> </li> </ul>"},{"location":"tutorials/preliminaries/#parallel-execution","title":"Parallel execution","text":"<p><code>postw90.x</code> and <code>wannier90.x</code> can be run in parallel to speed up the calculations, using the MPI libraries.</p> <p>To enable the parallel version to be built, you must specify some flags in the <code>make.inc</code> file of <code>wannier90</code> and <code>postw90</code>; for further information, please refer to the <code>README.install</code> file in the top directory of the <code>wannier90</code> distribution.</p> <p>Then, to run e.g. with 8 processors, you typically need to run a command similar to <code>postw90</code> as follows:</p> Terminal<pre><code>mpirun -np 8 postw90.x seedname\n</code></pre> <p>(the <code>mpirun</code> command and its flags may differ depending on the MPI libraries installed on your system: refer to your MPI manual and/or to your system administrator for further information).</p>"},{"location":"tutorials/preliminaries/#about-these-tutorials","title":"About these tutorials","text":"<p>The first part of this collection of tutorials comprises four examples taken from Refs.\u00a0<sup>1</sup><sup>2</sup>: gallium arsenide, lead, silicon and copper. All of the <code>wannier90</code>\u00a0input files have been provided.</p> <p>The second part of this collection of tutorials covers the generation of <code>wannier90</code>\u00a0input files starting from a full electronic structure calculation. We have provided input files for the <code>pwscf</code>\u00a0interface (http://www.quantum-espresso.org) to <code>wannier90</code>. Therefore, you will need to install and compile elements of the <code>quantum-espresso</code> package, namely <code>pw.x</code> and <code>pw2wannier90.x</code>, in order to run these tutorials. Please visit http://www.quantum-espresso.org to download the package, and for installation instructions. The tutorials work with <code>pwscf\u00a0v5.1.x</code> and <code>v6.0.x</code>. The exception are the tutorials on symmetry adapted Wannier functions which require v6.0.x together with the very latest version of <code>pw2wannier90.f90</code>. This can be found in the directory <code>pwscf/v6.0</code> in the wannier distribution. It should be moved to <code>PP/src</code> in the <code>pwscf</code>\u00a0distribution and compiled using <code>make pp</code>. Later versions v6.x.x should have the most up-to-date version of pw2wannier90.f90 already included in the Quantum ESPRESSO distribution.</p> <p>There are interfaces to a number of other electronic structure codes including abinit (http://www.abinit.org), fleur (http://www.flapw.de), OpenMX (http://www.openmx-square.org/), GPAW (https://wiki.fysik.dtu.dk/gpaw/), VASP (http://www.vasp.at), and Wien2k (http://www.wien2k.at)</p>"},{"location":"tutorials/preliminaries/#contact-us","title":"Contact us","text":"<p>If you have any suggestions regarding ways in which these tutorials may be improved, then send us an email.</p> <p>For other questions, email the <code>wannier90</code>\u00a0forum at <code>wannier@quantum-espresso.org</code>. Note that first you will need to register in order to post emails. Emails from non-registered users are deleted automatically. You can register by following the links at http://www.wannier.org/forum.html.</p> <ol> <li> <p>N. Marzari and D. Vanderbilt. Maximally localized generalized wannier functions for composite energy bands. Phys. Rev. B, 56:12847, 1997.\u00a0\u21a9\u21a9</p> </li> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9\u21a9</p> </li> <li> <p>N. Marzari, A. A. Mostofi, J. R. Yates, I. Souza, and D. Vanderbilt. Rev. Mod. Phys., 84:1419, 2012.\u00a0\u21a9</p> </li> <li> <p>A. A. Mostofi, J. R. Yates, Y.-S. Lee, I. Souza, D. Vanderbilt, and N. Marzari. Wannier90: a tool for obtaining maximally-localised wannier functions. Comput. Phys. Commun., 178:685, 2008.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_1/","title":"1: Gallium Arsenide \u2014 MLWFs for the valence bands","text":"<ul> <li> <p>Outline: Obtain and plot MLWFs for the four valence bands of GaAs.</p> </li> <li> <p>Generation details: From <code>pwscf</code>, using norm-conserving     pseudopotentials and a      2\\(\\times\\)2\\(\\times\\)2 k-point grid. Starting guess: four bond-centred Gaussians.</p> </li> <li> <p>Directory: <code>tutorials/tutorial01/</code> Files can be downloaded from     here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>gaas.win</code> The master input file</p> </li> <li> <p><code>gaas.mmn</code> The overlap matrices         \\(\\mathbf{M}^{(\\mathbf{k},\\mathbf{b})}\\)</p> </li> <li> <p><code>gaas.amn</code> Projection \\(\\mathbf{A}^{(\\mathbf{k})}\\) of the Bloch         states onto a set of trial localised orbitals</p> </li> <li> <p><code>UNK00001.1</code> The Bloch states in the real space unit cell. For         plotting only.</p> </li> </ul> </li> <li> <p>Run <code>wannier90</code>\u00a0to minimise the MLWFs spread</p> Terminal<pre><code>wannier90.x  gaas\n</code></pre> <p>Inspect the output file <code>gaas.wout</code>. The total spread converges to its minimum value after just a few iterations. Note that the geometric centre of each MLWF lies along a Ga-As bond, slightly closer to As than Ga. Note also that the memory requirement for the minimisation of the spread is very low as the MLWFs are defined at each k-point by just the 4\\(\\times\\)4 unitary matrices \\(\\mathbf{U}^{(\\mathbf{k})}\\).</p> </li> <li> <p>Plot the MLWFs by adding the following keywords to the input file     <code>gaas.win</code></p> Input file<pre><code>wannier_plot = true\n</code></pre> <p>and re-running <code>wannier90</code>. To visualise the MLWFs we must represent them explicitly on a real space grid (see the User guide page). As a consequence, plotting the MLWFs is slower and uses more memory than the minimisation of the spread. The four files that are created (<code>gaas_00001.xsf</code>, etc.) can be viewed using <code>XCrySDen</code>, e.g.,</p> Terminal<pre><code>xcrysden --xsf gaas_00001.xsf\n</code></pre> <p>Hint</p> <p>Once <code>XCrySDen</code> starts, click on <code>Tools</code> \\(\\rightarrow\\) <code>Data Grid</code> in order to specify an isosurface value to plot.</p> <p>For large systems, plotting the MLWFs may be time consuming and require a lot of memory. Use the keyword <code>wannier_plot_list</code> to plot a subset of the MLWFs. E.g., to plot the 1<sup>st</sup> and 3<sup>rd</sup> MLWFs use</p> Input file<pre><code>wannier_plot_list = 1 3\n</code></pre> <p>The MLWFs are plotted in a supercell of the unit cell. The size of this supercell is set through the keyword <code>wannier_plot_supercell</code>. The default value is 2 (corresponding to a supercell with eight times the unit cell volume). We recommend not using values great than 3 as the memory and computational cost scales cubically with supercell size.</p> <p>Plot the 3<sup>rd</sup> MLWFs in a supercell of size 3. Choose a low value for the isosurface (say 0.5). Can you explain what you see?</p> <p>Hint</p> <p>For a finite k-point mesh, the MLWFs are in fact periodic and the period is related to the spacing of the k-point mesh. For mesh with \\(n\\) divisions in the \\(i^{\\mathrm{th}}\\) direction in the Brillouin zone, the MLWFs \"live\" in a supercell \\(n\\) times the unit cell.</p> </li> </ul>"},{"location":"tutorials/tutorial_10/","title":"10: Graphite","text":"<ul> <li> <p>Outline: Obtain MLWFs for graphite (AB, Bernal)</p> </li> <li> <p>Directory: <code>tutorials/tutorial10/</code> Files can be downloaded from     here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>graphite.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>graphite.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states on a uniform grid</p> </li> <li> <p><code>graphite.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>graphite.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of graphite</p> Terminal<pre><code>pw.x &lt; graphite.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid</p> Terminal<pre><code>pw.x &lt; graphite.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>graphite.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp graphite\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states and     the projections for the starting guess (written in the     <code>graphite.mmn</code> and <code>graphite.amn</code> files).</p> Terminal<pre><code>pw2wannier90.x &lt; graphite.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x graphite\n</code></pre> </li> </ul>"},{"location":"tutorials/tutorial_11/","title":"11: Silicon \u2014 Valence and low-lying conduction states","text":""},{"location":"tutorials/tutorial_11/#valence-states","title":"Valence States","text":"<ul> <li> <p>Outline: Obtain MLWFs for the valence bands of silicon.</p> </li> <li> <p>Directory: <code>tutorials/tutorial11/</code> Files can be downloaded from here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>silicon.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>silicon.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states on a uniform grid</p> </li> <li> <p><code>silicon.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>silicon.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of silicon</p> Terminal<pre><code>pw.x &lt; silicon.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid. Note that we request the lower 4 (valence) bands</p> Terminal<pre><code>pw.x &lt; silicon.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>silicon.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp silicon\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states and     the projections for the starting guess (written in the <code>silicon.mmn</code>     and <code>silicon.amn</code> files).</p> Terminal<pre><code>pw2wannier90.x &lt; silicon.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x silicon\n</code></pre> </li> </ul> <p>Inspect the output file <code>silicon.wout</code>. The total spread converges to its minimum value after just a few iterations. Note that the geometric centre of each MLWF lies at the centre of the Si-Si bond. Note also that the memory requirement for the minimisation of the spread is very low as the MLWFs are defined by just the 4\\(\\times\\)4 unitary matrices \\(\\mathbf{U}^{(\\mathbf{k})}\\).</p> <p>Plot the MLWFs by adding the following keywords to the input file <code>silicon.win</code></p> Input file<pre><code>wannier_plot = true\n</code></pre> <p>and re-running <code>wannier90</code>. Visualise them using <code>XCrySDen</code>, e.g.,</p> Terminal<pre><code>xcrysden --xsf silicon_00001.xsf\n</code></pre>"},{"location":"tutorials/tutorial_11/#valence-conduction-states","title":"Valence + Conduction States","text":"<ul> <li> <p>Outline: Obtain MLWFs for the valence and low-lying conduction-band     states of Si. Plot the interpolated bandstructure. Apply a scissors     correction to the conduction bands.</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>silicon.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>silicon.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states on a uniform grid</p> </li> <li> <p><code>silicon.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>silicon.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> </ul> <p>The valence and lower conduction states can be represented by MLWFs with \\(sp^3\\)-like symmetry. The lower conduction states are not separated by an energy gap from the higher states. In order to form localised WF we use the disentanglement procedure introduced in Ref.\u00a0<sup>1</sup>. The position of the inner and outer energy windows are shown in this plot.</p> <ol> <li> <p>Modify the input file and run <code>pwscf</code>\u00a0and <code>wannier90</code>.\\     Inspect the output file <code>silicon.wout</code>. The minimisation of the     spread occurs in a two-step procedure. First, we minimise     \\(\\Omega_{\\rm       I}\\) -- this is the extraction of the optimal subspace in the     disentanglement procedure. Then, we minimise \\(\\Omega_{\\rm       O}+\\Omega_{{\\rm OD}}\\).</p> </li> <li> <p>Plot the bandstructure by adding the following commands to the input     file <code>silicon.win</code></p> Input file<pre><code>restart = plot\n\nbands_plot = true\n</code></pre> <p>and re-running <code>wannier90</code>. The files <code>silicon_band.dat</code> and <code>silicon_band.gnu</code> are created. To plot the bandstructure using gnuplot</p> Terminal<pre><code>gnuplot\n</code></pre> Gnuplot shell<pre><code>load 'silicon_band.gnu'\n</code></pre> <p>The k-point path for the bandstructure interpolation is set in the <code>kpoint_path</code> block. Try plotting along different paths.</p> </li> </ol>"},{"location":"tutorials/tutorial_11/#further-ideas","title":"Further ideas","text":"<ul> <li> <p>Compare the Wannier-interpolated bandstructure with the full     <code>pwscf</code>\u00a0bandstructure. Recompute the MLWFs using a finer     \\(k\\)-point grid (e.g.,     6\\(\\times\\)6\\(\\times\\)6 or     8\\(\\times\\)8\\(\\times\\)8) and note how     the accuracy of the interpolation increases\u00a0<sup>2</sup>.</p> </li> <li> <p>Compute four MLWFs spanning the low-lying conduction states (see     Ref.\u00a0<sup>1</sup>).</p> </li> </ul> <ol> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9\u21a9</p> </li> <li> <p>J. R. Yates, X. Wang, D. Vanderbilt, and I. Souza. Spectral and fermi surface properties from wannier interpolation. Phys. Rev. B, 75:195121, 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_12/","title":"12: Benzene \u2014 Valence and low-lying conduction states","text":""},{"location":"tutorials/tutorial_12/#valence-states","title":"Valence States","text":"<ul> <li> <p>Outline: Obtain MLWFs for the valence states of benzene</p> </li> <li> <p>Directory: <code>tutorials/tutorial12/</code> Files can be downloaded from here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>benzene.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>benzene.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>benzene.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of benzene</p> Terminal<pre><code>pw.x &lt; benzene.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>benzene.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp benzene\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states and     the projections for the starting guess (written in the <code>benzene.mmn</code>     and <code>benzene.amn</code> files).</p> Terminal<pre><code>pw2wannier90.x &lt; benzene.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x benzene\n</code></pre> </li> </ul> <p>Inspect the output file <code>benzene.wout</code>. The total spread converges to its minimum value after just a few iterations.</p> <p>Plot the MLWFs by adding the following keywords to the input file <code>benzene.win</code></p> Input file<pre><code>restart = plot\nwannier_plot = true\nwannier_plot_format = cube\nwannier_plot_list = 2-4\n</code></pre> <p>and re-running <code>wannier90</code>. Visualise them using, e.g., <code>XCrySDen</code>.</p>"},{"location":"tutorials/tutorial_12/#valence-conduction-states","title":"Valence + Conduction States","text":"<ul> <li> <p>Outline: Obtain MLWFs for the valence and low-lying conduction     states of benzene.</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>benzene.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>benzene.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states for the conduction states</p> </li> <li> <p><code>benzene.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>benzene.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> </ul> <p>In order to form localised WF we use the disentanglement procedure. The position of the inner energy window is set to lie in the energy gap; the outer energy window is set to 4.0\u2006eV. Modify the input file appropriately.</p> <ol> <li> <p>Run <code>pwscf</code>\u00a0and <code>wannier90</code>.\\     Inspect the output file <code>benzene.wout</code>. The minimisation of the     spread occurs in a two-step procedure. First, we minimise     \\(\\Omega_{\\rm       I}\\). Then, we minimise \\(\\Omega_{\\rm O}+\\Omega_{{\\rm OD}}\\).</p> </li> <li> <p>Plot the MLWFs by adding the following commands to the input file     <code>benzene.win</code></p> Input file<pre><code>restart = plot\nwannier_plot = true\nwannier_plot_format = cube\nwannier_plot_list = 1,7,13\n</code></pre> <p>and re-running <code>wannier90</code>. Visualise them using, e.g., <code>XCrySDen</code>.</p> </li> </ol>"},{"location":"tutorials/tutorial_13/","title":"13: (5,5) Carbon Nanotube \u2014 Transport properties","text":"<ul> <li> <p>Outline: Obtain the bandstructure, quantum conductance and density     of states of a metallic (5,5) carbon nanotube</p> </li> <li> <p>Directory: <code>tutorials/tutorial13/</code> Files can be downloaded from here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>cnt55.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>cnt55.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states for the conduction states</p> </li> <li> <p><code>cnt55.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>cnt55.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> </ul> <p>In order to form localised WF that describe both the occupied and unoccupied \\(\\pi\\) and \\(\\pi^{\\ast}\\) manifolds, we use the disentanglement procedure to extract a smooth manifold of states that has dimension equal to 2.5 times the number of carbon atoms per unit cell\u00a0<sup>1</sup>. The positions of the energy windows are shown in this plot.</p>  Bandstructure of (5,5) carbon nanotube showing the position of the outer and inner energy windows. <p>The part of the <code>wannier90</code>\u00a0input file that controls the transport part of the calculation looks like:</p> Input file<pre><code>transport = true\ntransport_mode = bulk\none_dim_axis = z\ndist_cutoff = 5.5\nfermi_energy = -1.06\ntran_win_min = -6.5\ntran_win_max = 6.5\ntran_energy_step = 0.01\ndist_cutoff_mode = one_dim\ntranslation_centre_frac = 0.0 0.0 0.0\n</code></pre> <p>Descriptions of these and other keywords related to the calculation of transport properties can be found in the User Guide.</p> <ol> <li> <p>Run <code>pwscf</code>\u00a0and <code>wannier90</code>.\\     Inspect the output file <code>cnt55.wout</code>. The minimisation of the spread     occurs in a two-step procedure. First, we minimise \\(\\Omega_{\\rm       I}\\). Then, we minimise \\(\\Omega_{\\rm O}+\\Omega_{{\\rm OD}}\\).</p> </li> <li> <p>Note that the initial \\(p_{z}\\) projections on the carbon atoms are     oriented in the radial direction with respect to the nanotube axis.</p> </li> <li> <p>The interpolated bandstructure is written to <code>cnt55_band.agr</code>     (since <code>bands_plot_format = xmgr</code> in the input file).</p> </li> <li> <p>The quantum conductance and density of states are written to the     files <code>cnt55_qc.dat</code> and <code>cnt55_dos.dat</code>, respectively. Note that     this part of the calculation may take some time. You can follow its     progress by monitoring the output to these files. Use a package such     as <code>gnuplot</code> or <code>xmgrace</code> in order to visualise the data. You should     get something that looks like     this.</p> <p>  Wannier interpolated bandstructure, quantum conductance and density of states of (5,5) carbon nanotube. Note that the Fermi level has been shifted by 1.06eV with respect to the bandstructure\u00a0plot. </p> </li> </ol> <ol> <li> <p>Y.-S. Lee, M. B. Nardelli, and N. Marzari. Band structure and quantum conductance of nanostructures from maximally localized wannier functions: the case of functionalized carbon nanotubes. Phys. Rev. Lett., 95:076804, 2005.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_14/","title":"14: Linear Sodium Chain \u2014 Transport properties","text":"<ul> <li> <p>Outline: Compare the quantum conductance of a periodic linear chain     of Sodium atoms with that of a defected chain</p> </li> <li> <p>Directories:</p> <ul> <li><code>tutorials/tutorial14/periodic</code></li> <li><code>tutorials/tutorial14/defected</code></li> </ul> <p>Files can be downloaded from here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>Na_chain.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>Na_chain.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states for the conduction states</p> </li> <li> <p><code>Na_chain.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>Na_chain.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> </ul> <p>The periodic system contains two unit cells evenly distributed along the supercell. Transport calculations are performed using <code>transport_mode = bulk</code> and so the resulting quantum conductance represents that of an infinite periodic chain.</p> <p>The part of the <code>wannier90</code>\u00a0input file that controls the transport part of the calculation looks like:</p> Input file<pre><code>transport = true\ntransport_mode = bulk\ntran_read_ht = false\none_dim_axis = x\nfermi_energy = -2.7401\ntran_win_min = -5.0\ntran_win_max = 5.0\ntran_energy_step = 0.01\ntranslation_centre_frac = 0.5 0.5 0.5\ntran_num_bb = 2\n</code></pre> <p>The defected system uses a 13 atom supercell with the central atom position altered to break symmetry. Setting <code>transport_mode = lcr</code> with tell <code>wannier90</code>\u00a0to treat the system as an infinite system with the defect at its centre. The supercell is chosen so that is conforms to the 2c2 geometry (see User Guide for details). Each principal layer is 2 atoms long so that the conductor region contains the defected atom plus a single atom on either side.</p> <p>The transport section of the input file contains these key differences:</p> Input file<pre><code>transport_mode = lcr\ntran_num_ll = 2\ntran_num_cell_ll = 2\n</code></pre> <p>Descriptions of these and other keywords related to the calculation of transport properties can be found in the User Guide.</p> <ol> <li> <p>Run <code>pwscf</code>\u00a0and <code>wannier90</code>\u00a0for the periodic system.</p> </li> <li> <p>Run <code>pwscf</code>\u00a0and <code>wannier90</code>\u00a0for the defected system.</p> </li> <li> <p>The quantum conductance is written to the files     <code>periodic/Na_chain_qc.dat</code> and , respectively. Compare the quantum     conductance of the periodic (bulk) calculation with the defected     (LCR) calculation. Your plot should look like     this.</p> </li> </ol>  Quantum conductance of periodic Sodium chain (black) compared to that of the defected Sodium chain (red)."},{"location":"tutorials/tutorial_15/","title":"15: (5,0) Carbon Nanotube \u2014 Transport properties","text":"<p>Note that these systems require reasonably large-scale electronic structure calculations.</p>"},{"location":"tutorials/tutorial_15/#bulk-transport-properties","title":"Bulk Transport properties","text":"<ul> <li> <p>Outline: Obtain the quantum conductance of a pristine single-walled     carbon nanotube</p> </li> <li> <p>Directory: <code>tutorials/tutorial14/periodic</code> Files can be downloaded fron here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>cnt.scf</code> The <code>pwscf</code>\u00a0input file for ground state     calculation</p> </li> <li> <p><code>cnt.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states for the conduction states</p> </li> <li> <p><code>cnt.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>cnt.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> </ul> <p>First we consider a single unit cell, with 10 k-points. With <code>transport_mode = bulk</code> we compute the transport properties of a pristine, infinite, periodic (5,0) carbon nanotube. Later, we will compare the quantum conductance of this system with a defected nanotube.</p> <ol> <li> <p>Run <code>pwscf</code>\u00a0and <code>wannier90</code>.</p> </li> <li> <p>The quantum conductance and density of states are written to the     files <code>cnt_qc.dat</code> and <code>cnt_dos.dat</code>, respectively.</p> </li> </ol>"},{"location":"tutorials/tutorial_15/#lcr-transport-properties-defected-nanotube","title":"LCR transport properties \u2014 Defected nanotube","text":"<ul> <li> <p>Outline: Use the automated LCR routine to investigate the effect of     a single silicon atom in a infinite (5,0) carbon nanotube.</p> </li> <li> <p>Directory: <code>tutorials/tutorial15/defected</code> Files can be downloaded from here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>cnt+si.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>cnt+si.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states for the conduction states</p> </li> <li> <p><code>cnt+si.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>cnt+si.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> </ul> <p>In this calculation an 11-atom supercell is used with a single silicon substitutional defect in the central unit cell. The supercell is chosen so that is conforms to the 2c2 geometry (see User Guide for details) with principal layers set to be two unit cells long.</p> <ol> <li> <p>Run <code>pwscf</code>\u00a0and <code>wannier90</code>. Again these are large     calculations, progress can be monitored by viewing respective output     files.</p> </li> <li> <p>The quantum conductance is written to <code>cnt+si_qc.dat</code>. Compare the     quantum conductance with the periodic (bulk) calculation. Your plot     should look like this{reference-type=\"ref\"     reference=\"fig:cnt_qc\"}.</p> <p>  Quantum conductance of infinite pristine nanotube (black) compared to that of the infinite nanotube with the substitutional silicon defect (red)."},{"location":"tutorials/tutorial_15/#further-ideas","title":"Further ideas","text":"<ul> <li> <p>Set <code>write_hr = true</code> in the bulk case. Consider the magnitude of     Hamiltonian elements between Wannier functions in increasingly     distant unit cells. Are two unit cell principal layers really large     enough, or are significant errors introduced?</p> </li> <li> <p>Does one unit cell either side of the defected unit cell shield the     disorder so that the leads are ideal? Does the quantum conductance     change if these 'buffer' regions are increased?</p> </li> </ul>"},{"location":"tutorials/tutorial_16/","title":"16: Silicon \u2014 Boltzmann transport","text":"<ul> <li>Outline: Obtain MLWFs for the valence and low-lying conduction     states of Si. Calculate the electrical conductivity, the Seebeck     coefficient and the thermal conductivity in the constant relaxation     time approximation using the <code>BoltzWann</code>\u00a0module.</li> </ul>"},{"location":"tutorials/tutorial_16/#if-you-want-to-use-quantum-espresso","title":"If you want to use Quantum ESPRESSO","text":"<ul> <li> <p>Directory: <code>tutorials/tutorial16-withqe/</code> Files can be downloaded from here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>Si.scf</code> The <code>pwscf</code>\u00a0input file for ground state     calculation</p> </li> <li> <p><code>Si.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states on a uniform grid</p> </li> <li> <p><code>Si.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>Si.win</code> The <code>wannier90</code>\u00a0and <code>postw90</code>\u00a0input file</p> </li> </ul> </li> </ul>"},{"location":"tutorials/tutorial_16/#if-you-do-not-want-to-use-quantum-espresso","title":"If you do not want to use Quantum ESPRESSO","text":"<ul> <li> <p>Directory: <code>tutorials/tutorial16-noqe/</code> Files can be downloaded from here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>Si.win</code> The <code>wannier90</code>\u00a0and <code>postw90</code>\u00a0input file</p> </li> <li> <p><code>Si.mmn</code> The overlap matrices     \\(\\mathbf{M}^{(\\mathbf{k},\\mathbf{b})}\\)</p> </li> <li> <p><code>Si.amn</code> Projection \\(\\mathbf{A}^{(\\mathbf{k})}\\) of the Bloch     states onto a set of trial localised orbitals</p> </li> <li> <p><code>Si.eig</code> The Bloch eigenvalues at each k-point. For     interpolation only</p> </li> </ul> </li> </ul> <p>Note the first five steps in the following are the same of Tutorial\u00a011, and are needed only if you want to use the <code>PWscf</code> code of Quantum ESPRESSO. Otherwise, if you have already run Tutorial\u00a011 with Quantum ESPRESSSO (in particular, the section \"Valence + Conduction States\") you can start from those files and continue from point 6, after having added the <code>BoltzWann</code>\u00a0flags to the input file.</p> <p>If instead you do not have Quantum ESPRESSO installed, or you do not want to use it, you can start from step 5 using the files in the <code>tutorials/tutorial16-noqe/</code> folder.</p> <ol> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of silicon</p> Terminal<pre><code>pw.x &lt; Si.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid. Details on the disentanglement procedure are discussed     in Tutorial\u00a011.</p> Terminal<pre><code>pw.x &lt; Si.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>Si.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp Si\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states and     the projections for the starting guess (written in the <code>Si.mmn</code> and     <code>Si.amn</code> files).</p> Terminal<pre><code>pw2wannier90.x &lt; Si.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.\\</p> Terminal<pre><code>wannier90.x Si\n</code></pre> <p>Inspect the output file <code>Si.wout</code> and check if the convergence was reached both in the disentanglement and in the wannierisation steps (as discussed in further detail in Tutorial\u00a011). You may also want to plot the Wannier functions and the interpolated band structure.</p> </li> <li> <p>Run <code>postw90</code>\u00a0to calculate the transport coefficients.\\     <code>postw90.x Si</code> (serial execution)\\     <code>mpirun -np 8 postw90.x Si</code> (example of parallel execution with 8     MPI processes)</p> </li> </ol> <p>Inspect the output file <code>Si.wpout</code>. It summarizes the main details of the calculation (more details can be obtained by setting a larger value of the <code>iprint</code> flag). Check if no warnings are issued. Note that if no special flags are passed to <code>BoltzWann</code>, it assumes that the ab-initio calculation did not include magnetization effects, and thus it sets to 2 the number of electrons per state.</p> <p>Note also that the value of the relaxation time \\(\\tau=10\\)\u00a0fs in the example is set only as a representative value; note also that only the electrical and thermal conductivity depend on \\(\\tau\\), while the Seebeck coefficient is independent of \\(\\tau\\).</p> <p>Using your favourite plotting program, plot the <code>Si_boltzdos.dat</code> file to inspect the DOS.</p> <p>Using your favourite plotting program, plot columns 1 and 3 of the <code>Si_seebeck.dat</code> file to inspect the \\(S_{xx}\\) component of the Seebeck coefficient as a function of the chemical potential \\(\\mu\\), at \\(T=300\\)\u00a0K.</p>"},{"location":"tutorials/tutorial_16/#further-ideas","title":"Further ideas","text":"<ul> <li> <p>Change the interpolation to a \\(60\\times 60\\times 60\\) mesh and run     again <code>postw90</code>\u00a0to check if the results for the transport properties     are converged.</p> </li> <li> <p>Change the <code>Si.win</code> input file so that it calculates the transport     coefficients for temperatures from 300 to 700\u00a0K, with steps of     200\u00a0K. Rerun <code>postw90</code>\u00a0and verify that the increase in execution     time is neglibile (in fact, most of the time is spent to interpolate     the band structure on the \\(k\\) mesh).</p> <p>Plot the Seebeck coefficient for the three temperatures \\(T=300\\)\u00a0K, \\(T=500\\)\u00a0K and \\(T=700\\)\u00a0K. To do this, you have to filter the <code>Si_seebeck.dat</code> to select only those lines where the second column is equal to the required temperature. A possible script to select the \\(S_{xx}\\) component of the Seebeck coefficient for \\(T=500\\)\u00a0K using the <code>awk/gawk</code> command line program is the following:</p> Terminal<pre><code>awk `{if ($2 == 500) {print $1, $3;}}' &lt; Si_seebeck.dat &gt; Si_seebeck_xx_500K.dat\n</code></pre> <p>Then, you can plot columns 1 and 2 of the output file <code>Si_seebeck_xx_500K.dat</code>.</p> </li> <li> <p>Try to calculate the Seebeck coefficient as a function of the     temperature, for a \\(n-\\)doped sample with, e.g., \\(n=10^{18}\\)     cm\\(^{-3}\\). Note that to this aim, you need to calculate consistently     the value \\(\\mu(T)\\) of the chemical potential as a function of the     temperature, so as to reproduce the given value of \\(n\\). Then, you     have to write a small program/script to interpolate the output of     <code>BoltzWann</code>, that you should have run on a suitable grid of     \\((\\mu,T)\\) points.</p> </li> </ul>"},{"location":"tutorials/tutorial_17/","title":"17: Iron \u2014 Spin-orbit-coupled bands and Fermi-surface contours","text":"<p>Note: It is recommended that you go through Tutorial 8 first (bcc Fe without spin-orbit).</p> <p>Note: This tutorial requires a recent version of the <code>pw2wannier90</code> interface.</p> <ul> <li> <p>Outline: Plot the spin-orbit-coupled bands of ferromagnetic bcc Fe.     Plot the Fermi-surface contours on a plane in the Brillouin zone.</p> </li> <li> <p>Directory: <code>tutorials/tutorial17/</code> Files can be downloaded from here</p> </li> <li> <p>Input files</p> <ul> <li> <p><code>Fe.scf</code> The <code>pwscf</code>\u00a0input file for ground state     calculation</p> </li> <li> <p><code>Fe.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states on a uniform grid</p> </li> <li> <p><code>Fe.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>Fe.win</code> The <code>wannier90</code> and <code>postw90</code> input file</p> </li> </ul> </li> </ul> <p>Note that <code>num_wann =18</code> in <code>Fe.win</code>, but only nine trial orbitals are provided. The line</p> Input file<pre><code>spinors = true\n</code></pre> <p>tells <code>wannier90</code> to use in step\u00a03 below the specified trial orbitals on both the up- and down-spin channels, effectively doubling their number.</p> <ol> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ferromagnetic ground state of     iron<sup>1</sup></p> Terminal<pre><code>pw.x &lt; Fe.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid</p> Terminal<pre><code>pw.x &lt; Fe.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>Fe.nnkp</code> file)</p> Terminal<pre><code>wannier90.x -pp Fe\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute:</p> <ul> <li> <p>The overlaps \\(\\langle u_{n{\\bf k}}\\vert u_{m{\\bf             k}+{\\bf b}}\\rangle\\) between spinor Bloch states     (written in the <code>Fe.mmn</code> file)</p> </li> <li> <p>The projections for the starting guess (written in the <code>Fe.amn</code>     file)</p> </li> <li> <p>The spin matrix elements \\(\\langle \\psi_{n{\\bf             k}}\\vert \\sigma_i\\vert \\psi_{m{\\bf k}}\\rangle\\),     \\(i=x,y,z\\) (written in the <code>Fe.spn</code> file)</p> </li> </ul> Terminal<pre><code>pw2wannier90.x &lt; Fe.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.\\</p> Terminal<pre><code>wannier90.x Fe\n</code></pre> </li> <li> <p>Run <code>postw90</code>\u00a0to compute the energy eigenvalues and spin expectation     values.</p> Terminal<pre><code>postw90.x Fe # (1)! \nmpirun -np 8 postw90.x Fe # (2)!\n</code></pre> <ol> <li>serial execution</li> <li>example of parallel execution with 8 MPI processes</li> </ol> </li> </ol> <p>In this tutorial we use the module <code>kpath</code> to plot the energy bands coloured by the expectation value of the spin along [001]:</p> Input file<pre><code>kpath = true\n\nkpath_task = bands\n\nkpath_bands_colour = spin\n\nkpath_num_points=500\n</code></pre> <p>To plot the bands using <code>gnuplot</code> (version 4.2 or higher) issue</p> Terminal<pre><code>gnuplot\n</code></pre> Gnuplot shell<pre><code>load 'Fe-bands.gnu'\n</code></pre> <p>or, using <code>python</code>,</p> Terminal<pre><code>python Fe-bands.py\n</code></pre> <p>Next we plot the Fermi-surface contours on the (010) plane \\(k_y=0\\), using the <code>kslice</code> module. Set <code>kpath = false</code> and uncomment the following instructions in <code>Fe.win</code>,</p> Input file<pre><code>kslice = true\n\nkslice_task = fermi_lines\n\nfermi_energy = [insert your value here]\n\nkslice_corner = 0.0 0.0 0.0\n\nkslice_b1 = 0.5 -0.5 -0.5\n\nkslice_b2 = 0.5 0.5 0.5\n\nkslice_2dkmesh = 200 200\n</code></pre> <p>taking the Fermi level value from <code>scf.out</code>. The energy eigenvalues are computed on a \\(200\\times 200\\) \\(k\\)-point grid covering the BZ slice. The lines of intersection between the Fermi surface and the (010) plane can be visualized with the <code>gnuplot</code> or <code>python</code> scripts generated at runtime,</p> Terminal<pre><code>gnuplot\n</code></pre> Gnuplot shell<pre><code>load 'Fe-kslice-fermi_lines.gnu'\n</code></pre> <p>or</p> Terminal<pre><code>python Fe-kslice-fermi_lines.py\n</code></pre> <p>The Fermi lines can be colour-coded by the spin expectation value \\(\\langle S_z\\rangle\\) of the states on the Fermi surface. Add to <code>Fe.win</code> the line</p> Input file<pre><code>kslice_fermi_lines_colour = spin\n</code></pre> <p>and re-run <code>postw90</code>. The names of the <code>gnuplot</code> and <code>python</code> scripts generated at runtime are unchanged. (However, the plotting algorithm is different in this case, and the lines are not as smooth as before. You may want to increase <code>kslice_2dkmesh</code>.)</p>"},{"location":"tutorials/tutorial_17/#further-ideas","title":"Further ideas","text":"<ul> <li> <p>Redraw the Fermi surface contours on the (010) plane starting from a     calculation without spin-orbit coupling, by adding to the input     files <code>iron_{up,down}.win</code> in Tutorial\u00a08 the lines</p> Input file<pre><code>kslice = true\n\nkslice_task = fermi_lines\n\nfermi_energy = \\[insert your value here\\]\n\nkslice_corner = 0.0 0.0 0.0\n\nkslice_b1 = 0.5 -0.5 -0.5\n\nkslice_b2 = 0.5 0.5 0.5\n\nkslice_2dkmesh = 200 200\n</code></pre> <p>before running <code>postw90</code>,</p> Input file<pre><code>postw90.x iron_up\n\npostw90.x iron_dn\n</code></pre> <p>The <code>python</code> scripts generated at runtime draw the up- and down-spin Fermi lines on separate figures. To draw them together, use the script <code>iron_updn-kslice-fermi_lines.py</code> provided with Tutorial\u00a017 (or merge the two generated scripts). Compare the Fermi lines with and without spin-orbit, and note the spin-orbit-induced avoided crossings.</p> </li> <li> <p>In Tutorial\u00a08     we obtained MLWFs separately for the up- and down-spin     channels of bcc Fe without spin-orbit. The Wannier-interpolated DOS     was therefore automatically separated into minority and majority     contributions. For a spinor calculation we can still spin-decompose     the DOS, using</p> Input file<pre><code>dos = true\n\nspin_decomp = true\n\ndos_kmesh = 25 25 25\n</code></pre> <p>The data file <code>Fe-dos.dat</code> created by <code>postw90</code> contains the up-spin and down-spin contributions in the third and fourth columns,</p> Terminal<pre><code>gnuplot\n</code></pre> Gnuplot shell<pre><code>plot 'Fe-dos.dat' u (-\\$3):(\\$1-12.6285) w\nl,'Fe-dos.dat' u (\\$4):(\\$1-12.6285) w l\n</code></pre> <p>(You should replace 12.6285 with your value of the Fermi energy). An alternative approach is to project the DOS onto the up-spin and down-spin WFs separately. To find the DOS projected onto the up-spin (odd-numbered) WFs replace <code>spin_decomp = true</code> with</p> Input file<pre><code>dos_project = 1,3,5,7,9,11,13,15,17\n</code></pre> <p>and re-run <code>postw90</code>. This approach has the advantage that it does not require the <code>Fe.spn</code> file.</p> </li> </ul> <ol> <li> <p>Please note the following counterintuitive feature in <code>pwscf</code>: in order to obtain a ground state with magnetization along the positive z-axis, one should use a negative value for the variable <code>starting_magnetization</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_18/","title":"18: Iron \u2014 Berry curvature, anomalous Hall conductivity and optical conductivity","text":"<p>Note: This tutorial requires a recent version of the <code>pw2wannier90</code> interface.</p> <ul> <li> <p>Outline: Calculate the Berry curvature, anomalous Hall     conductivity, and (magneto)optical conductivity of ferromagnetic bcc     Fe with spin-orbit coupling. In preparation for this tutorial it may     be useful to read Ref.\u00a0<sup>1</sup> and Ch.\u00a011 of the User Guide.</p> </li> <li> <p>Directory: <code>tutorials/tutorial18/</code> Files can be downloaded from here</p> </li> <li> <p>Input files</p> <ul> <li> <p><code>Fe.scf</code> The <code>pwscf</code>\u00a0input file for ground state     calculation</p> </li> <li> <p><code>Fe.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states on a uniform grid</p> </li> <li> <p><code>Fe.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>Fe.win</code> The <code>wannier90</code> and <code>postw90</code> input file</p> </li> </ul> </li> </ul> <p>The sequence of steps below is the same of Tutorial\u00a017. If you have already run that example, you can reuse the output files from steps 1 \u2014 5, and only step 6 must be carried out again using the new input file <code>Fe.win</code>.</p> <ol> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of iron</p> Terminal<pre><code>pw.x &lt; Fe.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid</p> Terminal<pre><code>pw.x &lt; Fe.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>Fe.nnkp</code> file)</p> Terminal<pre><code>wannier90.x -pp Fe\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlaps between Bloch states and     the projections for the starting guess (written in the <code>Si.mmn</code> and     <code>Si.amn</code> files)</p> Terminal<pre><code>pw2wannier90.x &lt; Fe.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs</p> Terminal<pre><code>wannier90.x Fe\n</code></pre> </li> <li> <p>Run <code>postw90</code></p> Terminal<pre><code>postw90.x Fe # (1)! \nmpirun -np 8 postw90.x Fe # (2)!\n</code></pre> <ol> <li>serial execution</li> <li>example of parallel execution with 8 MPI processes</li> </ol> </li> </ol>"},{"location":"tutorials/tutorial_18/#berry-curvature-plots","title":"Berry curvature plots","text":"<p>The Berry curvature \\(\\Omega_{\\alpha\\beta}({\\bf k})\\) of the occupied states is defined in this equation of the User Guide. The following lines in <code>Fe.win</code> are used to calculate the energy bands and the Berry curvature (in bohr\\(^2\\)) along high-symmetry lines in \\(k\\)-space.</p> Input file<pre><code>fermi_energy = [insert your value here]\n\nberry_curv_unit = bohr2\n\nkpath = true\n\nkpath_task = bands+curv\n\nkpath_bands_colour = spin\n\nkpath_num_points = 1000\n</code></pre> <p>After executing <code>postw90</code>, plot the Berry curvature component \\(\\Omega_z({\\bf k})=\\Omega_{xy}({\\bf k})\\) along the magnetization direction using the script generated at runtime,</p> Terminal<pre><code>python Fe-bands+curv_z.py\n</code></pre> <p>and compare with Fig.\u00a02 of Ref.\u00a0<sup>1</sup>.</p> <p>In Tutorial 17 we plotted the Fermi lines on the (010) plane \\(k_y=0\\). To combine them with a heatmap plot of (minus) the Berry curvature set <code>kpath = false</code>, uncomment the following lines in <code>Fe.win</code>, re-run <code>postw90</code>, and issue</p> Terminal<pre><code>python Fe-kslice-curv_z+fermi_lines.py\n</code></pre> <p>Compare with Fig.\u00a03 in Ref.\u00a0<sup>1</sup>. Note how the Berry curvature \"hot-spots\" tend to occur near spin-orbit-induced avoided crossings (the Fermi lines with and without spin-orbit were generated in Tutorial\u00a017).</p>"},{"location":"tutorials/tutorial_18/#anomalous-hall-conductivity","title":"Anomalous Hall conductivity","text":"<p>The intrinsic anomalous Hall conductivity (AHC) is proportional to the BZ integral of the Berry curvature. In bcc Fe with the magnetization along \\(\\hat{\\bf z}\\), the only nonzero components are \\(\\sigma_{xy}=-\\sigma_{yx}\\). To evaluate the AHC using a \\(25\\times 25\\times 25\\) \\(k\\)-point mesh, set <code>kslice = false</code>, uncomment the following lines in <code>Fe.win</code>,</p> Input file<pre><code>berry = true\n\nberry_task = ahc\n\nberry_kmesh = 25 25 25\n</code></pre> <p>and re-run <code>postw90</code>. The AHC is written in the output file <code>Fe.wpout</code> in vector form. For bcc Fe with the magnetization along [001], only the \\(z\\)-component \\(\\sigma_{xy}\\) is nonzero.</p> <p>As a result of the strong and rapid variations of the Berry curvature across the BZ, the AHC converges rather slowly with \\(k\\)-point sampling, and a \\(25\\times 25\\times 25\\) does not yield a well-converged value.</p> <p>-   Increase the BZ mesh density by changing <code>berry_kmesh</code>.</p> <p>-   To accelerate the convergence, adaptively refine the mesh around     spikes in the Berry curvature, by adding to <code>Fe.win</code> the lines</p> <p>This adds a \\(5\\times 5\\times 5\\) fine mesh around those points where \\(\\vert{\\bm \\Omega}({\\bf k})\\vert\\) exceeds 100\u00a0bohr\\(^2\\). The percentage of points triggering adaptive refinement is reported in <code>Fe.wpout</code>.</p> <p>Compare the converged AHC value with those obtained in Refs.\u00a0<sup>2</sup> and\u00a0<sup>1</sup>.</p> <p>The Wannier-interpolation formula for the Berry curvature comprises three terms, denoted \\(D\\)-\\(D\\), \\(D\\)-\\(\\overline{A}\\), and \\(\\overline{\\Omega}\\) in Ref.\u00a0<sup>2</sup>, and \\(J2\\), \\(J1\\), and \\(J0\\) in Ref.\u00a0<sup>3</sup>. To report in <code>Fe.wpout</code> the decomposition of the total AHC into these three terms, set <code>iprint</code> (verbosity level) to a value larger than one in <code>Fe.win</code>.</p>"},{"location":"tutorials/tutorial_18/#optical-conductivity","title":"Optical conductivity","text":"<p>The optical conductivity tensor of bcc Fe with magnetization along \\(\\hat{\\bf z}\\) has the form</p> \\[ \\bm{\\sigma}=\\bm{\\sigma}^{\\rm S}+\\bm{\\sigma}^{\\rm A}= \\left( \\begin{array}{ccc} \\sigma_{xx} &amp; 0 &amp; 0\\\\ 0 &amp; \\sigma_{xx} &amp; 0\\\\ 0 &amp; 0 &amp; \\sigma_{zz} \\end{array} \\right)+ \\left( \\begin{array}{ccc} 0 &amp; \\sigma_{xy} &amp; 0 \\\\ -\\sigma_{xy} &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 \\end{array} \\right), \\] <p>where \"S\" and \"A\" stand for the symmetric and antisymmetric parts and \\(\\sigma_{xx}=\\sigma_{yy}\\not=\\sigma_{zz}\\). The dc AHC calculated earlier corresponds to \\(\\sigma_{xy}\\) in the limit \\(\\omega\\rightarrow 0\\). At finite frequency \\(\\sigma_{xy}=-\\sigma_{yx}\\) acquires an imaginary part which describes magnetic circular dichoism (MCD).</p> <p>To compute the complex optical conductivity for \\(\\hbar\\omega\\) up to 7\u00a0eV, replace</p> Input file<pre><code>berry_task = ahc\n</code></pre> <p>with</p> Input file<pre><code>berry_task = kubo\n</code></pre> <p>add the line</p> Input file<pre><code>kubo_freq_max = 7.0\n</code></pre> <p>and re-run <code>postw90</code>. Reasonably converged spectra can be obtained with a \\(125\\times 125\\times 125\\) \\(k\\)-point mesh. Let us first plot the ac AHC in S/cm, as in the lower panel of Fig.\u00a05 in Ref.\u00a0<sup>1</sup>,</p> Terminal<pre><code>gnuplot\n</code></pre> Gnuplot shell<pre><code>plot 'Fe-kubo_A_xy.dat' u 1:2 w l\n</code></pre> <p>Comapare the \\(\\omega\\rightarrow 0\\) limit with the result obtained earlier by integrating the Berry curvature.</p> <p>Note</p> <p>The calculation of the AHC using <code>berry_task = kubo</code> involves a truncation of the sum over empty states in the Kubo-Greenwood formula: see description of the keyword <code>kubo_eigval_max</code> in the User Guide. As discussed around the formula for anomalous Hall conductivity of the User Guide, no truncation is done with <code>berry_task = ahc</code>.</p> <p>Next we plot the MCD spectrum. Following Ref.\u00a0<sup>1</sup>, we plot \\({\\rm Im}[\\omega\\sigma_{xy}(\\hbar\\omega)]\\), in units of \\(10^{29}\\)\u00a0sec\\(^{-2}\\). The needed conversion factor is \\(9\\times 10^{-18}\\times e/\\hbar\\simeq 0.0137\\) (\\(e\\) and \\(\\hbar\\) in SI units),</p> Gnuplot shell<pre><code>set yrange[-5:15]\nplot 'Fe-kubo_A_xy.dat' u 1:(\\$1)\\*(\\$3)\\*0.0137 w l\n</code></pre>"},{"location":"tutorials/tutorial_18/#further-ideas","title":"Further ideas","text":"<p>-   Recompute the AHC and optical spectra of bcc Fe using projected \\(s\\),     \\(p\\), and \\(d\\)-type Wannier functions instead of the hybridrized MLWFs     (see Tutorial\u00a08),     and compare the results.</p> <p>-   A crude way to model the influence of heterovalent alloying on the     AHC is to assume that its only effect is to donate or deplete     electrons, i.e., to shift the Fermi level of the pure     crystal\u00a0<sup>4</sup>. Recalculate the AHC of bcc Fe for a range of Fermi     energies within     \\(\\pm 0.5\\)\u00a0eV of the true Fermi level. This calculation can be     streamlined by replacing in <code>Fe.win</code></p> Input file<pre><code>fermi_energy = [insert your value here]\n</code></pre> <p>with</p> Input file<pre><code>fermi_energy_min = [insert here your value minus 0.5]\n\nfermi_energy_max = [insert here your value plus 0.5]\n</code></pre> <p>Use a sufficiently dense BZ mesh with adaptive refinement. To plot \\(\\sigma_{xy}\\) versus \\(\\varepsilon_F\\), issue</p> Terminal<pre><code>gnuplot\n</code></pre> Gnuplot shell<pre><code>plot 'Fe-ahc-fermiscan.dat' u 1:4 w lp\n</code></pre> <ol> <li> <p>Y. Yao, L. Kleinman, A. H. MacDonald, J. Sinova, T. Jungwirth, D.-S. Wang, E. Wang, and Q. Niu. Phys. Rev. Lett., 92:037204, 2004.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>X. Wang, J. R. Yates, I. Souza, and D. Vanderbilt. Ab initio calculation of the anomalous hall conductivity by wannier interpolation. Phys. Rev. B, 74:195118, 2006.\u00a0\u21a9\u21a9</p> </li> <li> <p>M. G. Lopez, D. Vanderbilt, T. Thonhauser, and I. Souza. Phys. Rev. B, 85:014435, 2012.\u00a0\u21a9</p> </li> <li> <p>Y. Yao, Y. Liang, D. Xiao, Q. Niu, S.-Q. Shen, X. Dai, and Z. Fang. Phys. Rev. B, 75:020401, 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_19/","title":"19: Iron \u2014 Orbital magnetization","text":"<p>Note: This tutorial requires a recent version of the <code>pw2wannier90</code> interface.</p> <ul> <li> <p>Outline: Calculate the orbital magnetization of ferromagnetic bcc     Fe by Wannier interpolation.</p> </li> <li> <p>Directory: <code>tutorials/tutorial19/</code> Files can be downloaded from here</p> </li> <li> <p>Input files</p> <ul> <li> <p><code>Fe.scf</code> The <code>pwscf</code>\u00a0input file for ground state     calculation</p> </li> <li> <p><code>Fe.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states on a uniform grid</p> </li> <li> <p><code>Fe.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>Fe.win</code> The <code>wannier90</code> and <code>postw90</code> input file</p> </li> </ul> </li> </ul> <p>The sequence of steps below is the same of Tutorials\u00a017 and 18. If you have already run one of those tutorials, you can reuse the output files from steps 1 \u2014 3 and 5. Steps\u00a04 and 6 should be carried out again using the new input files <code>Fe.pw2wan</code> and <code>Fe.win</code>.</p> <ol> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of iron</p> Terminal<pre><code>pw.x &lt; Fe.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid</p> Terminal<pre><code>pw.x &lt; Fe.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>Fe.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp Fe\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute:</p> <ul> <li> <p>The overlaps \\(\\langle u_{n{\\bf k}}\\vert u_{m{\\bf k}+{\\bf               b}}\\rangle\\) (written in the <code>Fe.mmn</code> file)</p> </li> <li> <p>The projections for the starting guess (written in the <code>Fe.amn</code>     file)</p> </li> <li> <p>The matrix elements \\(\\langle u_{n{\\bf k}+{\\bf b}_1}\\vert           H_{\\bf k}\\vert u_{m{\\bf k}+{\\bf b}_2}\\rangle\\) (written in     the <code>Fe.uHu</code> file)</p> </li> </ul> Terminal<pre><code>pw2wannier90.x &lt; Fe.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x Fe\n</code></pre> </li> <li> <p>Run <code>postw90</code>\u00a0to compute the orbital magnetization.</p> Terminal<pre><code>postw90.x Fe # (1)! \nmpirun -np 8 postw90.x Fe  # (2)!\n</code></pre> <ol> <li>serial execution</li> <li>example of parallel execution with 8 MPI processes</li> </ol> </li> </ol> <p>The orbital magnetization is computed as the BZ integral of the quantity \\({\\bf M}^{\\rm orb}({\\bf k})\\) defined in this equation of the User Guide. The relevant lines in <code>Fe.win</code> are</p> Input file<pre><code>berry = true\n\nberry_task = morb\n\nberry_kmesh = 25 25 25\n\nfermi_energy = [insert your value here]\n</code></pre> <p>After running <code>postw90</code>, compare the value of the orbital magnetization reported in <code>Fe.wpout</code> with the spin magnetization in <code>scf.out</code>. Set <code>iprint = 2</code> to report the decomposition of \\({\\bf M}^{\\rm orb}\\) into the terms \\(J0\\), \\(J1\\), and \\(J2\\) defined in Ref.\u00a0<sup>1</sup>.</p> <p>To plot \\(M_z^{\\rm orb}({\\bf k})\\) along high-symmetry lines set <code>berry = false</code> and uncomment in <code>Fe.win</code> the block of instructions containing</p> Input file<pre><code>kpath = true\n\nkpath_task = bands+morb\n</code></pre> <p>After running <code>postw90</code>, issue</p> Terminal<pre><code>python Fe-bands+morb_z.py\n</code></pre> <p>Compare with Fig.\u00a02 of Ref.\u00a0<sup>1</sup>, bearing in mind the factor of \\(-1/2\\) difference in the definition of \\({\\bf M}^{\\rm   orb}({\\bf k})\\) (see Ch.\u00a011 in the User Guide).</p> <p>To plot \\(M_z^{\\rm orb}({\\bf k})\\) together with the Fermi contours on the (010) BZ plane set <code>kpath = false</code>, uncomment in <code>Fe.win</code> the block of instructions containing</p> Input file<pre><code>kslice = true\n\nkslice_task = morb+fermi_lines\n</code></pre> <p>re-run <code>postw90</code>, and issue</p> Terminal<pre><code>python Fe-kslice-morb_z+fermi_lines.py\n</code></pre> <p>\\(M_z^{\\rm orb}({\\bf k})\\) is much more evenly distributed in \\(k\\)-space than the Berry curvature (see Tutorial 18). As a result, the integrated orbital magnetization converges more rapidly with the BZ sampling.</p> <ol> <li> <p>M. G. Lopez, D. Vanderbilt, T. Thonhauser, and I. Souza. Phys. Rev. B, 85:014435, 2012.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_2/","title":"2: Lead \u2014 Wannier-interpolated Fermi surface","text":"<ul> <li> <p>Outline: Obtain MLWFs for the four lowest states in lead. Use     Wannier interpolation to plot the Fermi surface.</p> </li> <li> <p>Generation Details: From <code>pwscf</code>, using norm-conserving     pseudopotentials and a      4\\(\\times\\)4\\(\\times\\)4 k-point grid.     Starting guess: atom-centred sp\\(^3\\) hybrid orbitals</p> </li> <li> <p>Directory: <code>tutorials/tutorial02/</code> Files can be downloaded from here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>lead.win</code> The master input file</p> </li> <li> <p><code>lead.mmn</code> The overlap matrices     \\(\\mathbf{M}^{(\\mathbf{k},\\mathbf{b})}\\)</p> </li> <li> <p><code>lead.amn</code> Projection \\(\\mathbf{A}^{(\\mathbf{k})}\\) of the Bloch     states onto a set of trial localised orbitals</p> </li> <li> <p><code>lead.eig</code> The Bloch eigenvalues at each k-point. For     interpolation only</p> </li> </ul> </li> </ul> <p>The four lowest valence bands in lead are separated in energy from the higher conduction states (see bandstructure plot). The MLWFs of these states have partial occupancy. MLWFs describing only the occupied states would be poorly localised.</p> <ol> <li> <p>Run <code>wannier90</code>\u00a0to minimise the MLWFs spread</p> Terminal<pre><code>wannier90.x lead\n</code></pre> <p>Inspect the output file <code>lead.wout</code>.</p> </li> <li> <p>Use Wannier interpolation to generate the Fermi surface of lead.     Rather than re-running the whole calculation we can use the unitary     transformations obtained in the first calculation and restart from     the plotting routine. Add the following keywords to the <code>lead.win</code>     file:</p> Input file<pre><code>restart = plot\nfermi_energy = 5.2676\nfermi_surface_plot = true\n</code></pre> <p>and re-run <code>wannier90</code>. The value of the Fermi energy (5.2676\u2006eV) was obtained from the initial first principles calculation. <code>wannier90</code>\u00a0calculates the band energies, through</p> <p>interpolation, on a dense mesh of k-points in the Brillouin zone. The density of this grid is controlled by the keyword <code>fermi_surface_num_points</code>. The default value is 50 (i.e., 50\\(^3\\) points). The Fermi surface file <code>lead.bxsf</code> can be viewed using <code>XCrySDen</code>, e.g.,</p> Terminal<pre><code>xcrysden --bxsf lead.bxsf\n</code></pre> </li> </ol>  Bandstructure of lead showing the position of the Fermi level. Only the lowest four bands are included in the calculation."},{"location":"tutorials/tutorial_20/","title":"20: Disentanglement restricted inside spherical regions of \\(k\\) space","text":""},{"location":"tutorials/tutorial_20/#lavo_3","title":"LaVO\\(_3\\)","text":"<ul> <li> <p>Outline: Obtain disentangled MLWFs for strained LaVO\\(_3\\).</p> </li> <li> <p>Directory: <code>tutorials/tutorial20/</code> Files can be downloaded from here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>LaVO3.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>LaVO3.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states on a uniform grid</p> </li> <li> <p><code>LaV03.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>LaVO3.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of LaVO\\(_3\\).</p> <p><code>``bash title=\"Terminal\"</code>pw.x &lt; LaVO3.scf &gt; scf.out`</p> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid.</p> Terminal<pre><code>pw.x &lt; LaVO3.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>LaVO3.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp LaVO3\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states and     the projections for the starting guess (written in the <code>LaVO3.mmn</code>     and <code>LaVO3.amn</code> files).</p> Terminal<pre><code>pw2wannier90.x &lt; LaVO3.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x LaVO3\n</code></pre> </li> </ul> <p>Inspect the output file <code>LaVO3.wout</code>. In the initial summary, you will see that the disentanglement was performed only within one sphere of radius 0.2 arount the point \\(A=(0.5, 0.5, 0.5)\\) in reciprocal space:</p> Output file<pre><code>|  Number of spheres in k-space              :                 1             |\n|   center n.   1 :     0.500   0.500   0.500,    radius   =   0.200         |\n</code></pre> <p>Compare the band structure that Wannier90 produced with the one obtained using Quantum ESPRESSO. You should get something similar to this. Notice how the \\(t_{2g}\\)-bands are entangled with other bands at \\(A\\) and the Wannier-interpolated band structure deviates from the Bloch bands only in a small region around that \\(k\\)-point. It is important to keep in mind that all symmetry equivalent \\(k\\)-points within the first Brillouin zone must be written explicitly in the list of sphere centers. For instance, the \\(A\\) point in the simple tetragonal lattice of this tutorial is non-degenerate, while the \\(X\\) point has degeneracy two, hence one must specify both \\((1/2,0,0)\\) and \\((0,1/2,0)\\) (see the SrMnO\\(_3\\) example here below).</p>"},{"location":"tutorials/tutorial_20/#further-ideas","title":"Further ideas","text":"<ul> <li> <p>Try to obtain the Wannier functions using the standard disentanglement procedure (without spheres, <code>dis_spheres_num = 0</code>). You will notice that the Wannier-interpolated band structure now shows deviations also in regions of \\(k\\)-space far away from \\(A\\), where disentanglement is actually not necessary. If you disable the disentanglement completely, instead, the Wannierisation procedure does not converge.</p> </li> <li> <p>In order to illustrate all possible cases, it is instructive to apply this method to SrMnO\\(_3\\), where the \\(t_{2g}\\) bands are entangled with the above-lying \\(e_g\\) bands, and also with the deeper O-\\(2p\\) states. In the SrMnO\\(_3\\) subfolder, you can find input files for building three different sets of Wannier functions: only \\(t_{2g}\\) states, only \\(e_g\\) states, or all V-\\(3d\\)-derived states (\\(t_{2g} + e_g\\)). In each case one needs to specify different disentanglement spheres, according to which region(s) in \\(k\\)-space show entanglement of the targeted bands. Also the index <code>dis_sphere_first_wan</code> needs to be adapted to the new disentanglement window, which here contains also states below the lowest-lying Wannier function (at variance with the LaVO\\(_3\\) case).</p> </li> </ul>  Band structure of epitaxially-strained (tetragonal) LaVO<sub>3</sub>. Black: Bloch bands; red circles: Wannier-interpolated band structure. The disentanglement was performed only for k-points within a sphere of radius 0.2 \u212b<sup>\u22121</sup> centered in A."},{"location":"tutorials/tutorial_21/","title":"21: Gallium Arsenide \u2014 Symmetry-adapted Wannier functions","text":"<p>Note: This tutorial requires a recent version of the <code>pw2wannier90</code> interface.</p> <ul> <li> <p>Outline: Obtain symmetry-adapted Wannier functions out of four     valence bands of GaAs. For the theoretical background of the     symmetry-adapted Wannier functions, see R. Sakuma, Phys. Rev. B     87, 235109 (2013).</p> </li> <li> <p>Directory: <code>tutorials/tutorial21/atom_centered_As_sp/</code> Files can be     downloaded from     here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>GaAs.scf</code> The <code>pwscf</code>\u00a0input file for ground state     calculation</p> </li> <li> <p><code>GaAs.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states on a uniform grid</p> </li> <li> <p><code>GaAs.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>GaAs.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of GaAs</p> Terminal<pre><code>pw.x &lt; GaAs.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid</p> Terminal<pre><code>pw.x &lt; GaAs.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>GaAs.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp GaAs\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states, the     projections for the starting guess, and the symmetry information     needed for symmetry-adapted mode (written in the <code>GaAs.mmn</code>,     <code>GaAs.amn</code>, and <code>GaAs.dmn</code> files, respectively).</p> Terminal<pre><code>pw2wannier90.x &lt; GaAs.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x GaAs\n</code></pre> </li> </ul> <p>Each directory creates different kind of symmetry-adapted Wannier function. See more detail in <code>tree/develop/tutorials/tutorial21/README</code>.</p>"},{"location":"tutorials/tutorial_22/","title":"22: Copper \u2014 Symmetry-adapted Wannier functions","text":"<p>Note: This tutorial requires a recent version of the <code>pw2wannier90</code> interface.</p> <ul> <li> <p>Outline: Obtain symmetry-adapted Wannier functions for Cu. By     symmetry-adapted mode, for example, we can make atomic centered     \\(s\\)-like Wannier function, which is not possible in the usual     procedure to create maximally localized Wannier functions. For the     theoretical background of the symmetry-adapted Wannier functions,     see R. Sakuma, Phys. Rev. B 87, 235109 (2013).</p> </li> <li> <p>Directory: <code>tutorials/tutorial22/s_at_0.00/</code> Files can be downloaded from here     \\</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>Cu.scf</code> The <code>pwscf</code>\u00a0input file for ground state     calculation</p> </li> <li> <p><code>Cu.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states on a uniform grid</p> </li> <li> <p><code>Cu.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>Cu.sym</code> Used only in <code>tutorials/tutorial22/s_at_0.25/</code>.     <code>pw2wannier90</code> reads this file when <code>\u201cread_sym = .true.\u201d</code> in     <code>Cu.pw2wan</code>. By default,     <code>\u201cread_sym = .false.\u201d and ``Cu.sym`` is the output of ``pw2wannier90</code>,     in which the symmetry operations employed in the calculation are     written for reference.</p> </li> <li> <p><code>Cu.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of Cu</p> Terminal<pre><code>pw.x &lt; Cu.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid</p> Terminal<pre><code>pw.x &lt; Cu.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>Cu.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp Cu\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states, the     projections for the starting guess, and the symmetry information     needed for symmetry-adapted mode (written in the <code>Cu.mmn</code>, <code>Cu.amn</code>,     and <code>Cu.dmn</code> files, respectively).</p> Terminal<pre><code>pw2wannier90.x &lt; Cu.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x Cu\n</code></pre> </li> </ul> <p>Each directory creates \\(s\\)-like symmetry-adapted Wannier function centered at different position on top of atomic centered \\(d\\)-like Wannier functions. See more detail in <code>tutorials/tutorial22/README</code>.</p>"},{"location":"tutorials/tutorial_23/","title":"23: Silicon \u2014 \\(G_0W_0\\) bands structure interpolation","text":"<p>Note: This tutorial requires a recent version of the <code>ypp</code> post-processing code of <code>yambo</code>.</p> <ul> <li> <p>Outline: Interpolate the bands structure of silicon obtained from     many-body perturbation theory at the \\(G_0W_0\\) level. Using the     <code>yambo</code> code, the quasi-particle corrections (QP) are summed to     Kohn-Sham eigenvalues, while the wavefunctions remain the same.</p> </li> <li> <p>Directory: <code>tutorials/tutorial23/</code> Files can be downloaded from here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>silicon.scf</code> The <code>pwscf</code>\u00a0input file for the     ground state calculation</p> </li> <li> <p><code>silicon.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states on a uniform grid</p> </li> <li> <p><code>silicon.gw.nscf</code> The <code>pwscf</code>\u00a0input file to     obtain Bloch states on a reduced grid with many empty bands</p> </li> <li> <p><code>silicon.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>silicon.win</code> The <code>wannier90</code> input file</p> </li> <li> <p><code>silicon.gw.win</code> The <code>wannier90</code> input file (for the \\(G_0W_0\\)     step)</p> </li> <li> <p><code>yambo.in</code> The <code>yambo</code> input file</p> </li> <li> <p><code>ypp.in</code> The <code>ypp</code> input file</p> </li> </ul> </li> <li> <p>Copy the input files from the <code>INPUT directory</code> into a working     directory (e.g. <code>WORK</code>)</p> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state charge of     silicon</p> Terminal<pre><code>pw.x &lt; silicon.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states reduced grid. We     use a 8x8x8 with many bands (many empty bands are needed to perform     a \\(G_0W_0\\) with <code>yambo</code>)</p> Terminal<pre><code>pw.x &lt; silicon.gw.nscf &gt; nscf.gw.out\n</code></pre> </li> <li> <p>Use the <code>k_mapper.py</code> utility to find the indexes of a 4x4x4 uniform     grid into the 8x8x8 reduced grid</p> Terminal<pre><code>./k_mapper.py 4 4 4 \"..tutorials/tutorial23/WORK/nscf.gw.out\"\n</code></pre> <p>Use the output to complete the <code>yambo.in</code> input file (you also need to specify how many bands you want to compute the QP corrections, here you can use all the bands from 1 to 14). Then, you should have obtained something like:</p> Output file<pre><code> 1| 1| 1|14|\n3| 3| 1|14|\n5| 5| 1|14|\n13| 13| 1|14|\n...\n</code></pre> </li> <li> <p>Enter the <code>si.save</code> directory and run <code>p2y</code>. A <code>SAVE</code> folder is     created, you can move it up in the <code>/WORK/</code> directory.</p> </li> <li> <p>Run a \\(G_0W_0\\) calculation from the <code>/WORK/</code> directory (remember, we     are using a 8x8x8 grid but computing QP corrections only on a 4x4x4     grid)</p> Terminal<pre><code>yambo \n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid</p> Terminal<pre><code>pw.x &lt; silicon.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>silicon.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp silicon\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states, the     projections for the starting guess (written in the <code>silicon.mmn</code> and     <code>silicon.amn</code> respectively).</p> Terminal<pre><code>pw2wannier90.x &lt; silicon.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x silicon\n</code></pre> <p>At this point, you should have obtained the interpolated valence bands for silicon at the DFT level.</p> </li> <li> <p>Run a <code>ypp</code> calculation (just type <code>ypp</code>)</p> Terminal<pre><code>ypp\n</code></pre> <p>You should obtain a file <code>silicon.gw.unsorted.eig</code> which contains the QP corrections on a uniform 4x4x4 grid.</p> </li> <li> <p>Run the gw2wannier90.py script to reorder, align and correct all     matrices and files using the QP corrections</p> Terminal<pre><code>../../../utility/gw2wannier90.py silicon mmn amn\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x silicon.gw\n</code></pre> <p>At this point, you should have obtained the interpolated valence bands for silicon at the \\(G_0W_0\\) level.</p> </li> </ul> <p>After you completed the tutorial for the valence bands only, you can repeat the final steps to interpolate also some conduction bands using disentanglement (the code is already present as comments in the input files).</p>"},{"location":"tutorials/tutorial_24/","title":"24: Tellurium \u2014 gyrotropic effects","text":"<ul> <li> <p>Outline: Calculate the gyrotropic effects in trigonal right-handed     Te Similar to the calculations of <sup>1</sup></p> </li> <li> <p>Directory: <code>tutorials/tutorial24/</code> Files can be downloaded from here</p> </li> <li> <p>Input files</p> <ul> <li> <p><code>Te.scf</code> The <code>pwscf</code>\u00a0input file for ground state     calculation</p> </li> <li> <p><code>Te.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states on a uniform grid</p> </li> <li> <p><code>Te.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>Te.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> </ul> <p>To make things easy, the tutorial treats Te without spin-orbit</p> <ol> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of tellurium</p> Terminal<pre><code>pw.x &lt; Te.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     <code>3x3x4</code> k-point grid</p> Terminal<pre><code>pw.x &lt; Te.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>Te.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp Te\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute:</p> <ul> <li> <p>The overlaps \\(\\langle u_{n{\\bf k}}\\vert u_{m{\\bf k}+{\\bf               b}}\\rangle\\) (written in the <code>Te.mmn</code> file)</p> </li> <li> <p>The projections for the starting guess (written in the <code>Te.amn</code>     file)</p> </li> <li> <p>The matrix elements \\(\\langle u_{n{\\bf k}+{\\bf b}_1}\\vert           H_{\\bf k}\\vert u_{m{\\bf k}+{\\bf b}_2}\\rangle\\) (written in     the <code>Te.uHu</code> file)</p> </li> <li> <p>The spin matrix elements \\(\\langle \\psi_{n{\\bf             k}}\\vert \\sigma_i\\vert \\psi_{m{\\bf k}}\\rangle\\) (would be     written in the <code>Te.spn</code> file, but only if spin-orbit is     included, which is not the case for the present tutorial)</p> </li> </ul> Terminal<pre><code>pw2wannier90.x &lt; Te.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x Te\n</code></pre> </li> <li> <p>Add the following lines to the <code>wannier90.win</code> file:</p> Input file<pre><code>gyrotropic=true\ngyrotropic_task=-C-dos-D0-Dw-K\nfermi_energy_step=0.0025\nfermi_energy_min=5.8\nfermi_energy_max=6.2\ngyrotropic_freq_step=0.0025\ngyrotropic_freq_min=0.0\ngyrotropic_freq_max=0.1\ngyrotropic_smr_fixed_en_width=0.01\ngyrotropic_smr_max_arg=5\ngyrotropic_degen_thresh=0.001\ngyrotropic_box_b1=0.2 0.0 0.0\ngyrotropic_box_b2=0.0 0.2 0.0\ngyrotropic_box_b3=0.0 0.0 0.2\ngyrotropic_box_center=0.33333 0.33333 0.5\ngyrotropic_kmesh=50 50 50 \n</code></pre> </li> <li> <p>Run <code>postw90</code>     to compute the gyrotropic properties: tensors \\(D\\), \\(\\widetilde{D}\\),     \\(K\\), \\(C\\) (See the User Guide):</p> Terminal<pre><code>postw90.x Te # (1)!\nmpirun -np 8 postw90.x Te  # (2)!\n</code></pre> <ol> <li>serial execution</li> <li>example of parallel execution with 8 MPI processes</li> </ol> <p>The integration in the \\(k\\)-space is limited to a small area around the H point. Thus it is valid only for Fermi levels near the band gap. And one needs to multiply the results by 2, to account for the H' point. To integrate over the entire Brillouin zone, one needs to remove the <code>gyrotropic_box_</code>\\(\\ldots\\) parameters</p> </li> <li> <p>Now change the above lines to</p> Input file<pre><code>gyrotropic=true\ngyrotropic_task=-NOA\nfermi_energy=5.95\ngyrotropic_freq_step=0.0025\ngyrotropic_freq_min=0.0\ngyrotropic_freq_max=0.3\ngyrotropic_smr_fixed_en_width=0.01\ngyrotropic_smr_max_arg=5\ngyrotropic_band_list=4-9\ngyrotropic_kmesh=50 50 50\n</code></pre> <p>and compute the interband natural optical activity</p> Terminal<pre><code>postw90.x Te # (1)!\nmpirun -np 8 postw90.x Te  # (2)!\n</code></pre> <ol> <li>serial execution</li> <li>example of parallel execution with 8 MPI processes</li> </ol> </li> </ol> <ol> <li> <p>S. S. Tsirkin, P. Aguado Puente, and I. Souza. Gyrotropic effects in trigonal tellurium studied from first principles. ArXiv e-prints, October 2017. arXiv:1710.03204.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_25/","title":"25: Gallium Arsenide \u2014 Nonlinear shift current","text":"<ul> <li> <p>Outline: Calculate the nonlinear shift current of inversion     asymmetric fcc Gallium Arsenide. In preparation for this tutorial it     may be useful to read Ref. <sup>1</sup></p> </li> <li> <p>Directory: <code>tutorials/tutorial25/</code> Files can be downlowaded from here</p> </li> <li> <p>Input files:</p> <ul> <li> <p><code>GaAs.scf</code> The <code>pwscf</code> input file for ground state calculation</p> </li> <li> <p><code>GaAs.nscf</code> The <code>pwscf</code> input file to obtain Bloch states on a     uniform grid</p> </li> <li> <p><code>GaAs.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>GaAs.win</code> The <code>wannier90</code> and <code>postw90</code> input file</p> </li> </ul> </li> </ul> <p> </p> <ol> <li> <p>Run <code>pwscf</code> to obtain the ground state of Gallium Arsenide</p> Terminal<pre><code>pw.x &lt; GaAs.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code> to obtain the ground state of Gallium Arsenide</p> Terminal<pre><code>pw.x &lt; GaAs.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>Wannier90</code> to generate a list of the required overlaps     (written into the <code>GaAs.nnkp</code> file)</p> Terminal<pre><code>wannier90.x -pp GaAs\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute:</p> <ul> <li> <p>The overlaps \\(\\langle u_{n\\bf{k}}|u_{n\\bf{k+b}}\\rangle\\)     between spinor Bloch states (written in the <code>GaAs.mmn</code> file)</p> </li> <li> <p>The projections for the starting guess (written in the     <code>GaAs.amn</code> file)</p> </li> </ul> Terminal<pre><code>pw2wannier90.x &lt; GaAs.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code> to compute MLWFs</p> Terminal<pre><code>wannier90.x GaAs\n</code></pre> </li> <li> <p>Run <code>postw90</code> to compute nonlinear shift current</p> Terminal<pre><code>postw90.x GaAs` # (1)! \n\nmpirun -np 8 postw90.x GaAs  # (2)! \n</code></pre> <ol> <li>serial execution</li> <li>example of parallel execution with 8 MPI processes</li> </ol> </li> </ol>"},{"location":"tutorials/tutorial_25/#shift-current-sigma","title":"Shift current $\\sigma^","text":"<p>The shift current tensor of GaAs has only one independent component that is finite, namely \\(\\sigma^{xyz}\\). For its computation, set</p> Input file<pre><code>berry = true\nberry_task = sc\n</code></pre> <p>Like the linear optical conductivity, the shift current is a frequency-dependent quantity. The frequency window and step is controlled by <code>kubo_freq_min</code>, <code>kubo_freq_max</code> and <code>kubo_freq_step</code>, as explained in the users guide.</p> <p>The shift current requires an integral over the Brillouin zone. The interpolated k-mesh is controlled by <code>berry_kmesh</code>, which has been set to</p> Input file<pre><code>berry_kmesh = 100 100 100\n</code></pre> <p>We also need to input the value of the Fermi level in eV:</p> Input file<pre><code>fermi_energy = [insert your value here]\n</code></pre> <p>Due to the sum over intermediate states involved in the calculation of the shift current, one needs to consider a small broadening parameter to avoid numerical problems due to possible degeneracies (see parameter \\(\\eta\\) in Eq. (36) of Ref. <sup>1</sup> and related discussion). This parameter is controlled by <code>sc_eta</code>. It is normally found that values between 0.01 eV and 0.1 eV yield an stable spectrum. The default value is set to \\(0.04\\) eV.</p> <p>Finally, <code>sc_phase_conv</code> controls the phase convention used for the Bloch sums. <code>sc_phase_conv=1</code> uses the so-called tight-binding convention, whereby the Wannier centres are included into the phase, while <code>sc_phase_conv=2</code> leaves the Wannier centres out of the phase. These two possible conventions are explained in Ref. <sup>2</sup>. Note that the overall shift-current spectrum does not depend on the chosen convention, but the individual terms that compose it do.</p> <p>On output, the program generates a set of 18 files named <code>SEED-sc_***.dat</code>, which correspond to the different tensor components of the shift current (note that the 9 remaining components until totaling \\(3\\times3\\times3=27\\) can be obtained from the 18 outputed by taking into account that \\(\\sigma^{abc}\\) is symmetric under \\(b\\leftrightarrow c\\) index exchange). For plotting the only finite shift-current component of GaAs \\(\\sigma^{xyz}\\) (units of A/V\\(^{2}\\)) as in the upper panel of Fig. 3 in Ref. <sup>1</sup>,</p> Terminal<pre><code>gnuplot\n</code></pre> Gnuplot shell<pre><code>plot 'GaAs-sc_xyz.dat' u 1:2 w l\n</code></pre> <ol> <li> <p>Julen Iba\u00f1ez-Azpiroz, Stepan S. Tsirkin, and Ivo Souza. Ab initio calculation of the shift photocurrent by wannier interpolation. Phys. Rev. B, 97:245143, Jun 2018. URL: https://link.aps.org/doi/10.1103/PhysRevB.97.245143, doi:10.1103/PhysRevB.97.245143.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>T. Yusufaly, D. Vanderbilt, and S. Coh. Tight-Binding Formalism in the Context of the PythTB Package. \\url http://physics.rutgers.edu/pythtb/formalism.html.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_26/","title":"26: Gallium Arsenide \u2014 Selective localization and constrained centres","text":"<ul> <li> <p>Outline: Application of the selectively localised Wannier function     (SLWF) method to gallium arsenide (GaAs), following the example in     Ref. <sup>1</sup>, which is essential reading for this tutorial     tutorial.</p> </li> <li> <p>Directory: <code>tutorials/tutorial26/</code> Files can be downloaded from here</p> </li> <li> <p>Input files:</p> <ul> <li> <p><code>GaAs.scf</code> The <code>pwscf</code> input file for ground state calculation</p> </li> <li> <p><code>GaAs.nscf</code> The <code>pwscf</code> input file to obtain Bloch states on a     uniform grid</p> </li> <li> <p><code>GaAs.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>GaAs.win</code> The <code>wannier90</code> and <code>postw90</code> input file</p> </li> </ul> </li> </ul> <p> </p> <ol> <li> <p>Run <code>pwscf</code> to obtain the ground state of Gallium Arsenide</p> Terminal<pre><code>pw.x &lt; GaAs.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code> to obtain the ground state of Gallium Arsenide</p> Terminal<pre><code>pw.x &lt; GaAs.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>Wannier90</code> to generate a list of the required overlaps     (written into the <code>GaAs.nnkp</code> file)</p> Terminal<pre><code>wannier90.x -pp GaAs\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute:</p> <ul> <li> <p>The overlaps \\(\\langle u_{n\\bf{k}}|u_{n\\bf{k+b}}\\rangle\\)     between Bloch states (written in the <code>GaAs.mmn</code> file)</p> </li> <li> <p>The projections for the starting guess (written in the     <code>GaAs.amn</code> file)</p> </li> </ul> Terminal<pre><code>pw2wannier90.x &lt; GaAs.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Inspect the <code>.win</code> file.</p> <ul> <li> <p>Make sure you understand the new keywords corresponding to     the selective localisation algorithm.</p> </li> <li> <p>Run <code>wannier90</code> to compute the SLWFs, in this case using one     objective Wannier function.</p> </li> </ul> Terminal<pre><code>wannier90.x GaAs\n</code></pre> <p>To constrain the centre of the SLWF you need to add <code>slwf_constrain = true</code> and\\ <code>slwf_lambda = 1</code> to the input file and uncomment the <code>slwf_centres</code> block. This will add a penalty functional to the total spread, which will try to constrain the centre of the SLWF to be on the As atom (as explained in Ref.\u00a0<sup>1</sup>, particularly from Eq.\u00a024 to Eq.\u00a035).</p> <p>Look at the value of the penalty functional, is this what you would expect at convergence? Does the chosen value of the Lagrange multiplier <code>slwf_lambda</code> give a SLWF function centred on the As atom?</p> <p>Alternatively, you can modify the <code>slwf_centres</code> block to constrain the centre of the SLWF to be on the Ga atom. Do you need a different value of <code>slwf_lambda</code> in this case to converge? Take a look at the result in Vesta and explain what you see. Do these functions transform like the identity under the action of the \\(T_d\\) group?</p> </li> </ol> <ol> <li> <p>Runzhi Wang, Emanuel A. Lazar, Hyowon Park, Andrew J. Millis, and Chris A. Marianetti. Selectively localized wannier functions. Physical Review B, 10 2014. doi:10.1103/PhysRevB.90.165125.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_27/","title":"27: Silicon \u2014 Selected columns of density matrix algorithm for automated MLWFs","text":"<p>Note: This tutorial requires a recent version of the <code>pw2wannier90.x</code> post-processing code of <code>Quantum ESPRESSO</code> (v6.4 or above).</p> <ul> <li> <p>Outline: For bulk crystalline Silicon, generate the \\(A_{mn}\\)     matrices via the selected columns of density matrix (SCDM) algorithm     and the corresponding MLWFs for 1) Valence bands 2) Valence bands     and 4 low-lying conduction bands 3) Conduction bands only. To better     understand the input files and the results of these calculations, it     is crucial that the Reader has familiarized with the concepts and     methods explained in Ref.\u00a0<sup>1</sup>. More info on the     keywords related to the SCDM method may be found in the user_guide.</p> </li> <li> <p>Directory: <code>tutorials/tutorial27/</code> Files can be downloaded from here</p> </li> <li> <p>Input Files: <code>input_files</code>, and in the three subfolders     <code>isolated, erfc</code> and <code>gaussian</code>. The <code>input_files</code> folder contains:</p> <ul> <li> <p><code>si.scf</code> The <code>pwscf</code>\u00a0input file for the ground     state calculation</p> </li> <li> <p><code>si_4bands.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states on a uniform grid for 4 bands.</p> </li> <li> <p><code>si_12bands.nscf</code> The <code>pwscf</code>\u00a0input file to     obtain Bloch states on a uniform grid for 12 bands.</p> </li> </ul> </li> <li> <p>Whereas the three subfolders <code>isolated, erfc</code> and <code>gaussian</code>     contain the <code>si.win</code> <code>wannier90</code>\u00a0 input files and <code>si.pw2wan</code> <code>pw2wannier90</code> input files each corresponding to one of the     scenarios listed in the outline.</p> </li> </ul>"},{"location":"tutorials/tutorial_27/#valence-bands","title":"Valence bands","text":"<p>In this case we will compute 4 localized WFs corresponding to the 4 valence bands of Silicon. These 4 bands constitute a manifold that is separated in energy from other bands. In this case the columns of the density matrix are already localized in real space and no extra parameter is required.</p> <ol> <li> <p>Copy the input files <code>si.scf</code> and <code>si_4bands.nscf</code> from the     <code>input_files</code> directory into the <code>isolated</code> folder</p> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state charge of     bulk Silicon.</p> Terminal<pre><code>pw.x &lt; si.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid of 4x4x4 for 4 bands.</p> Terminal<pre><code>pw.x &lt; si_4bands.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Inspect the <code>si.win</code> input file and make sure that the     <code>auto_projections</code> flag is set to <code>.true.</code>. Also, make sure that     no projections block is present.</p> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps and     also info on the SCDM method (written into the <code>si.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp si\n</code></pre> </li> <li> <p>Inspect the <code>si.nnkp</code> file and make sure you find the     <code>auto_projections</code> block and that no projections have been     written in the <code>projections</code> block.</p> </li> <li> <p>Inspect the <code>.pw2wan</code> input file. You will find two new     keywords, i.e. <code>scdm_proj</code> and <code>scdm_entanglement</code>. The former,     will instruct <code>pw2wannier90.x</code> to use the SCDM method when     generating the \\(A_{mn}\\) matrix. The latter, defines which     formula to adopt for the function \\(f(\\varepsilon_{n\\mathbf{k}})\\)     (see <sup>1</sup> and point below).</p> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states     and the projections via the SCDM method (written in the <code>si.mmn</code>     and <code>si.amn</code> respectively).</p> Terminal<pre><code>pw2wannier90.x &lt; si.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x si\n</code></pre> </li> </ol> <p>At this point, you should have obtained 4 Wannier functions and the interpolated valence bands for Silicon. Inspect the output file <code>si.wout</code>. In particular, look at the geometric centres of each WF, do they lie at the centre of the Si-Si bond as for the MLWFs computed from user-defined initial \\(s\\)-like projections (see Tutorial 11)? Plot these WFs using Vesta. Do they show the \\(\\sigma\\) character one would expect from chemical arguments?</p>"},{"location":"tutorials/tutorial_27/#valence-bands-conduction-bands","title":"Valence bands + conduction bands","text":"<p>In this case we will compute 8 localized WFs corresponding to the 4 valence bands and 4 low-lying conduction bands. Here, we don't have a separate manifold, since the conduction bands are entangled with other high-energy bands and the columns of the density matrix are not exponentially localized by construction. A modified density matrix is required in this case<sup>1</sup>, and it is defined as:</p> \\[ P(\\mathbf{r},\\mathbf{r}') = \\sum_{n,\\mathbf{k}} \\psi_{n\\mathbf{k}}(\\mathbf{r})f(\\varepsilon_{n,\\mathbf{k}})\\psi_{n\\mathbf{k}}^\\ast(\\mathbf{r}'), \\] <p>where \\(\\psi_{n\\mathbf{k}}\\) and \\(\\varepsilon_{n,\\mathbf{k}}\\) are the energy eigestates and eigenvalues from the first-principle calculation respectively. The function \\(f(\\varepsilon_{n,\\mathbf{k}})\\) contains two free parameters \\(\\mu\\) and \\(\\sigma\\) and is defined as a complementary error function:</p> \\[ f(\\varepsilon_{n,\\mathbf{k}}) = \\frac{1}{2}\\mathrm{erfc} \\left(\\frac{\\varepsilon_{n,\\mathbf{k}} - \\mu}{\\sigma}\\right). \\] <ol> <li> <p>Copy the input files <code>si.scf</code> and <code>si_12bands.nscf</code> from the     <code>input_files</code> folder into the <code>erfc</code> folder</p> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state charge of     bulk Silicon.</p> Terminal<pre><code>pw.x &lt; si.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid of 4x4x4 for 12 bands this time.</p> Terminal<pre><code>pw.x &lt; si_12bands.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Inspect the <code>si.win</code> input file and make sure that the     <code>auto_projections</code> flag is set to <code>.true.</code>. Also, make sure that     no projection block is present.</p> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps and     also info on the SCDM method (written into the <code>si.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp si\n</code></pre> </li> <li> <p>Inspect the <code>si.nnkp</code> file and make sure you find the     <code>auto_projections</code> block and that no projections have been     written in the <code>projections</code> block.</p> </li> <li> <p>Inspect the <code>.pw2wan</code> input file. You will find other two new     keywords, i.e. <code>scdm_mu</code> and <code>scdm_sigma</code>. These are the values     in eV of \\(\\mu\\) and \\(\\sigma\\) in \\(f(\\varepsilon_{n,\\mathbf{k}})\\),     respectively.</p> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states     and the projections via the SCDM method (written in the <code>si.mmn</code>     and <code>si.amn</code> respectively).</p> Terminal<pre><code>pw2wannier90.x &lt; si.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x si\n</code></pre> </li> </ol> <p>At this point, you should have obtained 8 localized Wannier functions and the interpolated valence and conduction bands for Silicon. Again, compare the results for the geometric centres and the individual spreads with the ones from Tutorial 11. Is the final value of total spread bigger or smaller than the one from Tutorial 11? Look at the WFs with Vesta. Can you explain what you see? Where do the major lobes of the \\(sp3\\)-like WFs point in this case?</p>"},{"location":"tutorials/tutorial_27/#conduction-bands-only","title":"Conduction bands only","text":"<p>In this case we will compute 4 localized WFs corresponding to the 4 low-lying conduction bands only. As for the previous point, we need to define a modified density matrix<sup>1</sup>. Since we are only interested in a subset of the conduction states, within a bounded energy region, a good choice for \\(f(\\varepsilon_{n,\\mathbf{k}})\\) is:</p> \\[ f(\\varepsilon_{n,\\mathbf{k}}) = \\exp\\left(-\\frac{(\\varepsilon_{n,\\mathbf{k}} - \\mu)^2}{\\sigma^2}\\right). \\] <ol> <li> <p>Copy the input files <code>si.scf</code> and <code>si_12bands.nscf</code> from the     <code>input_files</code> directory into the <code>gaussian</code> folder</p> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state charge of     bulk Silicon.</p> Terminal<pre><code>pw.x &lt; si.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid of 4x4x4 for 12 bands this time.</p> Terminal<pre><code>pw.x &lt; si_12bands.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Inspect the <code>si.win</code> input file and make sure that the     <code>auto_projections</code> flag is set to <code>.true.</code>. Also, make sure that     no projections block is present.</p> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps and     also info on the SCDM method (written into the <code>si.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp si\n</code></pre> </li> <li> <p>Inspect the <code>si.nnkp</code> file and make sure you find the     <code>auto_projections</code> block and that no projections have been     written in the <code>projections</code> block.</p> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states,     the projections for the starting guess via the SCDM method     (written in the <code>si.mmn</code> and <code>si.amn</code> respectively).</p> Terminal<pre><code>pw2wannier90.x &lt; si.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x si\n</code></pre> </li> </ol> <p>At this point, you should have obtained 4 localized Wannier functions and the interpolated conduction bands for Silicon. From chemical intuition, we would expect these functions to be similar to anti-bonding orbitals of molecules with tetrahedral symmetry. Plot the WFs and check if this is confirmed.</p> <ol> <li> <p>A. Damle and L. Lin. Disentanglement via entanglement: A unified method for Wannier localization. ArXiv e-prints, March 2017. URL: http://adsabs.harvard.edu/abs/2017arXiv170306958D, arXiv:1703.06958.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_28/","title":"28: Diamond \u2014 plotting of MLWFs using Gaussian cube format and VESTA","text":"<ul> <li> <p>Outline: Obtain MLWFs for the valence bands of diamond and output     them in Gaussian cube format</p> </li> <li> <p>Directory: <code>tutorials/tutorial28/</code> The input files for this tutorials are the     same as the ones in Tutorial 5 and can be downloaded     here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>diamond.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>diamond.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states on a uniform grid</p> </li> <li> <p><code>diamond.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>diamond.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of diamond</p> Terminal<pre><code>pw.x &lt; diamond.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid</p> Terminal<pre><code>pw.x &lt; diamond.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>diamond.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp diamond\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states and     the projections for the starting guess (written in the <code>diamond.mmn</code>     and <code>diamond.amn</code> files).</p> Terminal<pre><code>pw2wannier90.x &lt; diamond.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>When the lattice vectors are non-orthogonal, not all the     visualisation programs are capable to plot volumetric data in the     Gaussian cube format. One program that can read volumetric data for     these systems is VESTA. To instruct <code>wannier90</code>\u00a0to output the MLWFs     data in Gaussian cube format you need to add the following lines to     the <code>.win</code> file</p> Input file<pre><code>wannier_plot           = .true.\nwannier_plot_supercell = 3\nwannier_plot_format    = cube\nwannier_plot_mode      = crystal\nwannier_plot_radius    = 2.5\nwannier_plot_scale     = 1.0\n</code></pre> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs and output them in the Gaussian cube file.</p> Terminal<pre><code>wannier90.x diamond\n</code></pre> </li> <li> <p>Plot the first MLWF with VESTA <code>vesta diamond_00001.cube</code></p> </li> </ul> <p>Extra: Instead of using <code>wannier_plot_mode = crystal</code> try to use the molecule mode as <code>wannier_plot_mode = molecule</code> (see the user guide for the definition of this keyword). Add the following line to the <code>.win</code> file:</p> Input file<pre><code>restart = plot\n</code></pre> <p>and re-run <code>wannier90</code>. Use VESTA to plot the resulting MLWFs, do you see any difference from the <code>crystal</code> mode case? Can you explain why? Try to change the size of the supercell from 3 to 5, do you expect the results to be different? (Hint: When using the Gaussian cube format the code outputs the WF on a grid that is smaller than the super unit-cell. The size of the grid is specified by <code>wannier_plot_scale</code> and <code>wannier_plot_radius</code>.)</p>"},{"location":"tutorials/tutorial_29/","title":"29: Platinum \u2014 Spin Hall conductivity","text":"<ul> <li> <p>Outline: Calculate spin Hall conductivity (SHC) and plot Berry     curvature-like term of fcc Pt considering spin-orbit coupling. To     gain a better understanding of this tutorial, it is suggested to read     Ref.\u00a0<sup>1</sup> for a detailed description of the theory and the     berry_task=shc: spin Hall conductivity     chapter of the User Guide.</p> </li> <li> <p>Directory: <code>tutorials/tutorial29/</code> Files can be downloaded     here</p> </li> <li> <p>Input files</p> <ul> <li> <p><code>Pt.scf</code> The <code>pwscf</code>\u00a0input file for ground state     calculation</p> </li> <li> <p><code>Pt.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states on a uniform grid</p> </li> <li> <p><code>Pt.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>Pt.win</code> The <code>wannier90</code> and <code>postw90</code> input file</p> </li> </ul> </li> </ul> <p> </p> <ol> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of platinum</p> Terminal<pre><code>pw.x &lt; Pt.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     \\(k\\)-point grid</p> Terminal<pre><code>pw.x &lt; Pt.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>Pt.nnkp</code> file)</p> Terminal<pre><code>wannier90.x -pp Pt\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlaps between Bloch states and     the projections for the starting guess (written in the <code>Pt.mmn</code> and     <code>Pt.amn</code> files)</p> Terminal<pre><code>pw2wannier90.x &lt; Pt.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs</p> Terminal<pre><code>wannier90.x Pt\n</code></pre> </li> <li> <p>Run <code>postw90</code></p> Terminal<pre><code>postw90.x Pt # (1)!\nmpirun -np 8 postw90.x Pt # (2)!\n</code></pre> <ol> <li>serial execution</li> <li>example of parallel execution with 8 MPI processes</li> </ol> </li> </ol>"},{"location":"tutorials/tutorial_29/#spin-hall-conductivity","title":"Spin Hall conductivity","text":"<p>The intrinsic spin Hall conductivity \\(\\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}\\) is proportional to the BZ integral of the Berry curvature-like term. To evaluate the SHC using a \\(25\\times 25\\times 25\\) \\(k\\)-point mesh, set the following lines in <code>Pt.win</code>,</p> Input file<pre><code>berry = true\nberry_task = shc\nberry_kmesh = 25 25 25\n</code></pre> <p>When calculating SHC, adaptive smearing can be used by commenting the following two lines,</p> Input file<pre><code>#kubo_adpt_smr = false\n#kubo_smr_fixed_en_width = 1\n</code></pre> <p>Then set the Fermi energy \\(\\varepsilon_F\\) to a specific value</p> Input file<pre><code>fermi_energy = [insert your value here]\n</code></pre> <p>or invoke Fermi energy scan by setting</p> Input file<pre><code>fermi_energy_min = [insert here your lower range]\nfermi_energy_max = [insert here your upper range]\nfermi_energy_step = [insert here your step]\n</code></pre> <p>and re-run <code>postw90</code>. The SHC is written in the output file <code>Pt-shc-fermiscan.dat</code>. If only <code>fermi_energy</code> is set, the output file will contain SHC at this specific energy; if a list of Fermi energies are set, the output file will contain SHC calculated at each energy point in the list: we call this the \"Fermi energy scan\" of SHC.</p> <p>To plot the Fermi energy scan of SHC \\(\\sigma_{xy}^{\\text{spin}z}\\) versus \\(\\varepsilon_F\\), issue</p> Terminal<pre><code>gnuplot\n</code></pre> Gnuplot shell<pre><code>plot 'Pt-shc-fermiscan.dat' u 2:3 w lp\n</code></pre> <p>As a result of the strong and rapid variations of the Berry curvature-like term across the BZ, the SHC converges rather slowly with \\(k\\)-point sampling, and a \\(25\\times 25\\times 25\\) kmesh does not yield a well-converged value.</p> <ul> <li> <p>Increase the kmesh density by changing <code>berry_kmesh</code>.</p> </li> <li> <p>To accelerate the convergence, adaptively refine the kmesh around     spikes in the Berry curvature-like term, by adding to <code>Pt.win</code> the     lines This adds a \\(5\\times 5\\times 5\\) fine mesh around those points     where     \\(\\vert{\\Omega_{\\alpha\\beta}^{\\text{spin}\\gamma}}({\\bm k})\\vert\\)     exceeds 100\u00a0<code>berry_curv_unit</code>. The percentage of points triggering     adaptive refinement is reported in <code>Pt.wpout</code>.</p> </li> </ul> <p>Compare the converged SHC value with those obtained in Refs.\u00a0<sup>1</sup> and\u00a0<sup>2</sup>.</p> <p>Note some rough estimations of computation progress and time are reported in <code>Pt.wpout</code> (see the SHC part of the Solution Booklet). These may be helpful if the computation time is very long.</p> <p>Note</p> <ul> <li> <p>Since the Kubo formula of SHC involves unoccupied bands, we need to     include some unoccupied bands and construct more MLWF. Thus the     following parameters should be increased accordingly:</p> <p> Input file<pre><code>dis_froz_max\ndis_win_max\nprojections\n</code></pre> </p> </li> <li> <p>Normally we calculate the SHC \\(\\sigma_{xy}^{\\text{spin}z}\\), i.e.     \\(\\alpha = x, \\beta = y, \\gamma = z\\). To calculate other components,     the following parameters can be set as <code>1, 2, 3</code> with <code>1, 2, 3</code>     standing for <code>x, y, z</code> respectively.</p> </li> </ul>"},{"location":"tutorials/tutorial_29/#berry-curvature-like-term-plots","title":"Berry curvature-like term plots","text":"<p>The band-projected Berry curvature-like term \\(\\Omega_{n,\\alpha\\beta}^{\\text{spin} \\gamma}({\\bm k})\\) is defined in this equation of the User Guide. The following lines in <code>Pt.win</code> are used to calculate the energy bands colored by the band-projected Berry curvature-like term \\(\\Omega_{n,\\alpha\\beta}^{\\text{spin} \\gamma}({\\bm k})\\) (in \u00c5\\(^2\\)), as well as the \\(k\\)-resolved Berry curvature-like term \\(\\Omega_{\\alpha\\beta}^{\\text{spin} \\gamma}({\\bm k})\\) along high-symmetry lines in \\(k\\)-space, i.e. the <code>kpath</code> plot. First comment the line <code>berry = true</code> and then set</p> Input file<pre><code>kpath = true\nkpath_task = bands+shc\nkpath_bands_colour = shc\nkpath_num_points = 400\nkubo_adpt_smr = false\nkubo_smr_fixed_en_width = 1\nfermi_energy = [insert your value here]\nberry_curv_unit = ang2\n</code></pre> <p>After executing <code>postw90</code>, four files are generated: <code>Pt-bands.dat</code>, <code>Pt-path.kpt</code>, <code>Pt-shc.dat</code> and <code>Pt-bands+shc.py</code>. Then plot the band-projected Berry curvature-like term \\(\\Omega_{n,\\alpha\\beta}^{\\text{spin}\\gamma}({\\bm k})\\) using the script generated at runtime,</p> Terminal<pre><code>python Pt-bands+shc.py\n</code></pre> <p>and compare with Fig.\u00a02 of Ref.\u00a0<sup>1</sup>. Note a large fixed smearing of 1\u00a0eV is used to recover the result in Ref.\u00a0<sup>1</sup>. You can adjust the <code>kubo_smr_fixed_en_width</code> as you like to draw a visually appealing figure. A <code>kpath</code> plot of 0.05 eV smearing is shown in the Solution Booklet.</p> <p>Besides, you can set <code>kpath_task = shc</code> to only draw \\(k\\)-resolved term \\(\\Omega_{\\alpha\\beta}^{\\text{spin} \\gamma}({\\bm k})\\) (the lower panel of the figure), or set <code>kpath_task = bands</code> and <code>kpath_bands_colour = shc</code> to only draw energy bands colored by the band-projected term \\(\\Omega_{n,\\alpha\\beta}^{\\text{spin} \\gamma}({\\bm k})\\) (the upper panel of the figure).</p> <p>Similar to that of AHC, we can get a heatmap plot of the \\(k\\)-resolved Berry curvature-like term \\(\\Omega_{\\alpha\\beta}^{\\text{spin}\\gamma}({\\bm k})\\), i.e. the <code>kslice</code> plot. To move forward, set <code>kpath = false</code> and uncomment the following lines in <code>Pt.win</code>, Note the <code>kslice_b2</code> is actually \\((\\frac{\\sqrt{2}}{4},   \\frac{3\\sqrt{2}}{4},0.0)\\) which leads to a square slice in the BZ, making it easier to plot in the generated <code>python</code> script. Re-run <code>postw90</code>, and issue</p> Terminal<pre><code>python Pt-kslice-shc+fermi_lines.py\n</code></pre> <p>Compare the generated figure with Fig.\u00a03 in Ref.\u00a0<sup>1</sup>, or the Solution Booklet.</p> <p>Note</p> <p>Adaptive smearing depends on a uniform kmesh, so when running <code>kpath</code> and <code>kslice</code> plots adaptive smearing should not be used. A fixed smearing is needed to avoid near zero number in the denominator of the Kubo formula in the User Guide. To add a fixed smearing of 0.05 eV, add the following keywords in the<code>Pt.win</code>,</p> <p> Input file<pre><code>kubo_adpt_smr = .false.\nkubo_smr_fixed_en_width = 0.05\n</code></pre> </p>"},{"location":"tutorials/tutorial_29/#input-parameters-for-shc","title":"Input parameters for SHC","text":"<p>Finally, we provide a complete list of input parameters that can be used to control the SHC calculation, including the calculation of alternating current (ac) SHC which will be introduced in the next tutorial.</p> <ul> <li> <p>general controls for SHC</p> Input file<pre><code>shc_freq_scan\nshc_alpha\nshc_beta\nshc_gamma\n\nkubo_eigval_max\nexclude_bands\nberry_curv_unit\n</code></pre> </li> <li> <p>kmesh</p> Input file<pre><code>berry_task\nberry_kmesh\n\nberry_curv_adpt_kmesh\nberry_curv_adpt_kmesh_thresh\n</code></pre> </li> <li> <p>ac SHC</p> Input file<pre><code>kubo_freq_min\nkubo_freq_max\nkubo_freq_step\n\nshc_bandshift\nshc_bandshift_firstband\nshc_bandshift_energyshift\n\nscissors_shift\nnum_valence_bands\n</code></pre> </li> <li> <p>smearing</p> Input file<pre><code>[kubo_]adpt_smr\n[kubo_]adpt_smr_fac\n[kubo_]adpt_smr_max\n\n[kubo_]smr_fixed_en_width\n</code></pre> </li> <li> <p>Fermi energy</p> Input file<pre><code>fermi_energy\nfermi_energy_min\nfermi_energy_max\nfermi_energy_step\n</code></pre> </li> <li> <p>kpath</p> Input file<pre><code>kpath\nkpath_task\nkpath_num_points\nkpath_bands_colour\n</code></pre> </li> <li> <p>kslice</p> Input file<pre><code>kslice\nkslice_task\nkslice_corner\nkslice_b1\nkslice_b2\nkslice_2dkmesh\n\nkslice_fermi_level\nkslice_fermi_lines_colour\n</code></pre> </li> </ul> <p>Their meanings and usages can be found in the berry_task=shc: spin Hall conductivity  chapter of the User Guide.</p> <ol> <li> <p>Junfeng Qiao, Jiaqi Zhou, Zhe Yuan, and Weisheng Zhao. Calculation of intrinsic spin hall conductivity by wannier interpolation. Phys. Rev. B, 98:214402, Dec 2018. URL: https://link.aps.org/doi/10.1103/PhysRevB.98.214402, doi:10.1103/PhysRevB.98.214402.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>G. Y. Guo, S. Murakami, T.-W. Chen, and N. Nagaosa. Intrinsic spin hall effect in platinum: first-principles calculations. Phys. Rev. Lett., 100:096401, Mar 2008. URL: https://link.aps.org/doi/10.1103/PhysRevLett.100.096401, doi:10.1103/PhysRevLett.100.096401.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_3/","title":"3: Silicon \u2014 Disentangled MLWFs","text":"<ul> <li> <p>Outline: Obtain disentangled MLWFs for the valence and low-lying     conduction states of Si. Plot the interpolated band structure</p> </li> <li> <p>Generation Details: From <code>pwscf</code>, using norm-conserving     pseudopotentials and a      4\\(\\times\\)4\\(\\times\\)4 k-point grid.     Starting guess: atom-centred sp\\(^3\\) hybrid orbitals</p> </li> <li> <p>Directory: <code>tutorials/tutorial03/</code> Files can be downloaded from here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>silicon.win</code> The master input file</p> </li> <li> <p><code>silicon.mmn</code> The overlap matrices     \\(\\mathbf{M}^{(\\mathbf{k},\\mathbf{b})}\\)</p> </li> <li> <p><code>silicon.amn</code> Projection \\(\\mathbf{A}^{(\\mathbf{k})}\\) of the     Bloch states onto a set of trial localised orbitals</p> </li> <li> <p><code>silicon.eig</code> The Bloch eigenvalues at each k-point</p> </li> </ul> </li> </ul> <p>The valence and lower conduction states can be represented by MLWFs with \\(sp^3\\)-like symmetry. The lower conduction states are not separated from the higher states by an energy gap. In order to form localised WF, we use the disentanglement procedure introduced in Ref.\u00a0<sup>1</sup>. The position of the inner and outer energy windows are shown in the bandstructure plot.</p> <ol> <li> <p>Run <code>wannier90</code>.</p> Terminal<pre><code>wannier90.x silicon\n</code></pre> <p>Inspect the output file <code>silicon.wout</code>. The minimisation of the spread occurs in a two-step procedure\u00a0<sup>1</sup>. First, we minimise \\(\\Omega_{\\rm I}\\) -- this is the extraction of the optimal subspace in the disentanglement procedure. Then, we minimise \\(\\Omega_{\\rm D} + \\Omega_{{\\rm OD}}\\).</p> </li> <li> <p>Plot the energy bands by adding the following commands to the input     file <code>silicon.win</code></p> Input file<pre><code>restart = plot\n\nbands_plot = true\n</code></pre> <p>and re-running <code>wannier90</code>. The files <code>silicon_band.dat</code> and <code>silicon_band.gnu</code> are created. To plot the bandstructure run gnuplot</p> Terminal<pre><code>gnuplot\n</code></pre> <p>and within the gnuplot shell type</p> Gnuplot shell<pre><code>load 'silicon_band.gnu'\n</code></pre> <p>The k-point path for the bandstructure interpolation is set in the <code>kpoint_path</code> block. Try plotting along different paths.</p> </li> </ol>  Bandstructure of silicon showing the position of the outer and inner energy windows. <ol> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_30/","title":"30: Gallium Arsenide \u2014 Frequency-dependent spin Hall conductivity","text":"<ul> <li> <p>Outline: Calculate the alternating current (ac) spin Hall     conductivity of gallium arsenide considering spin-orbit coupling. To     gain a better understanding of this tutorial, it is suggested to read     Ref.\u00a0<sup>1</sup> for a detailed description of the theory and the     berry_task=shc: spin Hall conductivity     chapter of the User Guide.</p> </li> <li> <p>Directory: <code>tutorials/tutorial30/</code> Files can downloaded from     here</p> </li> <li> <p>Input files</p> <ul> <li> <p><code>GaAs.scf</code> The <code>pwscf</code>\u00a0input file for ground state     calculation</p> </li> <li> <p><code>GaAs.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states on a uniform grid</p> </li> <li> <p><code>GaAs.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>GaAs.win</code> The <code>wannier90</code> and <code>postw90</code> input file</p> </li> </ul> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of gallium     arsenide</p> Terminal<pre><code>pw.x &lt; GaAs.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     \\(k\\)-point grid</p> Terminal<pre><code>pw.x &lt; GaAs.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>GaAs.nnkp</code> file)</p> Terminal<pre><code>wannier90.x -pp GaAs\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlaps between Bloch states and     the projections for the starting guess (written in the <code>GaAs.mmn</code>     and <code>GaAs.amn</code> files)</p> Terminal<pre><code>pw2wannier90.x &lt; GaAs.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs</p> Terminal<pre><code>wannier90.x GaAs\n</code></pre> </li> <li> <p>Run <code>postw90</code></p> Terminal<pre><code>postw90.x GaAs # (1)! \nmpirun -np 8 postw90.x GaAs # (2)! \n</code></pre> <ol> <li>serial execution</li> <li>example of parallel execution with 8 MPI processes</li> </ol> </li> </ul>"},{"location":"tutorials/tutorial_30/#ac-spin-hall-conductivity","title":"ac spin Hall conductivity","text":"<p>The spin Hall conductivity is also dependent on the frequency \\(\\omega\\) in this equation of the User Guide. The direct current (dc) SHC calculated in the previous tutorial corresponds to \\(\\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}\\) in the limit \\(\\omega\\rightarrow 0\\) and it is a real number. At finite frequency \\(\\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}\\) acquires an imaginary part.</p> <p>To compute the ac spin Hall conductivity for \\(\\hbar\\omega\\) up to 8\u00a0eV, add the lines</p> Input file<pre><code>shc_freq_scan = true\nkubo_freq_min = 0.0\nkubo_freq_max = 8.0\nkubo_freq_step = 0.01\n</code></pre> <p>and re-run <code>postw90</code>. The file <code>GaAs-shc-freqscan.dat</code> contains the calculated ac SHC. Reasonably converged spectra can be obtained with a \\(250\\times 250\\times 250\\) \\(k\\)-point mesh. To plot the ac SHC, issue the following commands</p> Terminal<pre><code>gnuplot\n</code></pre> Gnuplot shell<pre><code>plot 'GaAs-shc-freqscan.dat' u 2:3 w l title 'Re',\n'GaAs-shc-freqscan.dat' u 2:4 w l title 'Im'\n</code></pre> <p>and then compare the result with Fig.\u00a04 in Ref.\u00a0<sup>1</sup> or the Solution Booklet.</p>"},{"location":"tutorials/tutorial_30/#notes","title":"Notes","text":"<ul> <li> <p>When calculating ac SHC, adaptive smearing can be used by add the     following keywords in the <code>GaAs.win</code>,</p> Input file<pre><code>kubo_adpt_smr = true\nkubo_adpt_smr_fac = [insert here your smearing factor]\nkubo_adpt_smr_max = [insert here your maximum smearing]\n</code></pre> </li> <li> <p>Adaptive kmesh refinement is not implemented for ac SHC calculation.</p> </li> <li> <p>The first 10 semi-core states are excluded from the calculation by     using the following keywords</p> Input file<pre><code>exclude_bands = 1-10\n</code></pre> <p>and in the case of GaAs disentanglement is not adopted so</p> Input file<pre><code>num_bands         =   16\nnum_wann          =   16\n</code></pre> </li> <li> <p>Since the band gap is often under estimated by LDA/GGA calculations,     a scissors shift is applied to recover the experimental band gap by     using the following keywords</p> Input file<pre><code>shc_bandshift = true\nshc_bandshift_firstband = 9\nshc_bandshift_energyshift = 1.117\n</code></pre> <p>or by</p> Input file<pre><code>num_valence_bands = 8\nscissors_shift = 1.117\n</code></pre> </li> </ul> <ol> <li> <p>Junfeng Qiao, Jiaqi Zhou, Zhe Yuan, and Weisheng Zhao. Calculation of intrinsic spin hall conductivity by wannier interpolation. Phys. Rev. B, 98:214402, Dec 2018. URL: https://link.aps.org/doi/10.1103/PhysRevB.98.214402, doi:10.1103/PhysRevB.98.214402.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_31/","title":"31: Platinum \u2014 Selected columns of density matrix algorithm for spinor wavefunctions","text":"<p>Note: This tutorial requires a recent version of the <code>pw2wannier90.x</code> post-processing code of <code>Quantum ESPRESSO</code> (v6.3 or above).</p> <ul> <li> <p>Outline: For bulk crystalline platinum with spin-orbit coupling,     generate the \\(A_{mn}\\) matrices via the selected columns of density     matrix (SCDM) algorithm and the corresponding spinor-MLWFs. To     better understand the input files and the results of these     calculations, it is crucial that the Reader has familiarized with     the concepts and methods explained in Ref.\u00a0<sup>1</sup>. More     info on the keywords related to the SCDM method may be found in the     user_guide.</p> <p>This tutorial focuses on the use of the SCDM method for spin-noncollinear systems. For the overview of the use of SCDM method to spinless systems, please refer to this tutorial.</p> </li> <li> <p>Directory: <code>tutorials/tutorial31/</code> Files can be downloaded from     here</p> <p>The input files for this tutorials are similar to the ones in Tutorial 29, except that a coarser k-point grid is used and that the keywords related to <code>postw90.x</code> are removed.</p> </li> <li> <p>Input Files:</p> <ul> <li> <p><code>Pt.scf</code> The <code>pwscf</code>\u00a0input file for the ground     state calculation</p> </li> <li> <p><code>Pt.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states on a uniform grid</p> </li> <li> <p><code>Pt.pw2wan</code> The input file for <code>pw2wannier90</code> with keywords     related to the SCDM method</p> </li> <li> <p><code>Pt.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> </ul> <p>We will compute 18 localized WFs. Since the band structure of platinum is metallic, the low-lying bands are entangled with other high-energy bands, and the columns of the density matrix are not exponentially localized by construction. Thus, we use a modified density matrix <sup>1</sup>, with the function \\(f(\\varepsilon_{n,\\mathbf{k}})\\) defined as a complementary error function. Refer to Tutorial 27 for the definition of the modified density matrix and the functional form of \\(f(\\varepsilon_{n,\\mathbf{k}})\\).</p> <ol> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of platinum</p> Terminal<pre><code>pw.x &lt; Pt.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     \\(7\\times 7\\times 7\\) \\(k\\)-point grid</p> Terminal<pre><code>pw.x &lt; Pt.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Inspect the <code>Pt.win</code> input file and make sure that the     <code>auto_projections</code> flag is set to <code>.true.</code>. Also, make sure that no     projection block is present.</p> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>Pt.nnkp</code> file)</p> Terminal<pre><code>wannier90.x -pp Pt\n</code></pre> </li> <li> <p>Inspect the <code>Pt.nnkp</code> file and make sure you find the     <code>auto_projections</code> block and that no projections have been written     in the <code>projections</code> block.</p> </li> <li> <p>Inspect the <code>Pt.pw2wan</code> input file. You will find four SCDM-related     keywords: <code>scdm_proj</code>, <code>scdm_entanglement</code>, <code>scdm_mu</code> and     <code>scdm_sigma</code>. In particular, the keyword <code>scdm_proj</code> will instruct     <code>pw2wannier90.x</code> to use the SCDM method when generating the \\(A_{mn}\\)     matrix. The remaining three keywords defines the formula and     parameters to define the function \\(f(\\varepsilon_{n\\mathbf{k}})\\)     (see Ref.\u00a0<sup>1</sup> and Tutorial 27).</p> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states and     the projections via the SCDM method (written in the <code>Pt.mmn</code> and     <code>Pt.amn</code> respectively).</p> Terminal<pre><code>pw2wannier90.x &lt; Pt.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Inspect the <code>pw2wan.out</code> output file. Compared to the spinless case,     you will find the following two additional lines.</p> Output file<pre><code>         Number of pivot points with spin up  :     9\n         Number of pivot points with spin down:     9\n</code></pre> <p>These lines give information on the pivots obtained by the QR decomposition with column pivoting (QRCP) in the SCDM algorithm. Each pivot determines a point in the real-space grid and a spin state. The basis of the spin state is determined by the basis used in the electronic structure code. In <code>pwscf</code>, the basis states are spin up and down states along the Cartesian \\(z\\)-axis.</p> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs</p> Terminal<pre><code>wannier90.x Pt\n</code></pre> </li> </ol> <ol> <li> <p>A. Damle and L. Lin. Disentanglement via entanglement: A unified method for Wannier localization. ArXiv e-prints, March 2017. URL: http://adsabs.harvard.edu/abs/2017arXiv170306958D, arXiv:1703.06958.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_32/","title":"32: Tungsten \u2014 SCDM parameters from projectability","text":"<ul> <li> <p>Outline: Compute the Wannier interpolated band structure of     tungsten (W) using the SCDM method to calculate the initial guess     (see Tutorial 27 for more details). The free parameters     in the SCDM method, i.e., \\(\\mu\\) and \\(\\sigma\\), are obtained by fitting a     complementary error function to the projectabilities. The number of     MLWFs is given by the number of pseudo-atomic orbitals (PAOs) in the     pseudopotential, \\(21\\) in this case. All the steps shown in this     tutorial have been automated in the AiiDA<sup>1</sup> workflow that     can be downloaded from the MaterialsCloud     website<sup>2</sup>.</p> </li> <li> <p>Directory: <code>tutorials/tutorial32/</code> Files can be downloaded from     here</p> </li> <li> <p>Input files</p> <ul> <li> <p><code>W.scf</code> The <code>pwscf</code>\u00a0input file for ground state     calculation</p> </li> <li> <p><code>W.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states on a uniform grid</p> </li> <li> <p><code>W.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>W.proj</code> The input file for <code>projwfc</code></p> </li> <li> <p><code>generate_weights.sh</code> The bash script to extract the     projectabilities from the output of <code>projwfc</code></p> </li> <li> <p><code>W.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> </ul> <p> </p> <ol> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of tungsten</p> Terminal<pre><code>pw.x -in W.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a     \\(10\\times10\\times10\\) uniform \\(k\\)-point grid</p> Terminal<pre><code>pw.x -in W.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>W.nnkp</code> file)</p> Terminal<pre><code>wannier90.x -pp W\n</code></pre> </li> <li> <p>Run <code>projwfc</code> to compute the projectabilities of the Bloch states     onto the Bloch sums obtained from the PAOs in the pseudopotential</p> Terminal<pre><code>projwfc.x -in W.proj &gt; proj.out\n</code></pre> </li> <li> <p>Run <code>generate_weights</code> to extract the projectabilitites from     <code>proj.out</code> in a format suitable to be read by <code>Xmgrace</code> or gnuplot</p> Terminal<pre><code>./generate_weights.sh\n</code></pre> </li> <li> <p>Plot the projectabilities and fit the data with the complementary     error function</p> \\[ f(\\epsilon;\\mu,\\sigma) = \\frac{1}{2} \\mathrm{erfc}(-\\frac{\\mu - \\epsilon}{\\sigma}). \\] <p>We are going to use <code>Xmgrace</code> to plot the projectabilities and perform the fitting. Open <code>Xmgrace</code></p> Terminal<pre><code>xmgrace\n</code></pre> <p>To Import the <code>p_vs_e.dat</code> file, click on <code>Data</code> from the top bar and then <code>Import -&gt; ASCII...</code>. At this point a new window <code>Grace: Read sets</code> should pop up. Select <code>p_vs_e.dat</code> in the <code>Files</code> section, click <code>Ok</code> at the bottom and close the window. You should now be able to see a quite noisy function that is bounded between 1 and 0. You can modify the appearence of the plot by clicking on <code>Plot</code> in the top bar and then <code>Set appearance...</code>. In the <code>Main</code> section of the pop-up window change the symbol type from <code>None</code> to <code>Circle</code>. Change the line type from straight to none, since the lines added by default by Xmgrace are not meaningful. For the fitting, go to <code>Data -&gt; Transformations -&gt; Non-linear curve fitting</code>. In this window, select the source from the <code>Set</code> box and in the <code>Formula</code> box insert the following</p> Input file<pre><code>y = 0.5 * erfc( ( x - A0 ) / A1 )\n</code></pre> <p>Select 2 as number of parameters, give 40 as initial condition for <code>A0</code> and 7 for <code>A1</code>. Click <code>Apply</code>. A new window should pop up with the stats of the fitting. In particular you should find a <code>Correlation coefficient</code> of 0.96 and a value of \\(39.9756\\) for <code>A0</code> and \\(6.6529\\) for <code>A1</code>. These are the value of \\(\\mu_{fit}\\) and \\(\\sigma_{fit}\\) we are going to use for the SCDM method. In particular, \\(\\mu_{SCDM} = \\mu_{fit} - 3\\sigma_{fit} = 20.0169\\) eV and \\(\\sigma_{SCDM} = \\sigma_{fit} = 6.6529\\) eV. The motivation for this specific choice of \\(\\mu_{fit}\\) and \\(\\sigma_{fit}\\) may be found in Ref.\u00a0<sup>3</sup>, where the authors also show validation of this approach on a dataset of 200 materials. You should now see the fitting function, as well as the projectabilities, in the graph below.</p> <p>  Each blue dot represents the projectability as defined in Eq. (22) of Ref. <sup>3</sup> of the state \\(\\vert n\\mathbf{k} \\rangle\\) as a function of the corresponding energy \\(\\epsilon_{n\\mathbf{k}}\\) for tungsten. The yellow line shows the fitted complementary error function. The vertical red line represents the value of \\(\\sigma_{fit}\\) while the vertical green line represents the optimal value of \\(\\mu_{SCDM}\\), i.e. \\(\\mu_{SCDM} = \\mu_{fit} - 3\\sigma_{fit}\\). </p> </li> <li> <p>Open <code>W.pw2wan</code> and append the following lines</p> Input file<pre><code>scdm_entanglement = erfc\n\nscdm_mu = 20.0169\n\nscdm_proj = .true.\n\nscdm_sigma = 6.6529 \n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlaps between Bloch states and     the projections for the starting guess (written in the <code>W.mmn</code> and     <code>W.amn</code> files)</p> Terminal<pre><code>pw2wannier90.x -in W.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to obtain the interpolated bandstructure (see the band     structure plot).</p> Terminal<pre><code>wannier90.x W\n</code></pre> <p>Please cite Ref.\u00a0<sup>3</sup> in any publication employing the procedure outlined in this tutorial to obtain \\(\\mu\\) and \\(\\sigma\\).</p> </li> </ol>  Band structure of tungsten on the \u0393-H-N-\u0393 path from DFT calculations (solid black) and Wannier interpolation using the SCDM method to construct the initial guess (red dots). <ol> <li> <p>Giovanni Pizzi, Andrea Cepellotti, Riccardo Sabatini, Nicola Marzari, and Boris Kozinsky. Aiida: automated interactive infrastructure and database for computational science. Computational Materials Science, 111:218 \u2013 230, 2016.\u00a0\u21a9</p> </li> <li> <p>V. Vitale, G. Pizzi, A. Marrazzo, J. R. Yates, N. Marzari, and A. A. Mostofi. Automated high-throughput wannierisation. Materials Cloud Archive, 2019. doi:\\href http://doi.org/10.24435/materialscloud:2019.0044/v210.24435/materialscloud:2019.0044/v2.\u00a0\u21a9</p> </li> <li> <p>Valerio Vitale, Giovanni Pizzi, Antimo Marrazzo, Jonathan Yates, Nicola Marzari, and Arash Mostofi. Automated high-throughput wannierisation. 2019. arXiv:1909.00433.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_33/","title":"33: Monolayer BC\\(_2\\)N \u2014 \\(k\\cdot p\\) expansion coefficients","text":"<ul> <li> <p>Outline: Calculate \\(k\\cdot p\\) expansion coefficients monolayer     BC\\(_2\\)N using quasi-degenerate (L\u00f6wdin) perturbation theory. In     preparation for this example it may be useful to read Ref.     <sup>1</sup></p> </li> <li> <p>Directory: <code>tutorial/tutorial33/</code> Files can be downloaded from here</p> </li> <li> <p>Input files:</p> <ul> <li> <p><code>bc2n.scf</code> The <code>pwscf</code> input file for ground state calculation</p> </li> <li> <p><code>bc2n.nscf</code> The <code>pwscf</code> input file to obtain Bloch states on a     uniform grid</p> </li> <li> <p><code>bc2n.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>bc2n.win</code> The <code>wannier90</code> and <code>postw90</code> input file</p> </li> </ul> </li> </ul> <p> </p> <ol> <li> <p>Run <code>pwscf</code> to obtain the ground state</p> Terminal<pre><code>pw.x &lt; bc2n.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code> to obtain the ground state</p> Terminal<pre><code>pw.x &lt; bc2n.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>Wannier90</code> to generate a list of the required overlaps     (written into the <code>bc2n.nnkp</code> file)</p> Terminal<pre><code>wannier90.x -pp bc2n\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute:</p> <ul> <li>The overlaps \\(\\langle u_{n\\bf{k}}|u_{n\\bf{k+b}}\\rangle\\)     between spinor Bloch states (written in the <code>bc2n.mmn</code>file)</li> <li>The projections for the starting guess (written in the     <code>bc2n.amn</code> file)</li> </ul> Terminal<pre><code>pw2wannier90.x &lt; bc2n.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code> to compute MLWFs</p> Terminal<pre><code>wannier90.x bc2n\n</code></pre> </li> <li> <p>Run <code>postw90</code> to compute expansion coefficients</p> Terminal<pre><code>postw90.x bc2n\n</code></pre> </li> </ol>"},{"location":"tutorials/tutorial_33/#expansion-coefficients","title":"Expansion coefficients","text":"<p>For computing \\(k\\cdot p\\) expansion coefficients as given by quasi-degenerate (L\u00f6wdin) perturbation theory, set</p> Input file<pre><code>berry = true\nberry_task = kdotp\n</code></pre> <p>Select the k-point around which the expansion coefficients will be computed, e.g., the S point</p> Input file<pre><code>kdotp_kpoint  =  0.5000 0.0000 0.5000\n</code></pre> <p>Set number of bands that should be taken into account for the \\(k\\cdot p\\) expansion, as well as their band indexes within the Wannier basis</p> Input file<pre><code>kdotp_num_bands = 2\nkdotp_bands =  2,3\n</code></pre> <p>Since no k-space integral is needed, set</p> Input file<pre><code>berry_kmesh = 1 1 1\n</code></pre> <p>Although not used, we also need to input the value of the Fermi level in eV</p> Input file<pre><code>fermi_energy = [insert your value here]\n</code></pre> <p>On output, the program generates three files, namely <code>SEED-kdotp_0.dat</code>, <code>SEED-kdotp_1.dat</code> and <code>SEED-kdotp_2.dat</code>, which correspond to the zeroth, first and second order expansion coefficients, respectively. The dimension of the matrix contained in each file is \\(3^{l}\\times N^{2}\\), where \\(N\\) is the number of bands set by <code>kdotp_num_bands</code>, and \\(l\\) is the order of the expansion term (currently \\(l=0,1\\) or \\(2\\)).</p> <p>These coefficients can be used, among other things, to compute the energy dispersion of the bands of interest around the chosen k-point. The \\(k\\cdot p\\) band dispersion can be computed and plotted along \\(k_x\\) (from S to X) using python and the file <code>kdotp_plot.py</code> provided in the example folder</p> Terminal<pre><code>    python kdotp_plot.py\n</code></pre> <p>For comparison, the exact band structure calculated usingWannier90 (file <code>bc2n_band.dat</code>, generated automatically) is also plotted along (see the band dispersion plot).</p> Band dispersion of monolayer BC<sub>2</sub>N around \\(S\\) point. Exact results (solid dots) are compared to first-order (blue) and second-order (red) \\(k\\cdot p\\) model results for valence and conduction bands.  <ol> <li> <p>Julen Iba\u00f1ez-Azpiroz, Fernando de Juan, and Ivo Souza. Quantitative analysis of two-band \\(k\\cdot p\\) models describing the shift-current photoconductivity. ArXiv e-prints, 2019. URL: http://arxiv.org/abs/1910.06172, arXiv:1910.06172.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_4/","title":"4: Copper \u2014 Fermi surface, orbital character of energy bands","text":"<ul> <li> <p>Outline: Obtain MLWFs to describe the states around the Fermi-level     in copper</p> </li> <li> <p>Generation Details: From <code>pwscf</code>, using ultrasoft     pseudopotentials\u00a0<sup>1</sup> and a     4\\(\\times\\)4\\(\\times\\)4 k-point grid.     Starting guess: five atom-centred d orbitals, and two s orbitals     centred on one of each of the two tetrahedral interstices.</p> </li> <li> <p>Directory: <code>tutorials/tutorial04/</code> Files can be downloaded from here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>copper.win</code> The master input file</p> </li> <li> <p><code>copper.mmn</code> The overlap matrices     \\(\\mathbf{M}^{(\\mathbf{k},\\mathbf{b})}\\)</p> </li> <li> <p><code>copper.amn</code> Projection \\(\\mathbf{A}^{(\\mathbf{k})}\\) of the     Bloch states onto a set of trial localised orbitals</p> </li> <li> <p><code>copper.eig</code> The Bloch eigenvalues at each k-point</p> </li> </ul> </li> <li> <p>Run <code>wannier90</code>\u00a0to minimise the MLWFs spread</p> Terminal<pre><code>wannier90.x copper\n</code></pre> <p>Inspect the output file <code>copper.wout</code>.</p> </li> <li> <p>Plot the Fermi surface, it should look familiar! The Fermi energy is     at 12.2103\u2006eV.</p> </li> <li> <p>Plot the interpolated bandstructure. A suitable path in k-space is</p> Input file<pre><code> begin kpoint_path\n G 0.00 0.00 0.00 X 0.50 0.50 0.00\n X 0.50 0.50 0.00 W 0.50 0.75 0.25\n W 0.50 0.75 0.25 L 0.00 0.50 0.00\n L 0.00 0.50 0.00 G 0.00 0.00 0.00\n G 0.00 0.00 0.00 K 0.00 0.50 -0.50\n end kpoint_path\n</code></pre> </li> <li> <p>Plot the contribution of the interstitial WF to the bandstructure.     Add the following keyword to <code>copper.win</code></p> Input file<pre><code>bands_plot_project = 6,7\n</code></pre> <p>The resulting file <code>copper_band_proj.gnu</code> can be opened with gnuplot. Red lines correspond to a large contribution from the interstitial WF (blue line are a small contribution; ie a large \\(d\\) contribution).</p> </li> </ul> <p>Investigate the effect of the outer and inner energy window on the interpolated bands.</p> Bandstructure of copper showing the position of the outer and inner energy windows. <ol> <li> <p>D. Vanderbilt. Phys. Rev. B, 41:7892, 1990.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_5/","title":"5: Diamond \u2014 MLWFs for the valence bands","text":"<ul> <li> <p>Outline: Obtain MLWFs for the valence bands of diamond</p> </li> <li> <p>Directory: <code>tutorials/tutorial05/</code> Files can be downloaded from     here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>diamond.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>diamond.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states on a uniform grid</p> </li> <li> <p><code>diamond.pw2wan</code> The input file for <code>pw2wannier90</code></p> </li> <li> <p><code>diamond.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of diamond</p> Terminal<pre><code>pw.x &lt; diamond.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid\\</p> Terminal<pre><code>pw.x &lt; diamond.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>diamond.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp diamond\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states and     the projections for the starting guess (written in the <code>diamond.mmn</code>     and <code>diamond.amn</code> files).</p> Terminal<pre><code>pw2wannier90.x &lt; diamond.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x diamond\n</code></pre> </li> </ul>"},{"location":"tutorials/tutorial_6/","title":"6: Copper \u2014 Fermi surface","text":"<ul> <li> <p>Outline: Obtain MLWFs to describe the states around the Fermi-level     in copper</p> </li> <li> <p>Directory: <code>tutorials/tutorial06/</code> Files can be downloaded from     here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>copper.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>copper.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states on a uniform grid</p> </li> <li> <p><code>copper.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>copper.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of copper</p> Terminal<pre><code>pw.x &lt; copper.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid</p> Terminal<pre><code>pw.x &lt; copper.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>copper.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp copper\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states and     the projections for the starting guess (written in the <code>copper.mmn</code>     and <code>copper.amn</code> files).</p> Terminal<pre><code>pw2wannier90.x &lt; copper.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x copper\n</code></pre> </li> </ul> <p>Inspect the output file <code>copper.wout</code>.</p> <ol> <li> <p>Use Wannier interpolation to obtain the Fermi surface of copper.     Rather than re-running the whole calculation we can use the unitary     transformations obtained in the first calculation and restart from     the plotting routine. Add the following keywords to the     <code>copper.win</code> file:</p> Input file<pre><code>restart = plot\n\nfermi_energy = [insert your value here]\n\nfermi_surface_plot = true\n</code></pre> <p>and re-run <code>wannier90</code>. The value of the Fermi energy can be obtained from the initial first principles calculation. <code>wannier90</code>\u00a0calculates the band energies, through Wannier interpolation, on a dense mesh of k-points in the Brillouin zone. The density of this grid is controlled by the keyword <code>fermi_surface_num_points</code>. The default value is 50 (i.e., 50\\(^3\\) points). The Fermi surface file <code>copper.bxsf</code> can be viewed using <code>XCrySDen</code>, e.g.,</p> Terminal<pre><code>xcrysden --bxsf copper.bxsf\n</code></pre> </li> <li> <p>Plot the interpolated bandstructure. A suitable path in k-space is</p> Input file<pre><code>begin kpoint_path\nG 0.00 0.00 0.00 X 0.50 0.50 0.00\nX 0.50 0.50 0.00 W 0.50 0.75 0.25\nW 0.50 0.75 0.25 L 0.00 0.50 0.00\nL 0.00 0.50 0.00 G 0.00 0.00 0.00\nG 0.00 0.00 0.00 K 0.00 0.50 -0.50\nend kpoint_path\n</code></pre> </li> </ol>"},{"location":"tutorials/tutorial_6/#further-ideas","title":"Further ideas","text":"<ul> <li> <p>Compare the Wannier interpolated bandstructure with the full     <code>pwscf</code>\u00a0bandstructure. Obtain MLWFs using a denser     k-point grid. To plot the bandstructure you can use the     <code>pwscf</code>\u00a0tool <code>bands.x</code> or the small FORTRAN program     available at http://www.tcm.phy.cam.ac.uk/~jry20/bands.html.</p> </li> <li> <p>Investigate the effects of the outer and inner energy windows on the     interpolated bands.</p> </li> <li> <p>Instead of extracting a subspace of seven states, we could extract a     nine dimensional space (i.e., with \\(s\\), \\(p\\) and \\(d\\) character).     Examine this case and compare the interpolated bandstructures.</p> </li> </ul>"},{"location":"tutorials/tutorial_7/","title":"7: Silane (SiH\\(_4\\)) \u2014 Molecular MLWFs using \\(\\Gamma\\)-point sampling","text":"<ul> <li> <p>Outline: Obtain MLWFs for the occupied states of molecular silane.     \\(\\Gamma\\)-point sampling</p> </li> <li> <p>Directory: <code>tutorials/tutorial07/</code> Files can be downloaded from     here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>silane.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>silane.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states on a uniform grid</p> </li> <li> <p><code>silane.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>silane.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of silane</p> Terminal<pre><code>pw.x &lt; silane.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid</p> Terminal<pre><code>pw.x &lt; silane.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>silane.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp silane\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states and     the projections for the starting guess (written in the <code>silane.mmn</code>     and <code>silane.amn</code> files).</p> Terminal<pre><code>pw2wannier90.x &lt; silane.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x silane\n</code></pre> </li> </ul>"},{"location":"tutorials/tutorial_8/","title":"8: Iron \u2014 Spin-polarized WFs, DOS, projected WFs versus MLWFs","text":"<ul> <li> <p>Outline: Generate both maximally-localized and projected Wannier     functions for ferromagnetic bcc Fe. Calculate the total and     orbital-projected density of states by Wannier interpolation.</p> </li> <li> <p>Directory: <code>tutorials/tutorial08/</code> Files can be downloaded from     here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>iron.scf</code> The <code>pwscf</code>\u00a0input file for the     spin-polarized ground state calculation</p> </li> <li> <p><code>iron.nscf</code> The <code>pwscf</code>\u00a0input file to obtain Bloch     states on a uniform grid</p> </li> <li> <p><code>iron_{up,down}.pw2wan</code> Input files for <code>pw2wannier90</code></p> </li> <li> <p><code>iron_{up,down}.win</code> Input files for <code>wannier90</code> and     <code>postw90</code></p> </li> </ul> </li> <li> <p>Note that in a spin-polarized calculation the spin-up and spin-down     MLWFs are computed separately. (The more general case of spinor WFs     will be treated in Tutorial\u00a017).</p> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ferromagnetic ground state of bcc Fe</p> Terminal<pre><code>pw.x &lt; iron.scf &gt; scf.out\n</code></pre> <p>Note</p> <p>Please note the following counterintuitive feature in <code>pwscf</code>: in order to obtain a ground state with magnetization along the positive \\(z\\)-axis, one should use a negative value for the variable <code>starting_magnetization</code>.</p> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid</p> Terminal<pre><code>pw.x &lt; iron.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>.nnkp</code> files).</p> Terminal<pre><code>wannier90.x -pp iron_up\nwannier90.x -pp iron_dn\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states and     the projections for the starting guess (written in the <code>.mmn</code> and     <code>.amn</code> files).</p> Terminal<pre><code>pw2wannier90.x &lt; iron_up.pw2wan &gt; pw2wan_up.out\npw2wannier90.x &lt; iron_dn.pw2wan &gt; pw2wan_dn.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x iron_up\nwannier90.x iron_dn\n</code></pre> </li> </ul>"},{"location":"tutorials/tutorial_8/#density-of-states","title":"Density of states","text":"<p>To compute the DOS using a \\(25\\times 25 \\times 25\\) \\(k\\)-point grid add to the two <code>.win</code> files</p> Input file<pre><code>dos = true\ndos_kmesh = 25\n</code></pre> <p>run <code>postw90</code>,</p> Input file<pre><code>postw90.x iron_up\npostw90.x iron_dn\n</code></pre> <p>and plot the DOS with <code>gnuplot</code>,</p> Terminal<pre><code>gnuplot\n</code></pre> Gnuplot shell<pre><code>plot 'iron_up_dos.dat' u (-\\$2):(\\$1-12.6256) w\nl,'iron_dn_dos.dat' u 2:(\\$1-12.6256) w l\n</code></pre> <p>Energies are referred to the Fermi level (12.6256\u00a0eV, from <code>scf.out</code>). Note the exchange splitting between the up-spin and down-spin DOS. Check the convergence by repeating the DOS calculations with more \\(k\\)-points.</p>"},{"location":"tutorials/tutorial_8/#projected-versus-maximally-localized-wannier-functions","title":"Projected versus maximally-localized Wannier functions","text":"<p>In the calculations above we chose \\(s\\), \\(p\\), and \\(d\\)-type trial orbitals in the <code>.win</code> files,</p> Input file<pre><code>Fe:s;p;d\n</code></pre> <p>Let us analyze the evolution of the WFs during the gauge-selection step. Open one of the <code>.wout</code> files and search for \"<code>Initial state</code>\"; those are the projected WFs. As expected they are atom-centred, with spreads organized in three groups, 1+3+5: one \\(s\\), three \\(p\\), and five \\(d\\). Now look at the final state towards the end of the file. The Wannier spreads have re-organized in two groups, 6+3; moreover, the six more diffuse WFs are off-centred: the initial atomic-like orbitals hybridized with one another, becoming more localized in the process. It is instructive to visualize the final-state MLWFs using <code>XCrySDen</code>, following Tutorial 1. For more details, see Sec.\u00a0IV.B of Ref.\u00a0<sup>1</sup>.</p> <p>Let us plot the evolution of the spread functional\u00a0\\(\\Omega\\),</p> Terminal<pre><code>grep SPRD iron_up.wout &gt; sprd_up\n\ngnuplot\n</code></pre> Gnuplot shell<pre><code>plot 'sprd_up' u 6 w l\n</code></pre> <p>The first plateau corresponds to atom-centred WFs of separate \\(s\\), \\(p\\), and \\(d\\) character, and the sharp drop signals the onset of the hybridization. With hindsight, we can redo steps\u00a04 and\u00a05 more efficiently using trial orbitals with the same character as the final MLWFs,</p> Input file<pre><code>Fe:sp3d2;dxy;dxz,dyz\n</code></pre> <p>With this choice the minimization converges much more rapidly.</p> <p>Any reasonable set of localized WFs spanning the states of interest can be used to compute physical quantities (they are \"gauge-invariant\"). Let us recompute the DOS using, instead of MLWFs, the WFs obtained by projecting onto \\(s\\), \\(p\\), and \\(d\\)-type trial orbitals, without further iterative minimization of the spread functional. This can be done by setting</p> Input file<pre><code>num_iter = 0\n</code></pre> <p>But note that we still need to do disentanglement! Recalculate the DOS to confirm that it is almost identical to the one obtained earlier using the hybridized set of MLWFs. Visualize the projected WFs using <code>XCrySDen</code>, to see that they retain the pure orbital character of the individual trial orbitals.</p>"},{"location":"tutorials/tutorial_8/#orbital-projected-dos-and-exchange-splitting","title":"Orbital-projected DOS and exchange splitting","text":"<p>With projected WFs the total DOS can be separated into \\(s\\), \\(p\\) and \\(d\\) contributions, in a similar way to the orbital decomposition of the energy bands in Tutorial\u00a04.</p> <p>In order to obtain the partial DOS projected onto the \\(p\\)-type WFs, add to the <code>.win</code> files</p> Input file<pre><code>dos_project = 2,3,4\n</code></pre> <p>and re-run <code>postw90</code>. Plot the projected DOS for both up- and down-spin bands. Repeat for the \\(s\\) and \\(d\\) projections.</p> <p>Projected WFs can also be used to quantify more precisely the exchange splitting between majority and minority states. Re-run <code>wannier90</code> after setting <code>dos=false</code> and adding to the <code>.win</code> files</p> Input file<pre><code>write_hr_diag = true\n</code></pre> <p>This instructs <code>wannier90</code> to print in the output file the on-site energies \\(\\langle {\\bf 0}n\\vert H\\vert {\\bf 0}n\\rangle\\). The difference between corresponding values in <code>iron_up.wout</code> and in <code>iron_dn.wout</code> gives the exchange splittings for the individual orbitals. Compare their magnitudes with the splittings displayed by the orbital-projected DOS plots. In agreement with the Stoner criterion, the largest exchange splittings occur for the localized \\(d\\)-states, which contribute most of the density of states at the Fermi level.</p>  Evolution of the Wannier spread \\(\\Omega\\) of the minority (spin-up) bands of bcc Fe during the iterative minimization of \\(\\widetilde{\\Omega}\\), starting from s, p and d-type trial orbitals. <ol> <li> <p>X. Wang, J. R. Yates, I. Souza, and D. Vanderbilt. Ab initio calculation of the anomalous hall conductivity by wannier interpolation. Phys. Rev. B, 74:195118, 2006.\u00a0\u21a9</p> </li> </ol>"},{"location":"tutorials/tutorial_9/","title":"9: Cubic BaTiO\\(_3\\)","text":"<ul> <li> <p>Outline: Obtain MLWFs for a perovskite</p> </li> <li> <p>Directory: <code>tutorials/tutorial09/</code> Files can be downloaded from     here</p> </li> <li> <p>Input Files</p> <ul> <li> <p><code>batio3.scf</code> The <code>pwscf</code>\u00a0input file for ground     state calculation</p> </li> <li> <p><code>batio3.nscf</code> The <code>pwscf</code>\u00a0input file to obtain     Bloch states on a uniform grid</p> </li> <li> <p><code>batio3.pw2wan</code> Input file for <code>pw2wannier90</code></p> </li> <li> <p><code>batio3.win</code> The <code>wannier90</code> input file</p> </li> </ul> </li> </ul> <p>To start with, we are going to obtain MLWFs for the oxygen 2p states. From the bandstructure\u00a0<sup>1</sup>, these form an isolated group of bands. We use the <code>wannier90</code>\u00a0keyword <code>exclude_bands</code> to remove all but the 2p bands from the calculation of the overlap and projection matrices (we don't have to do this, but it saves time).</p> <ol> <li> <p>Run <code>pwscf</code>\u00a0to obtain the ground state of BaTiO\\(_3\\)</p> Terminal<pre><code>pw.x &lt; BaTiO3.scf &gt; scf.out\n</code></pre> </li> <li> <p>Run <code>pwscf</code>\u00a0to obtain the Bloch states on a uniform     k-point grid</p> Terminal<pre><code>pw.x &lt; BaTiO3.nscf &gt; nscf.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to generate a list of the required overlaps (written     into the <code>BaTiO3.nnkp</code> file).</p> Terminal<pre><code>wannier90.x -pp BaTiO3\n</code></pre> </li> <li> <p>Run <code>pw2wannier90</code> to compute the overlap between Bloch states and     the projections for the starting guess (written in the <code>BaTiO3.mmn</code>     and <code>BaTiO3.amn</code> files).</p> Terminal<pre><code>pw2wannier90.x &lt; BaTiO3.pw2wan &gt; pw2wan.out\n</code></pre> </li> <li> <p>Run <code>wannier90</code>\u00a0to compute the MLWFs.</p> Terminal<pre><code>wannier90.x BaTiO3\n</code></pre> </li> </ol> <p>Inspect the output file <code>BaTiO3.wout</code>.</p> <p>Plot the second MLWF, as described in Section\u00a01, by adding the following keywords to the input file <code>BaTiO3.win</code></p> Input file<pre><code>wannier_plot = true\nrestart = plot\nwannier_plot_list = 2\nwannier_plot_supercell = 3\n</code></pre> <p>and re-running <code>wannier90</code>. Visualise it using <code>XCrySDen</code>,</p> Terminal<pre><code>xcrysden `--`xsf BaTiO3_00002.xsf\n</code></pre> <p>We can now simulate the ferroelectric phase by displacing the Ti atom. Change its position to</p> Input file<pre><code>Ti 0.505 0.5 0.5\n</code></pre> <p>and regenerate the MLWFs (i.e., compute the ground-state charge density and Bloch states using <code>pwscf</code>, etc.) and look at the change in the second MLWF.</p>"},{"location":"tutorials/tutorial_9/#further-ideas","title":"Further ideas","text":"<ul> <li> <p>Look at MLWFs for other groups of bands. What happens if you form     MLWFs for the whole valence manifold?</p> </li> <li> <p>Following Ref.\u00a0<sup>1</sup>, compute the Born effective     charges from the change in Wannier centres under an atomic     displacement.</p> </li> </ul> <ol> <li> <p>Nicola Marzari and David Vanderbilt. Maximally-localized Wannier functions in perovskites: Cubic BaTiO3. AIP Conference Proceedings, 436(1):146\u2013155, 06 1998.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorials/with_pwscf/","title":"Tutorials Using the pwscf Interface","text":"<p>The <code>pwscf</code>\u00a0plane-wave, density-functional theory code, which is available as part of the <code>quantum-espresso</code>\u00a0distribution (http://www.quantum-espresso.org), is fully interfaced to <code>wannier90</code>\u00a0via the <code>pw2wannier90</code> post-processing code that is also available as part of <code>quantum-espresso</code>. The latest version of <code>pw2wannier90</code> is included as part of the <code>wannier90</code>\u00a0distribution. Please see the <code>pwscf</code> directory for instructions on how to incorporate it into <code>pwscf</code>.</p> <p>Note that both the <code>pwscf</code> executable <code>pw.x</code> and <code>pw2wannier90.x</code> can be run in parallel, which for large calculations can reduce the computation time very significantly. This requires compiling the code in its parallel version, using the MPI libraries. Refer to the <code>quantum-espresso</code>\u00a0package for the documentation on how to do so. Note that, unless you specify <code>wf_collect=.true.</code> in your <code>pw.x</code> input file, you must run <code>pw2wannier90</code> with the same number of processors as <code>pw.x</code>.</p> <p>Moreover we remind here that both the <code>wannier90</code>\u00a0executable and <code>postw90.x</code> can be run in parallel. In this case any number of processors can be used, independently of the number used for <code>pw.x</code> and <code>pw2wannier90.x</code>.</p>"},{"location":"user_guide/introduction/","title":"Introduction","text":""},{"location":"user_guide/introduction/#getting-help","title":"Getting Help","text":"<p>The latest release of <code>wannier90</code>\u00a0and documentation can always be found at https://www.wannier.org.</p> <p>The development version may be cloned/downloaded from the official repository of the <code>wannier90</code>\u00a0code on GitHub (see https://github.com/wannier-developers/wannier90).</p> <p>There is a <code>wannier90</code>\u00a0mailing list for discussing issues in the development, theory, coding and algorithms pertinent to MLWF. You can register for this mailing list by following the links at https://www.wannier.org/forum.html. Alternatively, for technical issues about the <code>wannier90</code>\u00a0code, check the official repository of <code>wannier90</code>\u00a0on GitHub where you may raise issues or ask questions about its functionalities.</p> <p>Finally, many frequently asked questions are answered in Appendix\u00a0FAQs. An expanded FAQ session may be found on the Wiki page of the GitHub repository at https://github.com/wannier-developers/wannier90/wiki/FAQ.</p>"},{"location":"user_guide/introduction/#citations","title":"Citations","text":"<p>We ask that you acknowledge the use of <code>wannier90</code>\u00a0in any publications arising from the use of this code through the following reference</p> <p>[ref] G. Pizzi, V. Vitale, R. Arita, S. Bl\u00fcgel, F. Freimuth, G. G\u00e9ranton, M. Gibertini, D. Gresch, C. Johnson, T. Koretsune, J. Iba\u00f1ez-Azpiroz, H. Lee, J.M. Lihm, D. Marchand, A. Marrazzo, Y. Mokrousov, J.I. Mustafa, Y. Nohara, Y. Nomura, L. Paulatto, S. Ponc\u00e9, T. Ponweiser, J. Qiao, F. Th\u00f6le, S.S. Tsirkin, M. Wierzbowska, N. Marzari, D. Vanderbilt, I. Souza, A.A. Mostofi, J.R. Yates, Wannier90 as a community code: new features and applications, J. Phys. Cond. Matt. 32, 165902 (2020) https://doi.org/10.1088/1361-648X/ab51ff</p> <p>If you are using versions 2.x of the code, cite instead:</p> <p>[ref] A.\u00a0A.\u00a0Mostofi, J.\u00a0R.\u00a0Yates, G.\u00a0Pizzi, Y.-S.\u00a0Lee, I.\u00a0Souza, D.\u00a0Vanderbilt and N.\u00a0Marzari, An updated version of <code>wannier90</code>: A Tool for Obtaining Maximally-Localised Wannier Functions, Comput. Phys. Commun. 185, 2309 (2014) http://dx.doi.org/10.1016/j.cpc.2014.05.003</p> <p>It would also be appropriate to cite the original articles:</p> <p>Maximally localized generalized Wannier functions for composite energy bands, N. Marzari and D. Vanderbilt, Phys. Rev. B 56, 12847 (1997)</p> <p>and</p> <p>Maximally localized Wannier functions for entangled energy bands, I. Souza, N. Marzari and D. Vanderbilt, Phys. Rev. B 65, 035109 (2001)</p>"},{"location":"user_guide/introduction/#credits","title":"Credits","text":"<p>The Wannier90 Developer Group includes Giovanni Pizzi (EPFL, CH), Valerio Vitale (Cambridge, GB), David Vanderbilt (Rutgers University, US), Nicola Marzari (EPFL, CH), Ivo Souza (Universidad del Pais Vasco, ES), Arash A. Mostofi (Imperial College London, GB), and Jonathan R. Yates (University of Oxford, GB).</p> <p>The present release of <code>wannier90</code>\u00a0was written by the Wannier90 Developer Group together with Ryotaro Arita (Riken and U. Tokyo, JP), Stefan Bl\u00fcgel (FZ J\u00fclich, DE), Frank Freimuth (FZ J\u00fclich, DE), Guillame G\u00e9ranton (FZ J\u00fclich, DE), Marco Gibertini (EPFL and University of Geneva, CH), Dominik Gresch (ETHZ, CH), Charles Johnson (Imperial College London, GB), Takashi Koretsune (Tohoku University and JST PRESTO, JP), Julen Iba\u00f1ez-Azpiroz (Universidad del Pais Vasco, ES), Hyungjun Lee (EPFL, CH), Jae-Mo Lihm (Seoul National University, KR), Daniel Marchand (EPFL, CH), Antimo Marrazzo (EPFL, CH), Yuriy Mokrousov (FZ J\u00fclich, DE), Jamal I. Mustafa (UC Berkeley, USA), Yoshiro Nohara (Tokyo, JP), Yusuke Nomura (U. Tokyo, JP), Lorenzo Paulatto (Sorbonne Paris, FR), Samuel Ponc\u00e9 (Oxford University, GB), Thomas Ponweiser (RISC Software GmbH, AT), Florian Th\u00f6le (ETHZ, CH), Stepan Tsirkin (Universidad del Pais Vasco, ES), Ma\u0142gorzata Wierzbowska (Polish Academy of Science, PL).</p> <p>Contributors to the code include: Daniel Aberg (w90pov code), Lampros Andrinopoulos (w90vdw code), Pablo Aguado Puente (gyrotropic routines), Raffaello Bianco (k-slice plotting), Marco Buongiorno Nardelli (dosqc v1.0 subroutines upon which transport.f90 is based), Stefano De Gironcoli (pw2wannier90.x interface to Quantum ESPRESSO), Pablo Garcia Fernandez (matrix elements of the position operator), Nicholas D. M. Hine (w90vdw code), Young-Su Lee (specialised Gamma point routines and transport), Antoine Levitt (preconditioning), Graham Lopez (extension of pw2wannier90 to add terms needed for orbital magnetisation), Radu Miron (constrained centres), Nicolas Poilvert (transport routines), Michel Posternak (original plotting routines), Rei Sakuma (Symmetry-adapted Wannier functions), Gabriele Sclauzero (disentanglement in spheres in k-space), Matthew Shelley (transport routines), Christian Stieger (routine to print the U matrices), David Strubbe (various bugfixes/improvements), Timo Thonhauser (extension of pw2wannier90 to add terms needed for orbital magnetisation), Junfeng Qiao (spin Hall conductivity, projectability-disentangled Wannier functions).</p> <p>We also acknowledge individuals not already mentioned above who participated in the first Wannier90 community meeting (San Sebastian, 2016) for useful discussions: Daniel Fritsch, Victor Garcia Suarez, Jan-Philipp Hanke, Ji Hoon Ryoo, J\u00fcrg Hutter, Javier Junquera, Liang Liang, Michael Obermeyer, Gianluca Prandini, Paolo Umari.</p> <p><code>wannier90</code>\u00a0Version 2.x was written by: Arash A. Mostofi, Giovanni Pizzi, Ivo Souza, Jonathan R. Yates. <code>wannier90</code>\u00a0Version 1.0 was written by: Arash A. Mostofi, Jonathan R. Yates, Young-Su Lee. <code>wannier90</code>\u00a0is based on the Wannier Fortran 77 code written for isolated bands by Nicola Marzari and David Vanderbilt and for entangled bands by Ivo Souza, Nicola Marzari, and David Vanderbilt.</p> <p><code>wannier90</code>\u00a0\u00a9\u00a02007-2020 The Wannier Developer Group and individual contributors</p>"},{"location":"user_guide/introduction/#licence","title":"Licence","text":"<p>All the material in this distribution is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</p> <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</p>"},{"location":"user_guide/appendices/faq/","title":"Frequently Asked Questions","text":""},{"location":"user_guide/appendices/faq/#general-questions","title":"General Questions","text":""},{"location":"user_guide/appendices/faq/#what-is-wannier90","title":"What is <code>wannier90</code>?","text":"<p><code>wannier90</code>\u00a0is a computer package, written in Fortran90, for obtaining maximally-localised Wannier functions, using them to calculate bandstructures, Fermi surfaces, dielectric properties, sparse Hamiltonians and many things besides.</p>"},{"location":"user_guide/appendices/faq/#where-can-i-get-wannier90","title":"Where can I get <code>wannier90</code>?","text":"<p>The most recent release of <code>wannier90</code>\u00a0is always available on our website http://www.wannier.org.</p>"},{"location":"user_guide/appendices/faq/#where-can-i-get-the-most-recent-information-about-wannier90","title":"Where can I get the most recent information about <code>wannier90</code>?","text":"<p>The latest news about <code>wannier90</code>\u00a0can be followed on our website http://www.wannier.org.</p>"},{"location":"user_guide/appendices/faq/#is-wannier90-free","title":"Is <code>wannier90</code>\u00a0free?","text":"<p>Yes! <code>wannier90</code>\u00a0is available for use free-of-charge under the GNU General Public Licence. See the file <code>LICENSE</code> that comes with the <code>wannier90</code>\u00a0distribution or the GNU hopepage at http://www.gnu.org.</p>"},{"location":"user_guide/appendices/faq/#getting-help","title":"Getting Help","text":""},{"location":"user_guide/appendices/faq/#is-there-a-tutorial-available-for-wannier90","title":"Is there a Tutorial available for <code>wannier90</code>?","text":"<p>Yes! The <code>tutorials</code> directory of the <code>wannier90</code>\u00a0distribution contains input files for a number of tutorial calculations. The <code>doc</code> directory contains the accompanying tutorial handout.</p>"},{"location":"user_guide/appendices/faq/#where-do-i-get-support-for-wannier90","title":"Where do I get support for <code>wannier90</code>?","text":"<p>There are a number of options:</p> <ol> <li> <p>The <code>wannier90</code>\u00a0User Guide, available in the <code>doc</code> directory of the     distribution, and from the webpage     (http://www.wannier.org/user_guide.html)</p> </li> <li> <p>The <code>wannier90</code>\u00a0webpage for the most recent announcements     (http://www.wannier.org)</p> </li> <li> <p>The <code>wannier90</code>\u00a0mailing list (see     http://www.wannier.org/forum.html)</p> </li> </ol>"},{"location":"user_guide/appendices/faq/#is-there-a-mailing-list-for-wannier90","title":"Is there a mailing list for <code>wannier90</code>?","text":"<p>Yes! You need to register: go to http://www.wannier.org/forum.html and follow the instructions.</p>"},{"location":"user_guide/appendices/faq/#providing-help-finding-and-reporting-bugs","title":"Providing Help: Finding and Reporting Bugs","text":""},{"location":"user_guide/appendices/faq/#i-think-i-found-a-bug-how-do-i-report-it","title":"I think I found a bug. How do I report it?","text":"<ul> <li> <p>Check and double-check. Make sure it's a bug.</p> </li> <li> <p>Check that it is a bug in <code>wannier90</code>\u00a0and not a bug in the software     interfaced to <code>wannier90</code>.</p> </li> <li> <p>Check that you're using the latest version of <code>wannier90</code>.</p> </li> <li> <p>Send us an email. Make sure to describe the problem and to attach     all input and output files relating to the problem that you have     found.</p> </li> </ul>"},{"location":"user_guide/appendices/faq/#i-have-got-an-idea-how-do-i-report-a-wish","title":"I have got an idea! How do I report a wish?","text":"<p>We're always happy to listen to suggestions. Email your idea to the <code>wannier90</code>\u00a0developers.</p>"},{"location":"user_guide/appendices/faq/#i-want-to-help-how-can-i-contribute-to-wannier90","title":"I want to help! How can I contribute to <code>wannier90</code>?","text":"<p>Great! There's always plenty of functionality to add. Email us to let us know about the functionality you'd like to contribute.</p>"},{"location":"user_guide/appendices/faq/#i-like-wannier90-should-i-donate-anything-to-its-authors","title":"I like <code>wannier90</code>! Should I donate anything to its authors?","text":"<p>Our Swiss bank account number is... just kidding! There is no need to donate anything, please just cite our paper in any publications that arise from your use of <code>wannier90</code>:</p> <p>[ref] G. Pizzi, V. Vitale, R. Arita, S. Bl\u00fcgel, F. Freimuth, G. G\u00e9ranton, M. Gibertini, D. Gresch, C. Johnson, T. Koretsune, J. Iba\u00f1ez-Azpiroz, H. Lee, J.M. Lihm, D. Marchand, A. Marrazzo, Y. Mokrousov, J.I. Mustafa, Y. Nohara, Y. Nomura, L. Paulatto, S. Ponc\u00e9, T. Ponweiser, J. Qiao, F. Th\u00f6le, S.S. Tsirkin, M. Wierzbowska, N. Marzari, D. Vanderbilt, I. Souza, A.A. Mostofi, J.R. Yates, Wannier90 as a community code: new features and applications, J. Phys. Cond. Matt. 32, 165902 (2020) https://doi.org/10.1088/1361-648X/ab51ff</p> <p>If you are using versions 2.x of the code, cite instead:</p> <p>[ref] A.\u00a0A.\u00a0Mostofi, J.\u00a0R.\u00a0Yates, G.\u00a0Pizzi, Y.-S.\u00a0Lee, I.\u00a0Souza, D.\u00a0Vanderbilt and N.\u00a0Marzari, An updated version of <code>wannier90</code>: A Tool for Obtaining Maximally-Localised Wannier Functions, Comput. Phys. Commun. 185, 2309 (2014) http://doi.org/10.1016/j.cpc.2014.05.003</p>"},{"location":"user_guide/appendices/faq/#installation","title":"Installation","text":""},{"location":"user_guide/appendices/faq/#how-do-i-install-wannier90","title":"How do I install <code>wannier90</code>?","text":"<p>Follow the instructions in the file <code>README.install</code> in the main directory of the <code>wannier90</code>\u00a0distribution.</p>"},{"location":"user_guide/appendices/faq/#are-there-wannier90-binaries-available","title":"Are there <code>wannier90</code>\u00a0binaries available?","text":"<p>Not at present.</p>"},{"location":"user_guide/appendices/faq/#is-there-anything-else-i-need","title":"Is there anything else I need?","text":"<p>Yes. <code>wannier90</code>\u00a0works on top of an electronic structure calculation.</p> <p>At the time of writing there are public, fully functioning, interfaces between <code>wannier90</code>\u00a0and <code>PWSCF</code>, abinit (http://www.abinit.org), siesta (http://www.icmab.es/siesta/), VASP (https://www.vasp.at), Wien2k (http://www.wien2k.at), fleur (http://www.fleur.de), OpenMX (http://www.openmx-square.org/), GPAW (https://wiki.fysik.dtu.dk/gpaw/).</p> <p>To use <code>wannier90</code>\u00a0in combination with <code>PWSCF</code>\u00a0code (a plane-wave, pseudopotential, density-functional theory code, which is part of the <code>quantum-espresso</code> package) you will need to download <code>PWSCF</code>\u00a0from the webpage http://www.quantum-espresso.org. Then compile <code>PWSCF</code>\u00a0and the <code>wannier90</code>\u00a0interface program <code>pw2wannier90</code>. For instructions, please refer to the documentation that comes with the <code>quantum-espresso</code> distribution.</p> <p>For examples of how to use <code>PWSCF</code>\u00a0and <code>wannier90</code>\u00a0in conjunction with each other, see the <code>wannier90</code>\u00a0Tutorial.</p>"},{"location":"user_guide/appendices/utilities/","title":"Utilities","text":"<p>The <code>wannier90</code>\u00a0code is shipped with a few utility programs that may be useful in some occasions. In this chapter, we describe their use.</p>"},{"location":"user_guide/appendices/utilities/#kmeshpl","title":"<code>kmesh.pl</code>","text":"<p>The <code>wannier90</code>\u00a0code requires the definition of a full Monkhorst--Pack grid of \\(k\\) points. In the input file the size of this mesh is given by means of the <code>mp_grid</code> variable. E.g., setting</p> Input file<pre><code>mp_grid = 4 4 4\n</code></pre> <p>tells <code>wannier90</code>\u00a0that we want to use a \\(4\\times 4\\times 4\\) \\(k\\) grid.</p> <p>One has then to specify (inside the <code>kpoints</code> block in the the <code>seedname.win</code> file) the list of \\(k\\) points of the grid. Here, the <code>kmesh.pl</code> Perl script becomes useful, being able to generate the required list.</p> <p>The script can be be found in the <code>utility</code> directory of the <code>wannier90</code>\u00a0distribution. To use it, simply type:</p> Terminal<pre><code>./kmesh.pl nx ny nz\n</code></pre> <p>where <code>nx</code>, <code>ny</code> and <code>nz</code> define the size of the Monkhorst--Pack grid that we want to use (for instance, in the above example of the \\(4\\times 4\\times 4\\) \\(k\\) grid, <code>nx</code>\\(=\\)<code>ny</code>\\(=\\)<code>nz</code>\\(=\\)4).</p> <p>This produces on output the list of \\(k\\) points in Quantum Espresso format, where (apart from a header) the first three columns of each line are the \\(k\\) coordinates, and the fourth column is the weight of each \\(k\\) point. This list can be used to create the input file for the ab-initio <code>nscf</code> calculation.</p> <p>If one wants instead to generate the list of the \\(k\\) coordinates without the weight (in order to copy and paste the output inside the <code>seedname.win</code> file), one simply has to provide a fourth argument on the command line. For instance, for a \\(4\\times 4\\times 4\\) \\(k\\) grid, use</p> Terminal<pre><code>./kmesh.pl 4 4 4 wannier\n</code></pre> <p>and then copy the output inside the in the <code>kpoints</code> block in the <code>seedname.win</code> file.</p> <p>We suggest to always use this utility to generate the \\(k\\) grids. This allows to provide the \\(k\\) point coordinates with the accuracy required by <code>wannier90</code>, and moreover it makes sure that the \\(k\\) grid used in the ab-initio code and in <code>wannier90</code>\u00a0are the same.</p>"},{"location":"user_guide/appendices/utilities/#w90chk2chkx","title":"<code>w90chk2chk.x</code>","text":"<p>During the calculation of the Wannier functions, <code>wannier90</code>\u00a0produces a <code>.chk</code> file that contains some information to restart the calculation.</p> <p>This file is also required by the <code>postw90</code>\u00a0code. In particular, the <code>postw90</code>\u00a0code requires at least the <code>.chk</code> file, the <code>.win</code> input file, and (almost always) the <code>.eig</code> file. Specific modules may require further files: see the documentation of each module.</p> <p>However, the <code>.chk</code> file is written in a machine-dependent format. If one wants to run <code>wannier90</code>\u00a0on a machine, and then continue the calculation with <code>postw90</code>\u00a0on a different machine (or with <code>postw90</code>\u00a0compiled with a different compiler), the file has to be converted first in a machine-independent \"formatted\" format on the first machine, and then converted back on the second machine.</p> <p>To this aim, use the <code>w90chk2chk.x</code> executable. Note that this executable is not compiled by default: you can obtain it by executing</p> Terminal<pre><code>make w90chk2chk\n</code></pre> <p>in the main <code>wannier90</code>\u00a0directory.</p> <p>A typical use is the following:</p> <ol> <li> <p>Calculate the Wannier functions with <code>wannier90</code></p> </li> <li> <p>At the end of the calculation you will find a <code>seedname.chk</code> file.     Run (in the folder with this file) the command</p> Terminal<pre><code>w90chk2chk.x -export seedname\n</code></pre> <p>or equivalently</p> Terminal<pre><code>w90chk2chk.x -u2f seedname\n</code></pre> <p>(replacing <code>seedname</code> with the seedname of your calculation).</p> <p>This command reads the <code>seedname.chk</code> file and creates a formatted file <code>seedname.chk.fmt</code> that is safe to be transferred between different machines.</p> </li> <li> <p>Copy the <code>seedname.chk.fmt</code> file (together with the <code>seedname.win</code>     and <code>seedname.eig</code> files) on the machine on which you want to run     <code>postw90</code>.</p> </li> <li> <p>On this second machine (after having compiled <code>w90chk2chk.x</code>) run</p> Terminal<pre><code>w90chk2chk.x -import seedname\n</code></pre> <p>or equivalently</p> Terminal<pre><code>w90chk2chk.x -f2u seedname\n</code></pre> <p>This command reads the <code>seedname.chk.fmt</code> file and creates an unformatted file <code>seedname.chk</code> ready to be used by <code>postw90</code>.</p> </li> <li> <p>Run the <code>postw90</code>\u00a0code.</p> </li> </ol>"},{"location":"user_guide/appendices/utilities/#pl_assessment","title":"<code>PL_assessment</code>","text":"<p>The function of this utility is to assess the length of a principal layer (in the context of a Landauer-Buttiker quantum conductance calculation) of a periodic system using a calculation on a single unit cell with a dense k-point mesh.</p> <p>The utility requires the real-space Hamiltonian in the MLWF basis, <code>seedname_hr.dat</code>.</p> <p>The <code>seedname_hr.dat</code> file should be copied to a directory containing executable for the utility. Within that directory, run:</p> Terminal<pre><code>./PL_assess.x  nk1 nk2 nk3 num_wann \n</code></pre> <p>where:</p> <p><code>nk1</code> is the number of k-points in x-direction <code>nk2</code> is the number of k-points in y-direction <code>nk3</code> is the number of k-points in z-direction <code>num_wann</code> is the number of wannier functions of your system</p> <p>e.g.,</p> Terminal<pre><code>./PL_assess.x  1 1 20 16\n</code></pre> <p>Note that the current implementation only allows for a single k-point in the direction transverse to the transport direction.</p> <p>When prompted, enter the seedname.</p> <p>The programme will return an output file <code>seedname_pl.dat</code>, containing four columns</p> <ol> <li> <p>Unit cell number, \\(R\\)</p> </li> <li> <p>Average 'on-site' matrix element between MLWFs in the home unit     cell, and the unit cell \\(R\\) lattice vectors away</p> </li> <li> <p>Standard devaition of the quantity in (2)</p> </li> <li> <p>Maximum absolute value in (2)</p> </li> </ol>"},{"location":"user_guide/appendices/utilities/#w90vdw","title":"<code>w90vdw</code>","text":"<p>This utility provides an implementation of a method for calculating van der Waals energies based on the idea of density decomposition via MLWFs.</p> <p>For theoretical details, please see the following publication and references therein:</p> <p>Lampros Andrinopoulos, Nicholas D. M. Hine and Arash A. Mostofi, \"Calculating dispersion interactions using maximally localized Wannier functions\", J. Chem. Phys. 135, 154105 (2011).</p> <p>For further details of this program, please see the documentation in <code>utility/w90vdw/doc/</code> and the related examples in <code>utility/w90vdw/examples/</code>.</p>"},{"location":"user_guide/appendices/utilities/#w90pov","title":"<code>w90pov</code>","text":"<p>An utility to create Pov files (to render the Wannier functions using the PovRay utility) is provided inside <code>utility/w90pov</code>.</p> <p>Please refer to the documentation inside <code>utility/w90pov/doc</code> for more information.</p>"},{"location":"user_guide/appendices/utilities/#k_mapperpy","title":"<code>k_mapper.py</code>","text":"<p>The <code>wannier90</code>\u00a0code requires the definition of a full Monkhorst--Pack grid of \\(\\mathbf{k}\\)-vectors, which can be obtained by means of the <code>kmesh.pl</code> utility. In order to perform a GW calculation with the Yambo code, you need to perform a nscf calculation on a grid in the irreducible BZ. Moreover, you may need a finer grid to converge the GW calculation than what you need to interpolate the band structure. The <code>k_mapper.py</code> tools helps in finding the \\(\\mathbf{k}\\)-vectors indexes of a full grid needed for interpolation into the reduced grid needed for the GW calculation with Yambo. Usage:</p> Terminal<pre><code>path/k_mapper.py nx ny nz QE_nscf_output\n</code></pre> <p>where <code>path</code> is the path of <code>utility</code> folder, <code>QE_nscf_output</code> is the path of the QE nscf output file given to Yambo.</p>"},{"location":"user_guide/appendices/utilities/#gw2wannier90py","title":"<code>gw2wannier90.py</code>","text":"<p>This utility allows to sort in energy the input data of <code>wannier90</code> (e.g. overlap matrices and energy eigenvalues). <code>gw2wannier90.py</code> allows to use <code>wannier90</code> at the \\(G_0W_0\\) level, where quasi-particle corrections can change the energy ordering of eigenvalues (Some <code>wannier90</code> modules require states to be ordered in energy). Usage:</p> Terminal<pre><code>path/gw2wannier90.py seedname options\n</code></pre> <p>where <code>path</code> is the path of <code>utility</code> folder.</p> <p>Available options are:</p> Terminal<pre><code>mmn, amn, spn, unk, uhu, uiu,\nspn_formatted, unk_formatted, uhu_formatted, uiu_formatted,\nwrite_formatted\n</code></pre> <p>If no options are specified, all the files (<code>mmn, amn, spn, UNK, uHu, uIu</code>) are considered.</p> <p>Binary (unformatted Fortran) files are supported, though not reccommended, since they are compiler-dependent. A safer choice is to use (bigger) formatted files, with options:</p> <p><code>spn_formatted, uiu_formatted, uhu_formatted, unk_formatted</code></p> <p>In default, the output format is the same as the input format. To generate formatted files with unformatted input, use option: <code>write_formatted</code></p>"},{"location":"user_guide/appendices/utilities/#w90spn2spnx","title":"<code>w90spn2spn.x</code>","text":"<p>The interface between ab-initio code and <code>wannier90</code>\u00a0(e.g. <code>pw2wannier90.x</code>) can produce a <code>.spn</code> file that is used by <code>postw90</code>\u00a0to calculate some spin related quantities.</p> <p>The <code>.spn</code> file can be written in a machine-dependent or a machine-independent format depending on the input parameter <code>spn_formatted</code> (the default is <code>false</code> which means the <code>.spn</code> file is machine-dependent) of the <code>pw2wannier90.x</code>. If a <code>.spn</code> file has been generated on a machine with machine-dependent format, and then one wants to continue the calculation with <code>postw90</code>\u00a0on a different machine (or with <code>postw90</code>\u00a0compiled with a different compiler), the file has to be converted first in a machine-independent \"formatted\" format on the first machine.</p> <p>To this aim, use the <code>w90spn2spn.x</code> executable. Note that this executable is not compiled by default: you can obtain it by executing</p> Terminal<pre><code>make w90spn2spn\n</code></pre> <p>in the main <code>wannier90</code>\u00a0directory.</p> <p>A typical use is the following:</p> <ol> <li> <p>Calculate the <code>.spn</code> file, e.g. by <code>pw2wannier90.x</code></p> </li> <li> <p>At the end of the calculation you will find a <code>seedname.spn</code> file.     If the file is \"unformatted\", run (in the folder with this file) the     command</p> Terminal<pre><code>w90spn2spn.x -export seedname\n</code></pre> <p>or equivalently</p> Terminal<pre><code>w90spn2spn.x -u2f seedname\n</code></pre> <p>(replacing <code>seedname</code> with the seedname of your calculation).</p> <p>This command reads the <code>seedname.spn</code> file and creates a formatted file <code>seedname.spn.fmt</code> that is safe to be transferred between different machines.</p> </li> <li> <p>Copy the <code>seedname.spn.fmt</code> file on the machine on which you want to     run <code>postw90</code>.</p> </li> <li> <p>On this second machine (after having compiled <code>w90spn2spn.x</code>) run</p> Terminal<pre><code>w90spn2spn.x -import seedname\n</code></pre> <p>or equivalently</p> Terminal<pre><code>w90spn2spn.x -f2u seedname\n</code></pre> <p>This command reads the <code>seedname.spn.fmt</code> file and creates an unformatted file <code>seedname.spn</code> ready to be used by <code>postw90</code>.</p> </li> <li> <p>Run the <code>postw90</code>\u00a0code.</p> </li> </ol> <p>Note if <code>spn_formatted</code> is set to <code>true</code> in both <code>pw2wannier90.x</code> and <code>postw90</code>\u00a0input files, then the <code>.spn</code> file will be written and read as \"formatted\", so <code>w90spn2spn.x</code> is not needed. However, if an \"unformatted\" <code>seedname.spn</code> has been created and you do not want to rerun <code>pw2wannier90.x</code>, then <code>w90spn2spn.x</code> can be useful. Also, once a \"formatted\" <code>seedname.spn</code> has been generated, the step 4 can be skipped if <code>spn_formatted</code> is set to <code>true</code> in <code>postw90</code>\u00a0input file <code>seedname.win</code>.</p>"},{"location":"user_guide/appendices/utilities/#write_pdwf_projectorspy","title":"<code>write_pdwf_projectors.py</code>","text":"<p>A python script to extract projectors from a <code>UPF</code> file and write them into a <code>pw2wannier90.x</code>-recognizable <code>dat</code> file, which can be used to compute <code>amn</code> using pseudo-atomic orbital projection.</p> <p>Usage:</p> Terminal<pre><code>path/write_pdwf_projectors.py UPF_filename\n</code></pre> <p>where <code>path</code> is the path of <code>utility</code> folder, <code>UPF_filename</code> is the path of a <code>UPF</code> file.</p> <p>The script serves as a reference for writing the <code>dat</code> file, you can generate your own pseudo-atomic orbitals by some other codes and use them to compute <code>amn</code>.</p>"},{"location":"user_guide/postw90/berry/","title":"Overview of the <code>berry</code> module","text":"<p>The <code>berry</code> module of <code>postw90</code> is called by setting <code>berry = true</code> and choosing one or more of the available options for <code>berry_task</code>. The routines in the <code>berry</code> module which compute the \\(k\\)-space Berry curvature, orbital magnetization and spin Hall conductivity are also called when <code>kpath = true</code> and <code>kpath_task = {curv,morb,shc}</code>, or when <code>kslice = true</code> and <code>kslice_task = {curv,morb,shc}</code>.</p>"},{"location":"user_guide/postw90/berry/#background-berry-connection-and-curvature","title":"Background: Berry connection and curvature","text":"<p>The Berry connection is defined in terms of the cell-periodic Bloch states \\(\\vert u_{n{\\bf k}}\\rangle=e^{-i{\\bf k}\\cdot{\\bf r}}\\vert \\psi_{n{\\bf k}}\\rangle\\) as</p> \\[ \\begin{equation} {\\bf A}_n({\\bf k})=\\langle u_{n{\\bf k}}\\vert i\\bm{\\nabla}_{\\bf k}\\vert u_{n{\\bf k}}\\rangle, \\end{equation} \\] <p>and the Berry curvature is the curl of the connection,</p> \\[ \\begin{equation} \\bm{\\Omega}_n({\\bf k})=\\bm{\\nabla}_{\\bf k}\\times {\\bf A}_n({\\bf k})= -{\\rm Im} \\langle \\bm{\\nabla}_{\\bf k} u_{n{\\bf k}}\\vert \\times \\vert\\bm{\\nabla}_{\\bf k} u_{n{\\bf k}}\\rangle. \\end{equation} \\] <p>These two quantities play a central role in the description of several electronic properties of crystals\u00a0<sup>1</sup>. In the following we will work with a matrix generalization of the Berry connection,</p> \\[ \\begin{equation} \\label{eq:berry-connection-matrix} {\\bf A}_{nm}({\\bf k})=\\langle u_{n{\\bf k}}\\vert i\\bm{\\nabla}_{\\bf k}\\vert u_{m{\\bf k}}\\rangle={\\bf A}_{mn}^*({\\bf k}), \\end{equation} \\] <p>and write the curvature as an antisymmetric tensor,</p> \\[ \\begin{equation} \\label{eq:curv} \\Omega_{n,\\alpha\\beta}({\\bf k}) =\\epsilon_{\\alpha\\beta\\gamma} \\Omega_{n,\\gamma}({\\bf k})=-2{\\rm Im}\\langle \\nabla_{k_\\alpha} u_{n\\bf k}\\vert \\nabla_{k_\\beta} u_{n\\bf k}\\rangle. \\end{equation} \\]"},{"location":"user_guide/postw90/berry/#berry_taskkubo-optical-conductivity-and-joint-density-of-states","title":"<code>berry_task=kubo</code>: optical conductivity and joint density of states","text":"<p>The Kubo-Greenwood formula for the optical conductivity of a crystal in the independent-particle approximation reads</p> \\[ \\begin{equation} \\sigma_{\\alpha\\beta}(\\hbar\\omega)=\\frac{ie^2\\hbar}{N_k\\Omega_c} \\sum_{\\bf k}\\sum_{n,m} \\frac{f_{m{\\bf k}}-f_{n{\\bf k}}}      {\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}} \\frac{\\langle\\psi_{n{\\bf k}}\\vert v_\\alpha\\vert\\psi_{m{\\bf k}}\\rangle       \\langle\\psi_{m{\\bf k}}\\vert v_\\beta\\vert\\psi_{n{\\bf k}}\\rangle} {\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}-(\\hbar\\omega+i\\eta)}. \\end{equation} \\] <p>Indices \\(\\alpha,\\beta\\) denote Cartesian directions, \\(\\Omega_c\\) is the cell volume, \\(N_k\\) is the number of \\(k\\)-points used for sampling the Brillouin zone, and \\(f_{n{\\bf k}}=f(\\varepsilon_{n{\\bf k}})\\) is the Fermi-Dirac distribution function. \\(\\hbar\\omega\\) is the optical frequency, and \\(\\eta&gt;0\\) is an adjustable smearing parameter with units of energy.</p> <p>The off-diagonal velocity matrix elements can be expressed in terms of the connection matrix\u00a0<sup>2</sup>,</p> \\[ \\begin{equation} \\label{eq:velocity_mat} \\langle\\psi_{n{\\bf k}}\\vert {\\bf v} \\vert\\psi_{m{\\bf k}}\\rangle= -\\frac{i}{\\hbar}(\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}) {\\bf A}_{nm}({\\bf k})\\,\\,\\,\\,\\,\\,\\,\\,(m\\not= n). \\end{equation} \\] <p>The conductivity becomes</p> \\[ \\begin{equation} \\label{eq:sig-k} \\begin{aligned} \\sigma_{\\alpha\\beta}(\\hbar\\omega)&amp;= \\frac{1}{N_k}\\sum_{\\bf k}\\sigma_{{\\bf k},\\alpha\\beta}(\\hbar\\omega)\\\\ \\sigma_{{\\bf k},\\alpha\\beta}(\\hbar\\omega)&amp;=\\frac{ie^2}{\\hbar\\Omega_c}\\sum_{n,m} (f_{m{\\bf k}}-f_{n{\\bf k}}) \\frac{\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}} {\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}-(\\hbar\\omega+i\\eta)} A_{nm,\\alpha}({\\bf k})A_{mn,\\beta}({\\bf k}) \\end{aligned} \\end{equation} \\] <p>Let us decompose it into Hermitian (dissipative) and anti-Hermitean (reactive) parts. Note that</p> \\[ \\begin{equation} \\label{eq:lorentzian} \\overline{\\delta}(\\varepsilon)=\\frac{1}{\\pi}{\\rm Im} \\left[\\frac{1}{\\varepsilon-i\\eta}\\right], \\end{equation} \\] <p>where \\(\\overline{\\delta}\\) denotes a \"broadended\" delta-function. Using this identity we find for the Hermitean part</p> \\[ \\begin{equation} \\label{eq:sig-H} \\sigma_{{\\bf k},\\alpha\\beta}^{\\rm H}(\\hbar\\omega)=-\\frac{\\pi e^2}{\\hbar\\Omega_c} \\sum_{n,m}(f_{m{\\bf k}}-f_{n{\\bf k}}) (\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}) A_{nm,\\alpha}({\\bf k})A_{mn,\\beta}({\\bf k}) \\overline{\\delta}(\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}-\\hbar\\omega). \\end{equation} \\] <p>Improved numerical accuracy can be achieved by replacing the Lorentzian (Eq. \\(\\eqref{eq:lorentzian}\\)) with a Gaussian, or other shapes. The analytical form of \\(\\overline{\\delta}(\\varepsilon)\\) is controlled by the keyword <code>[kubo_]smr_type</code>.</p> <p>The anti-Hermitean part of Eq.\u00a0\\(\\eqref{eq:sig-k}\\) is given by</p> \\[ \\begin{equation} \\label{eq:sig-AH} \\sigma_{{\\bf k},\\alpha\\beta}^{\\rm AH}(\\hbar\\omega)=\\frac{ie^2}{\\hbar\\Omega_c} \\sum_{n,m}(f_{m{\\bf k}}-f_{n{\\bf k}}) {\\rm Re}\\left[ \\frac{\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}}                     {\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}                      -(\\hbar\\omega+i\\eta)} \\right] A_{nm,\\alpha}({\\bf k})A_{mn,\\beta}({\\bf k}). \\end{equation} \\] <p>Finally the joint density of states is</p> \\[ \\begin{equation} \\label{eq:jdos} \\rho_{cv}(\\hbar\\omega)=\\frac{1}{N_k}\\sum_{\\bf k}\\sum_{n,m} f_{n{\\bf k}}(1-f_{m{\\bf k}}) \\overline{\\delta}(\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}}-\\hbar\\omega). \\end{equation} \\] <p>Equations\u00a0\\(\\eqref{eq:lorentzian}\\)--\\(\\eqref{eq:jdos}\\) contain the parameter \\(\\eta\\), whose value can be chosen using the keyword <code>[kubo_]smr_fixed_en_width</code>. Better results can often be achieved by adjusting the value of \\(\\eta\\) for each pair of states, i.e., \\(\\eta\\rightarrow \\eta_{nm\\bf k}\\). This is done as follows (see description of the keyword <code>adpt_smr_fac</code>)</p> \\[ \\begin{equation} \\eta_{nm{\\bf k}}=\\alpha\\vert \\bm{\\nabla}_{\\bf k} (\\varepsilon_{m{\\bf k}}-\\varepsilon_{n{\\bf k}})\\vert \\Delta k. \\end{equation} \\] <p>The energy eigenvalues \\(\\varepsilon_{n\\bf k}\\), band velocities \\(\\bm{\\nabla}_{\\bf k}\\varepsilon_{n{\\bf k}}\\), and off-diagonal Berry connection \\({\\bf A}_{nm}({\\bf k})\\) entering the previous four equations are evaluated over a \\(k\\)-point grid by Wannier interpolation, as described in Refs.\u00a0<sup>3</sup><sup>4</sup>. After averaging over the Brillouin zone, the Hermitean and anti-Hermitean parts of the conductivity are assembled into the symmetric and antisymmetric tensors</p> \\[ \\begin{equation} \\begin{aligned} \\sigma^{\\rm S}_{\\alpha\\beta}&amp;= {\\rm Re}\\sigma^{\\rm H}_{\\alpha\\beta}+i{\\rm Im}\\sigma^{\\rm AH}_{\\alpha\\beta}\\\\ \\sigma^{\\rm A}_{\\alpha\\beta}&amp;= {\\rm Re}\\sigma^{\\rm AH}_{\\alpha\\beta}+i{\\rm Im}\\sigma^{\\rm H}_{\\alpha\\beta}, \\end{aligned} \\end{equation} \\] <p>whose independent components are written as a function of frequency onto nine separate files.</p>"},{"location":"user_guide/postw90/berry/#berry_taskahc-anomalous-hall-conductivity","title":"<code>berry_task=ahc</code>: anomalous Hall conductivity","text":"<p>The antisymmetric tensor \\(\\sigma^{\\rm A}_{\\alpha\\beta}\\) is odd under time reversal, and therefore vanishes in non-magnetic systems, while in ferromagnets with spin-orbit coupling it is generally nonzero. The imaginary part \\({\\rm Im}\\sigma^{\\rm H}_{\\alpha\\beta}\\) describes magnetic circular dichroism, and vanishes as \\(\\omega\\rightarrow 0\\). The real part \\({\\rm Re}\\sigma^{\\rm AH}_{\\alpha\\beta}\\) describes the anomalous Hall conductivity (AHC), and remains finite in the static limit.</p> <p>The intrinsic dc AHC is obtained by setting \\(\\eta=0\\) and \\(\\omega=0\\) in Eq.\u00a0\\(\\eqref{eq:sig-AH}\\). The contribution from point \\({\\bf k}\\) in the Brillouin zone is</p> \\[ \\begin{equation} \\sigma^{\\rm AH}_{{\\bf k},\\alpha\\beta}(0)=\\frac{2e^2}{\\hbar\\Omega_c} \\sum_{n,m}f_{n\\bf k}(1-f_{m\\bf k}) {\\rm Im}\\langle \\nabla_{k_\\alpha} u_{n\\bf k}\\vert u_{m\\bf k}\\rangle \\langle u_{m\\bf k}\\vert\\nabla_{k_\\beta} u_{n\\bf k}\\rangle, \\end{equation} \\] <p>where we replaced \\(f_{n\\bf k}-f_{m\\bf k}\\) with \\(f_{n\\bf k}(1-f_{m\\bf k})-f_{m\\bf k}(1-f_{n\\bf k})\\).</p> <p>This expression is not the most convenient for ab initio calculations, as the sums run over the complete set of occupied and empty states. In practice the sum over empty states can be truncated, but a relatively large number should be retained to obtain accurate results. Using the resolution of the identity \\(1=\\sum_m \\vert u_{m\\bf k} \\rangle \\langle u_{m\\bf k}\\vert\\) and noting that the term \\(\\sum_{n,m}f_{n\\bf k}f_{m\\bf k}(\\ldots)\\) vanishes identically, we arrive at the celebrated formula for the intrinsic AHC in terms of the Berry curvature,</p> \\[ \\begin{equation} \\label{eq:ahc} \\begin{aligned} \\sigma^{\\rm AH}_{\\alpha\\beta}(0)&amp;=\\frac{e^2}{\\hbar} \\frac{1}{N_k\\Omega_c}\\sum_{\\bf k}(-1)\\Omega_{\\alpha\\beta}({\\bf k}),\\\\ %\\sum_n (-1)f_{n\\bf k}\\Omega_{n,\\alpha\\beta}({\\bf k}). \\Omega_{\\alpha\\beta}({\\bf k})&amp;=\\sum_n f_{n\\bf k}\\Omega_{n,\\alpha\\beta}({\\bf k}). \\end{aligned} \\end{equation} \\] <p>Note that only occupied states enter this expression. Once we have a set of Wannier functions spanning the valence bands (together with a few low-lying conduction bands, typically) Eq.\u00a0\\(\\eqref{eq:ahc}\\) can be evaluated by Wannier interpolation as described in Refs.\u00a0<sup>3</sup><sup>5</sup>, with no truncation involved.</p>"},{"location":"user_guide/postw90/berry/#berry_taskmorb-orbital-magnetization","title":"<code>berry_task=morb</code>: orbital magnetization","text":"<p>The ground-state orbital magnetization of a crystal is given by\u00a0<sup>1</sup><sup>6</sup></p> \\[ \\begin{equation} \\label{eq:morb} \\begin{aligned} {\\bf M}^{\\rm orb}&amp;=\\frac{e}{\\hbar} %\\int_{\\rm BZ}\\frac{d{\\bf k}}{(2\\pi)^3} \\frac{1}{N_k\\Omega_c}\\sum_{\\bf k}{\\bf M}^{\\rm orb}({\\bf k}),\\\\ {\\bf M}^{\\rm orb}({\\bf k})&amp;= \\sum_n\\,\\frac{1}{2}f_{n{\\bf k}}\\, {\\rm Im}\\,\\langle \\bm{\\nabla}_{\\bf k}u_{n{\\bf k}}\\vert \\times \\left(H_{\\bf k}+\\varepsilon_{n{\\bf k}}-2\\varepsilon_F\\right) \\vert \\bm{\\nabla}_{\\bf k}u_{n{\\bf k}}\\rangle, \\end{aligned} \\end{equation} \\] <p>where \\(\\varepsilon_F\\) is the Fermi energy. The Wannier-interpolation calculation is described in Ref.\u00a0<sup>5</sup>. Note that the definition of \\({\\bf M}^{\\rm orb}({\\bf k})\\) used here differs by a factor of \\(-1/2\\) from the one in Eq.\u00a0(97) and Fig.\u00a02 of that work.</p>"},{"location":"user_guide/postw90/berry/#sec:shc","title":"<code>berry_task=shc</code>: spin Hall conductivity","text":"<p>The Kubo-Greenwood formula for the intrinsic spin Hall conductivity (SHC) of a crystal in the independent-particle approximation reads <sup>7</sup><sup>8</sup><sup>9</sup></p> \\[ \\begin{equation} \\label{eq:kubo_shc} \\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}(\\omega) =  \\frac{\\hbar}{\\Omega_c N_k} \\sum_{\\bm{k}}\\sum_{n} f_{n\\bm{k}} \\\\ \\sum_{m \\neq n} \\frac{2\\operatorname{Im}[\\langle n\\bm{k}| \\hat{j}_{\\alpha}^{\\gamma}|m\\bm{k}\\rangle  \\langle m\\bm{k}| -e\\hat{v}_{\\beta}|n\\bm{k}\\rangle]} {(\\epsilon_{n\\bm{k}}-\\epsilon_{m\\bm{k}})^2-(\\hbar\\omega +i\\eta)^2}. \\end{equation} \\] <p>The spin current operator \\(\\hat{j}_{\\alpha}^{\\gamma}= \\frac{1}{2}\\{\\hat{s}_{\\gamma},\\hat{v}_{\\alpha}\\}\\) where the spin operator \\(\\hat{s}_{\\gamma}=\\frac{\\hbar}{2}\\hat{\\sigma}_{\\gamma}\\). Indices \\(\\alpha,\\beta\\) denote Cartesian directions, \\(\\gamma\\) denotes the direction of spin, commonly \\(\\alpha = x, \\beta = y, \\gamma = z\\). \\(\\Omega_c\\) is the cell volume, \\(N_k\\) is the number of \\(k\\)-points used for sampling the Brillouin zone, and \\(f_{n{\\bf k}}=f(\\varepsilon_{n{\\bf k}})\\) is the Fermi-Dirac distribution function. \\(\\hbar\\omega\\) is the optical frequency, and \\(\\eta&gt;0\\) is an adjustable smearing parameter with unit of energy.</p> <p>The velocity matrix element in the numerator is the same as Eq.\u00a0\\(\\eqref{eq:velocity_mat}\\), so the only unknown quantity is the spin current matrix \\(\\langle n\\bm{k}| \\hat{j}_{\\alpha}^{\\gamma}|m\\bm{k}\\rangle\\). We can use Wannier interpolation technique to efficiently calculate this matrix, and there are two derivation according to the degree of approximation. A noteworthy difference is the way in which two ab-initio matrix elements are evaluated,</p> \\[ \\begin{equation} \\langle u_{n{\\bf k}}\\vert\\sigma_\\gamma H_{\\bf k} \\vert u_{m{\\bf k}+{\\bf b}}\\rangle, \\langle u_{n{\\bf k}}\\vert \\sigma_\\gamma \\vert u_{m{\\bf k}+{\\bf b}}\\rangle, \\gamma = x, y, z \\end{equation} \\] <p>These are evaluated by <code>pw2wannier90</code> using Ryoo's method. In contrast, Qiao's method does not require <code>pw2wannier90</code>, but it assumes an approximation \\(1\\approx\\sum_{ l\\in ab-initio{\\rm \\,bands}}|u_{l\\bm{k}}\\rangle \\langle u_{l\\bm{k}}|\\). You can choose which method to evaluate this value with <code>shc_method</code> in the input file. For a full derivation please refer to Ref.\u00a0<sup>7</sup> or Ref.\u00a0<sup>8</sup>.</p> <p>The Eq.\u00a0\\(\\eqref{eq:kubo_shc}\\) can be further separated into band-projected Berry curvature-like term</p> \\[ \\begin{equation} \\label{eq:kubo_shc_berry} \\Omega_{n,\\alpha\\beta}^{\\text{spin}\\gamma}(\\bm{k}) = {\\hbar}^2 \\sum_{  m\\ne n}\\frac{-2\\operatorname{Im}[\\langle n\\bm{k}|  \\frac{1}{2}\\{\\hat{\\sigma}_{\\gamma},\\hat{v}_{\\alpha}\\}|m\\bm{k}\\rangle  \\langle m\\bm{k}| \\hat{v}_{\\beta}|n\\bm{k}\\rangle]} {(\\epsilon_{n\\bm{k}}-\\epsilon_{m\\bm{k}})^2-(\\hbar\\omega+i\\eta)^2}, \\end{equation} \\] <p>\\(k\\)-resolved term which sums over occupied bands</p> \\[ \\begin{equation} \\label{eq:kubo_shc_berry_sum} \\Omega_{\\alpha\\beta}^{\\text{spin}\\gamma}(\\bm{k}) = \\sum_{n} f_{n\\bm{k}} \\Omega_{n,\\alpha\\beta}^{\\text{spin}\\gamma}(\\bm{k}), \\end{equation} \\] <p>and the SHC is</p> \\[ \\begin{equation} \\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}(\\omega) = -\\frac{e^2}{\\hbar}\\frac{1}{\\Omega_c N_k}\\sum_{\\bm{k}} \\Omega_{\\alpha\\beta}^{\\text{spin}\\gamma}(\\bm{k}). \\end{equation} \\] <p>The unit of the \\(\\Omega_{n,\\alpha\\beta}^{\\text{spin}\\gamma}(\\bm{k})\\) is \\(\\text{length}^{2}\\) (Angstrom\\(^2\\) or Bohr\\(^2\\), depending on your choice of <code>berry_curv_unit</code> in the input file), and the unit of \\(\\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}\\) is \\((\\hbar/e)\\)S/cm (the unit is written in the header of the output file). The case of \\(\\omega=0\\) corresponds to direct current (dc) SHC while that of \\(\\omega\\ne0\\) corresponds to alternating current (ac) SHC or frequency-dependent SHC. Note in some papers Eq.\u00a0\\(\\eqref{eq:kubo_shc_berry}\\) is called as spin Berry curvature. However, it was pointed out by Ref.\u00a0<sup>10</sup> that this name is misleading, so we use a somewhat awkward name \"Berry curvature-like term\" to refer to Eq.\u00a0\\(\\eqref{eq:kubo_shc_berry}\\). The \\(k\\)-resolved term Eq.\u00a0\\(\\eqref{eq:kubo_shc_berry_sum}\\) can be used to draw <code>kslice</code> plot, and the band-projected Berry curvature-like term Eq.\u00a0\\(\\eqref{eq:kubo_shc_berry}\\) can be used to color the <code>kpath</code> plot.</p> <p>Same as the case of optical conductivity, the parameter \\(\\eta\\) contained in the Eq.\u00a0\\(\\eqref{eq:kubo_shc_berry}\\) can be chosen using the keyword <code>[kubo_]smr_fixed_en_width</code>. Also, adaptive smearing can be employed by the keyword <code>[kubo_]adpt_smr</code> (see Tutorials 29 and 30 in the Tutorial).</p> <p>Please cite the following paper\u00a0<sup>7</sup> or \u00a0<sup>8</sup> when publishing SHC results obtained using this method:</p> <p>Junfeng Qiao, Jiaqi Zhou, Zhe Yuan, and Weisheng Zhao, Calculation of intrinsic spin Hall conductivity by Wannier interpolation, Phys. Rev. B. 98, 214402 (2018), DOI:10.1103/PhysRevB.98.214402.</p> <p>or</p> <p>Ji Hoon Ryoo, Cheol-hwan Park, and Ivo Souza, Computation of intrinsic spin Hall conductivities from first principles using maximally localized Wannier functions, Phys. Rev. B. 99, 235113 (2019), DOI:10.1103/PhysRevB.99.235113.</p>"},{"location":"user_guide/postw90/berry/#berry_tasksc-shift-current","title":"<code>berry_task=sc</code>: shift current","text":"<p>The shift-current contribution to the second-order response is characterized by a frequency-dependent third-rank tensor\u00a0<sup>11</sup></p> \\[ \\begin{equation} \\label{eq:shiftcurrent} \\begin{split} \\sigma^{abc}(0;\\omega,-\\omega)=&amp;-\\frac{i\\pi e^3}{4\\hbar^2 \\Omega_c N_k} \\sum_{\\bm{k}} \\sum_{n,m}(f_{n\\bm{k}}-f_{m\\bm{k}}) \\times \\left(r^b_{ mn}(\\bm{k})r^{c;a}_{nm}(\\bm{k}) + r^c_{mn}(\\bm{k})r^{b;a}_{ nm}(\\bm{k})\\right)\\\\ &amp;\\times \\left[\\delta(\\omega_{mn\\bm{k}}-\\omega)+\\delta(\\omega_{nm\\bm{k}}-\\omega)\\right], \\end{split} \\end{equation} \\] <p>where \\(a,b,c\\) are spatial indexes and \\(\\omega_{mn\\bm{k}}=(\\epsilon_{n\\bm{k}}-\\epsilon_{m\\bm{k}})/\\hbar\\). The expression in Eq.\u00a0\\(\\eqref{eq:shiftcurrent}\\) involves the dipole matrix element</p> \\[ \\begin{equation} \\label{eq:r} r^a_{ nm}(\\bm{k})=(1-\\delta_{nm})A^a_{ nm}(\\bm{k}), \\end{equation} \\] <p>and its generalized derivative</p> \\[ \\begin{equation} \\label{eq:gen-der} r^{a;b}_{nm}(\\bm{k})=\\partial_{k_{b}} r^a_{nm}(\\bm{k}) -i\\left(A^b_{nn}(\\bm{k})-A^b_{ mm}(\\bm{k})\\right)r^a_{ nm}(\\bm{k}). \\end{equation} \\] <p>The first-principles evaluation of the above expression is technically challenging due to the presence of an extra \\(k\\)-space derivative. The implementation in <code>wannier90</code> follows the scheme proposed in Ref.\u00a0<sup>12</sup>, following the spirit of the Wannier-interpolation method for calculating the AHC\u00a0<sup>3</sup> by reformulating \\(k\\cdot p\\) perturbation theory within the subspace of wannierized bands. This strategy inherits the practical advantages of the sum-over-states approach, but without introducing the truncation errors usually associated with this procedure\u00a0<sup>11</sup>.</p> <p>As in the case of the optical conductivity, a broadened delta function can be applied in Eq.\u00a0\\(\\eqref{eq:shiftcurrent}\\) by means of the parameter \\(\\eta\\) (see Eq.\u00a0\\(\\eqref{eq:lorentzian}\\)) using the keyword <code>[kubo_]smr_fixed_en_width</code>, and adaptive smearing can be employed using the keyword <code>[kubo_]adpt_smr</code>.</p> <p>Please cite Ref.\u00a0<sup>12</sup> when publishing shift-current results using this method.</p>"},{"location":"user_guide/postw90/berry/#berry_taskkdotp-k-p-coefficients","title":"<code>berry_task=kdotp</code>: k \u22c5 p coefficients","text":"<p>Consider a Hamiltonian</p> \\[ \\begin{equation} \\label{eq:H} H=H^{0}+H^{\\prime} \\end{equation} \\] <p>where the eigenvalues \\(E_{n}\\) and eigenfunctions \\(\\vert n\\rangle\\) of \\(H^{0}\\) are known, and \\(H^{\\prime}\\) is a perturbation. In a nutshell, quasi-degenerate perturbation theory assumes that the set of eigenfunctions of \\(H^0\\) can be divided into subsets \\(A\\) and \\(B\\) that are weakly coupled by \\(H^{\\prime}\\), and that we are only interested in subset \\(A\\). This theory asserts that a transformed Hamiltonian \\(\\tilde{H}\\) exists within subspace \\(A\\) such that</p> \\[ \\begin{equation} \\label{eq:pert-exp} \\tilde{H}=\\tilde{H}^{0}+\\tilde{H}^{1}+\\tilde{H}^{2} + \\cdots \\end{equation} \\] <p>where \\(\\tilde{H}^{j}\\) contain matrix elements of \\(H^{\\prime}\\) to the \\(j\\)th power. According to Appendix B of Ref\u00a0<sup>13</sup>, the first three terms are</p> \\[ \\begin{equation} \\begin{aligned} \\label{eq:pert-matelem0} &amp; \\tilde{H}^{0}_{mm'} = H^{0}_{mm'},\\\\ \\label{eq:pert-matelem1} &amp; \\tilde{H}^{1}_{mm'} = H^{'}_{mm'},\\\\ \\label{eq:pert-matelem2} &amp; \\tilde{H}^{2}_{mm'} = \\dfrac{1}{2}\\sum_{l}H^{'}_{ml}H^{'}_{lm'} \\left( \\dfrac{1}{E_{m}-E_{l}}+\\dfrac{1}{E_{m'}-E_{l}} \\right), \\end{aligned} \\end{equation} \\] <p>where \\(m,m'\\in A\\) and \\(l\\in B\\). The approximation \\(\\tilde{H}\\sim \\tilde{H}^{0}+\\tilde{H}^{1}\\) amounts to truncating \\(H\\) to the \\(A\\) subspace. By further including \\(\\tilde{H}^{2}\\), the coupling to the \\(B\\) subspace is incorporated approximately, \"renormalizing\" the elements of the truncated matrix.</p> <p>We adopt the notation described in Sec. III.B of Ref.\u00a0<sup>3</sup>. We shift the origin of \\(k\\) space to the point where the band edge (or some other band extremum of interest) is located, and Taylor expand around that point the Wannier-gauge Hamiltonian,</p> \\[ \\begin{equation} \\label{eq:HW-exp} H^{(W)}(\\bm{k})=H^{(W)}(0) +\\sum_{a}H_{a}^{(W)}(0)k_{a} +\\dfrac{1}{2}\\sum_{ab}H_{ab}^{(W)}(0)k_{a}k_{b} + \\mathcal{O}(k^{3}) \\end{equation} \\] <p>where \\(a,b=x,y,z\\), and</p> \\[ \\begin{equation} \\begin{aligned} &amp;H_{a}^{(W)}(0)=\\left. \\dfrac{\\partial H^{(W)}(\\bm{k})}{\\partial k_{a}} \\right\\rvert_{\\bm{k}=0}\\\\ &amp;H_{ab}^{(W)}(0)=\\left. \\dfrac{\\partial^{2} H^{(W)}(\\bm{k})} {\\partial k_{a}\\partial k_{b}}\\right\\rvert_{\\bm{k}=0} \\end{aligned} \\end{equation} \\] <p>We now apply to \\(H^{(W)}(\\bm{k})\\) a similarity transformation \\(U(0)\\) that diagonalizes \\(H^{(W)}(0)\\), and call the transformed Hamiltonian \\(H(\\bm{k})\\),</p> \\[ \\begin{equation} \\label{eq:Hbar} H(\\bm{k})=\\overbrace{\\overline{H}}^{H^{0}} + \\overbrace{\\sum_{a}\\overline{H}_{a}k_{a} +\\dfrac{1}{2}\\sum_{ab}\\overline{H}_{ab}k_{a}k_{b}}^{H^{\\prime}} + \\mathcal{O}(k^{3}), \\end{equation} \\] <p>where we introduced the notation</p> \\[ \\begin{equation} \\overline{\\mathcal{O}}=U^{\\dagger}(0)\\mathcal{O}^{(W)}(0)U(0), \\end{equation} \\] <p>and applied it to \\(\\mathcal{O}=H,{H}_{a},{H}_{ab}\\). We can now apply quasi-degenerate perturbation theory by choosing the diagonal matrix \\(\\overline{H}\\) as our \\(H^{0}\\), and the remaining (nondiagonal) terms in Eq. \\(\\eqref{eq:Hbar}\\) as \\(H^{\\prime}\\). Collecting terms in Eq.\u00a0\\(\\eqref{eq:pert-exp}\\) up to second order in \\(k\\) we get</p> \\[ \\begin{equation} \\label{eq:Htilde}  \\tilde{H}_{mm'}(\\bm{k}) = \\overline{H}_{mm'} + \\sum_{a} \\left(\\overline{H}_{a}\\right)_{mm'}k_{a}  + \\dfrac{1}{2}\\sum_{a,b}\\left[ \\left(\\overline{H}_{ab}\\right)_{mm'} + \\left({T}_{ab}\\right)_{mm'} \\right]k_{a}k_{b}+ \\mathcal{O}(k^{3}), \\end{equation} \\] <p>where \\(m,m'\\in A\\) and we have defined the virtual-transition matrix</p> \\[ \\begin{equation} \\label{eq:Tab} \\left({T}_{ab}\\right)_{mm'}=\\sum_{l\\in B} \\left(\\overline{H}_{a}\\right)_{ml}\\left(\\overline{H}_{b}\\right)_{lm'}  \\times \\left( \\dfrac{1}{E_{m}-E_{l}}+\\dfrac{1}{E_{m'}-E_{l}} \\right) = \\left({T}_{ab}\\right)_{m'm}^{*}. \\end{equation} \\] <p>(The \\(T_{ab}\\) term in Eq. \\(\\eqref{eq:Htilde}\\) gives an Hermitean contribution to \\(\\tilde{H}(\\bm{k})\\) only after summing over \\(a\\) and \\(b\\), whereas the other terms are Hermitean already before summing.)</p> <p>The implementation in <code>wannier90</code> follows the scheme proposed in Ref.\u00a0<sup>14</sup>, and outputs \\(\\overline{H}_{mm'}\\) in <code>seedname-kdotp_0.dat</code>, \\(\\left(\\overline{H}_{a}\\right)_{mm'}\\) in <code>seedname-kdotp_1.dat</code>, and \\(\\left[\\left(\\overline{H}_{ab}\\right)_{mm'} + \\left({T}_{ab}\\right)_{mm'}\\right]/2\\) in <code>seedname-kdotp_2.dat</code>.</p> <p>Please cite Ref.\u00a0<sup>14</sup> when publishing \\(k\\cdot p\\) results using this method.</p>"},{"location":"user_guide/postw90/berry/#needed-matrix-elements","title":"Needed matrix elements","text":"<p>All the quantities entering the formulas for the optical conductivity and AHC can be calculated by Wannier interpolation once the Hamiltonian and position matrix elements \\(\\langle {\\bf 0}n\\vert H\\vert {\\bf R}m\\rangle\\) and \\(\\langle {\\bf 0}n\\vert {\\bf r}\\vert {\\bf   R}m\\rangle\\) are known\u00a0<sup>3</sup><sup>4</sup>. Those matrix elements are readily available at the end of a standard MLWF calculation with <code>wannier90</code>. In particular, \\(\\langle {\\bf   0}n\\vert {\\bf r}\\vert {\\bf R}m\\rangle\\) can be calculated by Fourier transforming the overlap matrices in Methodology Eq.\u00a0[overlap matrices],</p> \\[ \\begin{equation} \\langle u_{n{\\bf k}}\\vert u_{m{\\bf k}+{\\bf b}}\\rangle. \\end{equation} \\] <p>Further Wannier matrix elements are needed for the orbital magnetization\u00a0<sup>5</sup>. In order to calculate them using Fourier transforms, one more piece of information must be taken from the \\(k\\)-space ab-initio calculation, namely, the matrices</p> \\[ \\begin{equation} \\langle u_{n{\\bf k}+{\\bf b}_1}\\vert H_{\\bf k}\\vert u_{m{\\bf k}+{\\bf b}_2}\\rangle \\end{equation} \\] <p>over the ab-initio \\(k\\)-point mesh\u00a0<sup>5</sup>. These are evaluated by <code>pw2wannier90</code>, the interface routine between <code>pwscf</code> and <code>wannier90</code>, by adding to the input file <code>seedname.pw2wan</code> the line</p> Input file<pre><code>write_uHu = .true.\n</code></pre> <p>The calculation of spin Hall conductivity needs the spin matrix elements</p> \\[ \\begin{equation} \\langle u_{n{\\bf k}}\\vert \\sigma_\\gamma \\vert u_{m{\\bf k}}\\rangle, \\gamma = x, y, z \\end{equation} \\] <p>from the ab-initio \\(k\\)-point mesh. These are also evaluated by <code>pw2wannier90</code> by adding to the input file <code>seedname.pw2wan</code> the line</p> Input file<pre><code>write_spn = .true.\n</code></pre> <p>If one uses Ryoo's method to calculate spin Hall conductivity, the further matrix elements are needed:</p> \\[ \\begin{equation} \\langle u_{n{\\bf k}}\\vert \\sigma_\\gamma H_{\\bf k}\\vert u_{m{\\bf k}+{\\bf b}}\\rangle, \\langle u_{n{\\bf k}}\\vert \\sigma_\\gamma \\vert u_{m{\\bf k}+{\\bf b}}\\rangle, \\gamma = x, y, z \\end{equation} \\] <p>and these are evaluated by adding to the input file <code>seedname.pw2wan</code> the lines</p> Input file<pre><code>write_sHu = .true.\nwrite_sIu = .true.\n</code></pre> <ol> <li> <p>Di Xiao, Ming-Che Chang, and Qian Niu. Berry phase effects on electronic properties. Rev. Mod. Phys., 82:1959\u20132007, Jul 2010. doi:10.1103/RevModPhys.82.1959.\u00a0\u21a9\u21a9</p> </li> <li> <p>E. I. Blount. Solid State Physics, 13:305, 1962.\u00a0\u21a9</p> </li> <li> <p>X. Wang, J. R. Yates, I. Souza, and D. Vanderbilt. Ab initio calculation of the anomalous hall conductivity by wannier interpolation. Phys. Rev. B, 74:195118, 2006.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>J. R. Yates, X. Wang, D. Vanderbilt, and I. Souza. Spectral and fermi surface properties from wannier interpolation. Phys. Rev. B, 75:195121, 2007.\u00a0\u21a9\u21a9</p> </li> <li> <p>M. G. Lopez, D. Vanderbilt, T. Thonhauser, and I. Souza. Phys. Rev. B, 85:014435, 2012.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>D. Ceresoli, T. Thonhauser, D. Vanderbilt, and R. Resta. Orbital magnetization in crystalline solids: multi-band insulators, chern insulators, and metals. Phys. Rev. B, 74:024408, 2006.\u00a0\u21a9</p> </li> <li> <p>Junfeng Qiao, Jiaqi Zhou, Zhe Yuan, and Weisheng Zhao. Calculation of intrinsic spin hall conductivity by wannier interpolation. Phys. Rev. B, 98:214402, Dec 2018. URL: https://link.aps.org/doi/10.1103/PhysRevB.98.214402, doi:10.1103/PhysRevB.98.214402.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Ji Hoon Ryoo, Cheol-Hwan Park, and Ivo Souza. Computation of intrinsic spin hall conductivities from first principles using maximally localized wannier functions. Phys. Rev. B, 99:235113, Jun 2019. URL: https://link.aps.org/doi/10.1103/PhysRevB.99.235113, doi:10.1103/PhysRevB.99.235113.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>G. Y. Guo, S. Murakami, T.-W. Chen, and N. Nagaosa. Intrinsic spin hall effect in platinum: first-principles calculations. Phys. Rev. Lett., 100:096401, Mar 2008. URL: https://link.aps.org/doi/10.1103/PhysRevLett.100.096401, doi:10.1103/PhysRevLett.100.096401.\u00a0\u21a9</p> </li> <li> <p>M Gradhand, D V Fedorov, F Pientka, P Zahn, I Mertig, and B L Gy\u00f6rffy. First-principle calculations of the berry curvature of bloch states for charge and spin transport of electrons. Journal of Physics: Condensed Matter, 24(21):213202, may 2012. URL: https://doi.org/10.1088%2F0953-8984%2F24%2F21%2F213202, doi:10.1088/0953-8984/24/21/213202.\u00a0\u21a9</p> </li> <li> <p>J. E. Sipe and A. I. Shkrebtii. Second-order optical response in semiconductors. Phys. Rev. B, 61:5337, 2000. doi:10.1103/PhysRevB.61.5337.\u00a0\u21a9\u21a9</p> </li> <li> <p>Julen Iba\u00f1ez-Azpiroz, Stepan S. Tsirkin, and Ivo Souza. Ab initio calculation of the shift photocurrent by wannier interpolation. Phys. Rev. B, 97:245143, Jun 2018. URL: https://link.aps.org/doi/10.1103/PhysRevB.97.245143, doi:10.1103/PhysRevB.97.245143.\u00a0\u21a9\u21a9</p> </li> <li> <p>R. Winkler. Spin-orbit Coupling Effects in Two-Dimensional Electron and Hole Systems. Springer, 2003 edition edition, 2003. ISBN 978-3-540-01187-3.\u00a0\u21a9</p> </li> <li> <p>Julen Iba\u00f1ez-Azpiroz, Fernando de Juan, and Ivo Souza. Quantitative analysis of two-band \\(k\\cdot p\\) models describing the shift-current photoconductivity. ArXiv e-prints, 2019. URL: http://arxiv.org/abs/1910.06172, arXiv:1910.06172.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"user_guide/postw90/boltzwann/","title":"Electronic transport calculations with the <code>BoltzWann</code>\u00a0module","text":"<p>By setting <code>boltzwann=TRUE</code>, <code>postw90</code>\u00a0will call the <code>BoltzWann</code>\u00a0routines to calculate some transport coefficients using the Boltzmann transport equation in the relaxation time approximation.</p> <p>In particular, the transport coefficients that are calculated are: the electrical conductivity \\(\\mathrm{\\bm{\\sigma}}\\), the Seebeck coefficient \\(\\mathrm{\\bm{S}}\\) and the coefficient \\(\\mathrm{\\bm{K}}\\) (defined below; it is the main ingredient of the thermal conductivity).</p> <p>The list of parameters of the <code>BoltzWann</code>\u00a0module are summarized in Table\u00a0<code>BoltzWann</code> Parameters. A tutorial of a Boltzmann transport calculation can be found in the <code>wannier90</code>\u00a0Tutorial.</p> <p>Note</p> <p>By default, the code assumes to be working with a 3D bulk material, with periodicity along all three spatial directions. If you are interested in studying 2D systems, set the correct value for the <code>boltz_2d_dir</code> variable (see Sec.\u00a0boltz_2d_dir for the documentation). This is important for the evaluation of the Seebeck coefficient.</p> <p>Please cite the following paper\u00a0<sup>1</sup> when publishing results obtained using the <code>BoltzWann</code>\u00a0module:</p> <p>G. Pizzi, D. Volja, B. Kozinsky, M. Fornari, and N. Marzari, BoltzWann: A code for the evaluation of thermoelectric and electronic transport properties with a maximally-localized Wannier functions basis, Comp. Phys. Comm. 185, 422 (2014), DOI:10.1016/j.cpc.2013.09.015.</p>"},{"location":"user_guide/postw90/boltzwann/#theory","title":"Theory","text":"<p>The theory of the electronic transport using the Boltzmann transport equations can be found for instance in Refs.\u00a0<sup>2</sup><sup>3</sup><sup>4</sup>. Here we briefly summarize only the main results.</p> <p>The current density \\(\\mathrm{\\bm{J}}\\) and the heat current (or energy flux density) \\(\\mathrm{\\bm{J}}_Q\\) can be written, respectively, as</p> \\[ \\begin{equation} \\begin{aligned}   \\mathrm{\\bm{J}}   &amp;= \\mathrm{\\bm{\\sigma}}(\\mathrm{\\bm{E}} - \\mathrm{\\bm{S}}   \\mathrm{\\bm{\\nabla }}T) \\\\   \\mathrm{\\bm{J}}_Q &amp;= T \\mathrm{\\bm{\\sigma }}\\mathrm{\\bm{S}} \\mathrm{\\bm{E}} -   \\mathrm{\\bm{K}} \\mathrm{\\bm{\\nabla }}T, \\end{aligned} \\end{equation} \\] <p>where the electrical conductivity \\(\\mathrm{\\bm{\\sigma}}\\), the Seebeck coefficient \\(\\mathrm{\\bm{S}}\\) and \\(\\mathrm{\\bm{K}}\\) are \\(3\\times 3\\) tensors, in general.</p> <p>Note</p> <p>the thermal conductivity \\(\\mathrm{\\bm{\\kappa}}\\) (actually, the electronic part of the thermal conductivity), which is defined as the heat current per unit of temperature gradient in open-circuit experiments (i.e., with \\(\\mathrm{\\bm{J}}=0\\)) is not precisely \\(\\mathrm{\\bm{K}}\\), but \\(\\mathrm{\\bm{\\kappa }}= \\mathrm{\\bm{K}}-\\mathrm{\\bm{S}} \\mathrm{\\bm{\\sigma }}\\mathrm{\\bm{S}} T\\) (see for instance Eq.\u00a0(7.89) of Ref.\u00a0<sup>2</sup> or Eq.\u00a0(XI-57b) of Ref.\u00a0<sup>3</sup>). The thermal conductivity \\(\\mathrm{\\bm{\\kappa}}\\) can be then calculated from the \\(\\mathrm{\\bm{\\sigma}}\\), \\(\\mathrm{\\bm{S}}\\) and \\(\\mathrm{\\bm{K}}\\) tensors output by the code.</p> <p>These quantities depend on the value of the chemical potential \\(\\mu\\) and on the temperature \\(T\\), and can be calculated as follows:</p> \\[ \\begin{equation} \\label{eq:boltz-sigmas} \\begin{aligned}   \\mathrm{[\\bm{\\sigma}]}_{ij}(\\mu,T)&amp;=e^2 \\int_{-\\infty}^{+\\infty} d\\varepsilon   \\left(-\\frac {\\partial f(\\varepsilon,\\mu,T)}{\\partial \\varepsilon}\\right)   \\Sigma_{ij}(\\varepsilon), \\\\   [\\mathrm{\\bm{\\sigma }}\\mathrm{\\bm{S}}]_{ij}(\\mu,T)&amp;=\\frac e T   \\int_{-\\infty}^{+\\infty} d\\varepsilon \\left(-\\frac {\\partial   f(\\varepsilon,\\mu,T)}{\\partial \\varepsilon}\\right)(\\varepsilon-\\mu)   \\Sigma_{ij}(\\varepsilon),\\\\   [\\mathrm{\\bm{K}}]_{ij}(\\mu,T)&amp;=\\frac 1 T \\int_{-\\infty}^{+\\infty}   d\\varepsilon \\left(-\\frac {\\partial f(\\varepsilon,\\mu,T)}   {\\partial \\varepsilon}\\right)(\\varepsilon-\\mu)^2 \\Sigma_{ij}(\\varepsilon), \\end{aligned} \\end{equation} \\] <p>where \\([\\mathrm{\\bm{\\sigma }}\\mathrm{\\bm{S}}]\\) denotes the product of the two tensors \\(\\mathrm{\\bm{\\sigma}}\\) and \\(\\mathrm{\\bm{S}}\\), \\(f(\\varepsilon,\\mu,T)\\) is the usual Fermi--Dirac distribution function</p> \\[ \\begin{equation} f(\\varepsilon,\\mu,T) = \\frac{1}{e^{(\\varepsilon-\\mu)/K_B T}+1} \\end{equation} \\] <p>and \\(\\Sigma_{ij}(\\varepsilon)\\) is the Transport Distribution Function (TDF) tensor, defined as</p> \\[ \\begin{equation} \\Sigma_{ij}(\\varepsilon) = \\frac 1 V \\sum_{n,\\mathrm{\\bm{k}}} v_i(n,\\mathrm{\\bm{k}}) v_j(n,\\mathrm{\\bm{k}}) \\tau(n,\\mathrm{\\bm{k}}) \\delta(\\varepsilon - E_{n,k}). \\end{equation} \\] <p>In the above formula, the sum is over all bands \\(n\\) and all states \\(\\mathrm{\\bm{k}}\\) (including spin, even if the spin index is not explicitly written here). \\(E_{n,\\mathrm{\\bm{k}}}\\) is the energy of the \\(n-\\)th band at \\(\\mathrm{\\bm{k}}\\), \\(v_i(n,\\mathrm{\\bm{k}})\\) is the \\(i-\\)th component of the band velocity at \\((n,\\mathrm{\\bm{k}})\\), \\(\\delta\\) is the Dirac's delta function, \\(V = N_k \\Omega_c\\) is the total volume of the system (\\(N_k\\) and \\(\\Omega_c\\) being the number of \\(k\\)-points used to sample the Brillouin zone and the unit cell volume, respectively), and finally \\(\\tau\\) is the relaxation time. In the relaxation-time approximation adopted here, \\(\\tau\\) is assumed as a constant, i.e., it is independent of \\(n\\) and \\(\\mathrm{\\bm{k}}\\) and its value (in fs) is read from the input variable <code>boltz_relax_time</code>.</p>"},{"location":"user_guide/postw90/boltzwann/#files","title":"Files","text":""},{"location":"user_guide/postw90/boltzwann/#seedname_boltzdosdat","title":"<code>seedname_boltzdos.dat</code>","text":"<p>OUTPUT. Written by <code>postw90</code>\u00a0if <code>boltz_calc_also_dos</code> is <code>true</code>. Note that even if there are other general routines in <code>postw90</code>\u00a0which specifically calculate the DOS, it may be convenient to use the routines in <code>BoltzWann</code>\u00a0setting <code>boltz_calc_also_dos = true</code> if one must also calculate the transport coefficients. In this way, the (time-demanding) band interpolation on the \\(k\\) mesh is performed only once, resulting in a much shorter execution time.</p> <p>The first lines are comments (starting with # characters) which describe the content of the file. Then, there is a line for each energy \\(\\varepsilon\\) on the grid, containing a number of columns. The first column is the energy \\(\\varepsilon\\). The following is the DOS at the given energy \\(\\varepsilon\\). The DOS can either be calculated using the adaptive smearing scheme (see the following note) if <code>boltz_dos_adpt_smr</code> is <code>true</code>, or using a \"standard\" fixed smearing, whose type and value are defined by <code>boltz_dos_smr_type</code> and <code>boltz_dos_smr_fixed_en_width</code>, respectively. If spin decomposition is required (input flag <code>spin_decomp</code>), further columns are printed, with the spin-up projection of the DOS, followed by spin-down projection.</p> <p>Note</p> <p>Note that in <code>BoltzWann</code>\u00a0the adaptive (energy) smearing scheme also implements a simple adaptive \\(k-\\)mesh scheme: if at any given \\(k\\) point one of the band gradients is zero, then that \\(k\\) point is replaced by 8 neighboring \\(k\\) points. Thus, the final results for the DOS may be slightly different with respect to that given by the <code>dos</code> module.</p>"},{"location":"user_guide/postw90/boltzwann/#seedname_tdfdat","title":"<code>seedname_tdf.dat</code>","text":"<p>OUTPUT. This file contains the Transport Distribution Function (TDF) tensor \\(\\mathrm{\\bm{\\Sigma}}\\) on a grid of energies.</p> <p>The first lines are comments (starting with # characters) which describe the content of the file. Then, there is a line for each energy \\(\\varepsilon\\) on the grid, containing a number of columns. The first is the energy \\(\\varepsilon\\), the followings are the components if \\(\\mathrm{\\bm{\\Sigma}}(\\varepsilon)\\) in the following order: \\(\\Sigma_{xx}\\), \\(\\Sigma_{xy}\\), \\(\\Sigma_{yy}\\), \\(\\Sigma_{xz}\\), \\(\\Sigma_{yz}\\), \\(\\Sigma_{zz}\\). If spin decomposition is required (input flag <code>spin_decomp</code>), 12 further columns are provided, with the 6 components of \\(\\mathrm{\\bm{\\Sigma}}\\) for the spin up, followed by those for the spin down.</p> <p>The energy \\(\\varepsilon\\) is in eV, while \\(\\mathrm{\\bm{\\Sigma}}\\) is in \\(\\displaystyle\\frac{1}{\\hbar^2}\\cdot{\\mathrm{eV}\\cdot\\mathrm{fs}}\\cdot {\\mathring{\\mathrm{A}}^{-1}}\\).</p>"},{"location":"user_guide/postw90/boltzwann/#seedname_elconddat","title":"<code>seedname_elcond.dat</code>","text":"<p>OUTPUT. This file contains the electrical conductivity tensor \\(\\mathrm{\\bm{\\sigma}}\\) on the grid of \\(T\\) and \\(\\mu\\) points.</p> <p>The first lines are comments (starting with # characters) which describe the content of the file. Then, there is a line for each \\((\\mu,T)\\) pair, containing 8 columns, which are respectively: \\(\\mu\\), \\(T\\), \\(\\sigma_{xx}\\), \\(\\sigma_{xy}\\), \\(\\sigma_{yy}\\), \\(\\sigma_{xz}\\), \\(\\sigma_{yz}\\), \\(\\sigma_{zz}\\). (The tensor is symmetric).</p> <p>The chemical potential is in eV, the temperature is in K, and the components of the electrical conductivity tensor ar in SI units, i.e. in 1/\\(\\Omega\\)/m.</p>"},{"location":"user_guide/postw90/boltzwann/#seedname_sigmasdat","title":"<code>seedname_sigmas.dat</code>","text":"<p>OUTPUT. This file contains the tensor \\(\\mathrm{\\bm{\\sigma}}\\mathrm{\\bm{S}}\\), i.e. the product of the electrical conductivity tensor and of the Seebeck coefficient as defined by Eq.\u00a0\\(\\eqref{eq:boltz-sigmas}\\), on the grid of \\(T\\) and \\(\\mu\\) points.</p> <p>The first lines are comments (starting with # characters) which describe the content of the file. Then, there is a line for each \\((\\mu,T)\\) pair, containing 8 columns, which are respectively: \\(\\mu\\), \\(T\\), \\((\\sigma S)_{xx}\\), \\((\\sigma S)_{xy}\\), \\((\\sigma S)_{yy}\\), \\((\\sigma S)_{xz}\\), \\((\\sigma S)_{yz}\\), \\((\\sigma S)_{zz}\\). (The tensor is symmetric).</p> <p>The chemical potential is in eV, the temperature is in K, and the components of the tensor ar in SI units, i.e. in A/m/K.</p>"},{"location":"user_guide/postw90/boltzwann/#seedname_seebeckdat","title":"<code>seedname_seebeck.dat</code>","text":"<p>OUTPUT. This file contains the Seebeck tensor \\(\\mathrm{\\bm{S}}\\) on the grid of \\(T\\) and \\(\\mu\\) points.</p> <p>Note that in the code the Seebeck coefficient is defined as zero when the determinant of the electrical conductivity \\(\\mathrm{\\bm{\\sigma}}\\) is zero. If there is at least one \\((\\mu, T)\\) pair for which \\(\\det \\mathrm{\\bm{\\sigma}}=0\\), a warning is issued on the output file.</p> <p>The first lines are comments (starting with # characters) which describe the content of the file. Then, there is a line for each \\((\\mu,T)\\) pair, containing 11 columns, which are respectively: \\(\\mu\\), \\(T\\), \\(S_{xx}\\), \\(S_{xy}\\), \\(S_{xz}\\), \\(S_{yx}\\), \\(S_{yy}\\), \\(S_{yz}\\), \\(S_{zx}\\), \\(S_{zy}\\), \\(S_{zz}\\).</p> <p>NOTE: therefore, the format of the columns of this file is different from the other three files (elcond, sigmas and kappa)!</p> <p>The chemical potential is in eV, the temperature is in K, and the components of the Seebeck tensor ar in SI units, i.e. in V/K.</p>"},{"location":"user_guide/postw90/boltzwann/#seedname_kappadat","title":"<code>seedname_kappa.dat</code>","text":"<p>OUTPUT. This file contains the tensor \\(\\mathrm{\\bm{K}}\\) defined in Sec.\u00a0Theory on the grid of \\(T\\) and \\(\\mu\\) points.</p> <p>The first lines are comments (starting with # characters) which describe the content of the file. Then, there is a line for each \\((\\mu,T)\\) pair, containing 8 columns, which are respectively: \\(\\mu\\), \\(T\\), \\(K_{xx}\\), \\(K_{xy}\\), \\(K_{yy}\\), \\(K_{xz}\\), \\(K_{yz}\\), \\(K_{zz}\\). (The tensor is symmetric).</p> <p>The chemical potential is in eV, the temperature is in K, and the components of the \\(\\mathrm{\\bm{K}}\\) tensor are the SI units for the thermal conductivity, i.e. in W/m/K.</p> <ol> <li> <p>G. Pizzi, D. Volja, B. Kozinsky, M. Fornari, and N. Marzari. Boltzwann: a code for the evaluation of thermoelectric and electronic transport properties with a maximally-localized wannier functions basis. Comput. Phys. Commun., 185:422, 2014. doi:doi:10.1016/j.cpc.2013.09.015.\u00a0\u21a9</p> </li> <li> <p>J. Ziman. Principles of the Theory of Solids. Cambridge University Press, 2<sup>nd</sup> ed. edition, 1972.\u00a0\u21a9\u21a9</p> </li> <li> <p>G. Grosso and G. P. Parravicini. Solid State Physics. Academic Press, 2000.\u00a0\u21a9\u21a9</p> </li> <li> <p>G. D. Mahan. Transport properties. In Intern. Tables for Crystallography, volume D, chapter 1.8, pages 7828. 2006.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_guide/postw90/geninterp/","title":"Generic Band interpolation","text":"<p>By setting <code>geninterp=TRUE</code>, <code>postw90</code>\u00a0will calculate the band energies (and possibly the band derivatives, if also <code>geninterp_alsofirstder</code> is set to <code>TRUE</code>) on a generic list of \\(k\\) points provided by the user.</p> <p>The list of parameters of the Generic Band Interpolation module are summarized in Table\u00a0<code>geninterp</code> Parameters. The list of input \\(k\\) points for which the band have to be calculated is read from the file named <code>seedname_geninterp.kpt</code>. The format of this file is described below.</p>"},{"location":"user_guide/postw90/geninterp/#files","title":"Files","text":""},{"location":"user_guide/postw90/geninterp/#seedname_geninterpkpt","title":"<code>seedname_geninterp.kpt</code>","text":"<p>INPUT. Read by <code>postw90</code>\u00a0if <code>geninterp</code> is <code>true</code>.</p> <p>The first line is a comment (its maximum allowed length is 500 characters).</p> <p>The second line must contain <code>crystal</code> (or <code>frac</code>) if the \\(k\\)-point coordinates are given in crystallographic units, i.e., in fractional units with respect to the primitive reciprocal lattice vectors. Otherwise, it must contain <code>cart</code> (or <code>abs</code>) if instead the \\(k-\\)point coordinates are given in absolute coordinates (in units of 1/\u00c5) along the \\(k_x\\), \\(k_y\\) and \\(k_z\\) axes.</p> <p>Note</p> <p>Note on units: In the case of absolute coordinates, if \\(a_{lat}\\) is the lattice constant expressed in angstrom, and you want to represent for instance the point \\(X=\\frac {2\\pi}{a_{lat}} [0.5, 0, 0]\\), then you have to input for its \\(x\\) coordinate \\(k_x = 0.5 * 2 * \\pi / a_{lat}\\). As a practical example, if \\(a_{lat}=4\\)\u00c5, then \\(k_x = 0.78539816339745\\) in absolute coordinates in units of 1/\u00c5.</p> <p>The third line must contain the number \\(n\\) of following \\(k\\) points.</p> <p>The following \\(n\\) lines must contain the list of \\(k\\) points in the format</p> <pre><code>kpointidx k1 k2 k3\n</code></pre> <p>where <code>kpointidx</code> is an integer identifying the given \\(k\\) point, and <code>k1</code>, <code>k2</code> and <code>k3</code> are the three coordinates of the \\(k\\) points in the chosen units.</p>"},{"location":"user_guide/postw90/geninterp/#sec:seedname.geninterp.dat","title":"<code>seedname_geninterp.dat</code> or <code>seedname_geninterp_NNNNN.dat</code>","text":"<p>OUTPUT. This file/these files contain the interpolated band energies (and also the band velocities if the input flag <code>geninterp_alsofirstder</code> is <code>true</code>).</p> <p>If the flag <code>geninterp_single_file</code> is <code>true</code>, then a single file <code>seedname_geninterp.dat</code> is written by the code at the end of the calculation. If instead one sets <code>geninterp_single_file</code> to <code>false</code>, each process writes its own output file, named <code>seedname_geninterp_00000.dat</code>, <code>seedname_geninterp_00001.dat</code>, ...</p> <p>This flag is useful when one wants to parallelize the calculation on many nodes, and it should be used especially for systems with a small number of Wannier functions, when one wants to compute the bands on a large number of \\(k\\) points (if the flag <code>geninterp_single_file</code> is <code>true</code>, instead, all the I/O is made by the root node, which is a significant bottleneck).</p> <p>Note</p> <p>Important! The files are not deleted before the start of a calculation, but only the relevant files are overwritten. Therefore, if one first performs a calculation and then a second one with a smaller number of processors, care is needed to avoid to mix the results of the older calculations with those of the new one. In case of doubt, either check the date stamp in the first line of the <code>seedname_geninterp_*.dat</code> files, or simply delete the <code>seedname_geninterp_*.dat</code> files before starting the new calculation.</p> <p>To join the files, on can simply use the following command:</p> <pre><code>cat seedname_geninterp_*.dat &gt; seedname_geninterp.dat\n</code></pre> <p>or, if one wants to remove the comment lines:</p> <pre><code>rm seedname_geninterp.dat\nfor i in seedname_geninterp_*.dat ; do grep -v \\# \"$i\" &gt;&gt; \\\nseedname_geninterp.dat ; done\n</code></pre> <p>The first few lines of each files are comments (starting with #), containing a datestamp, the comment line as it is read from the input file, and a header. The following lines contain the band energies (and derivatives) for each band and \\(k\\) point (the energy index runs faster than the \\(k\\)-point index). For each of these lines, the first four columns contain the \\(k\\)-point index as provided in the input, and the \\(k\\) coordinates (always in absolute coordinates, in units of 1/\u00c5). The fifth column contains the band energy.</p> <p>If <code>geninterp_alsofirstder</code> is <code>true</code>, three further columns are printed, containing the three first derivatives of the bands along the \\(k_x\\), \\(k_y\\) and \\(k_z\\) directions (in units of eV\\(\\cdot\\)\u00c5).</p> <p>The \\(k\\) point coordinates are in units of 1/\u00c5, the band energy is in eV.</p>"},{"location":"user_guide/postw90/gyrotropic/","title":"Overview of the <code>gyrotropic</code> module","text":"<p>The <code>gyrotropic</code> module of <code>postw90</code> is called by setting <code>gyrotropic = true</code> and choosing one or more of the available options for <code>gyrotropic_task</code>. The module computes the quantities, studied in <sup>1</sup>, where more details may be found.</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-d0-the-berry-curvature-dipole","title":"<code>gyrotropic_task=-d0</code>: the Berry curvature dipole","text":"<p>The traceless dimensionless tensor</p> \\[ \\begin{equation} \\label{eq:D_ab} D_{ab}=\\int[d{\\bm k}]\\sum_n \\frac{\\partial E_n}{\\partial{k_a}} \\Omega_n^b \\left(-\\frac{\\partial f_0}{\\partial E}\\right)_{E=E_n}, \\end{equation} \\]"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-dw-the-finite-frequency-generalization-of-the-berry-curvature-dipole","title":"<code>gyrotropic_task=-dw</code>: the finite-frequency generalization of the Berry curvature dipole","text":"\\[ \\begin{equation} \\label{eq:D-tilde} \\widetilde{D}_{ab}(\\omega)=\\int[d{\\bm k}]\\sum_n \\frac{\\partial E_n}{\\partial{k_a}}\\widetilde\\Omega^b_n(\\omega) \\left(-\\frac{\\partial f_0}{\\partial E}\\right)_{E=E_n}, \\end{equation} \\] <p>where \\(\\widetilde{\\bm\\Omega}_{{\\bm k}n}(\\omega)\\) is a finite-frequency generalization of the Berry curvature:</p> \\[ \\begin{equation} \\label{eq:curv-w} \\widetilde{\\bm\\Omega}_{{\\bm k}n}(\\omega)=- \\sum_m\\,\\frac{\\omega^2_{{\\bm k}mn}}{\\omega^2_{{\\bm k}mn}-\\omega^2} {\\rm Im}\\left({\\bm A}_{{\\bm k}nm}\\times{\\bm A}_{{\\bm k}mn}\\right) \\end{equation} \\] <p>Contrary to the Berry curvature, the divergence of \\(\\tilde{\\bm\\Omega}_{{\\bm k}n}(\\omega)\\) is generally nonzero. As a result, \\(\\widetilde{D}(\\omega)\\) can have a nonzero trace at finite frequencies, \\(\\tilde{D}_\\|\\neq-2\\tilde{D}_\\perp\\) in Te.</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-c-the-ohmic-conductivity","title":"<code>gyrotropic_task=-C</code>: the ohmic conductivity","text":"<p>In the constant relaxation-time approximation the ohmic conductivity is expressed as \\(\\sigma_{ab}=(2\\pi e\\tau/\\hbar)C_{ab}\\), with</p> \\[ \\begin{equation} \\label{eq:C_ab} C_{ab}=\\frac{e}{h}\\int[d{\\bm k}]\\sum_n\\, \\frac{\\partial E_n}{\\partial{k_a}} \\frac{\\partial E_n}{\\partial{k_b}} \\left(-\\frac{\\partial f_0}{\\partial E}\\right)_{E=E_n} \\end{equation} \\] <p>a positive quantity with units of surface current density (A/cm).</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-k-the-kinetic-magnetoelectric-effect-kme","title":"<code>gyrotropic_task=-K</code>: the kinetic magnetoelectric effect (kME)","text":"<p>A microscopic theory of the intrinsic kME effect in bulk crystals was recently developed\u00a0<sup>2</sup><sup>3</sup>.</p> <p>The response is described by</p> \\[ \\begin{equation} \\label{eq:K_ab} K_{ab}=\\int[d{\\bm k}]\\sum_n\\frac{\\partial E_n}{\\partial{k_a}} m_n^b \\left(-\\frac{\\partial f_0}{\\partial E}\\right)_{E=E_n}, \\end{equation} \\] <p>which has the same form as Eq.\u00a0\\(\\eqref{eq:D_ab}\\), but with the Berry curvature replaced by the intrinsic magnetic moment \\({\\bm m}_{{\\bm k}n}\\) of the Bloch electrons, which has the spin and orbital components given by\u00a0<sup>4</sup></p> \\[ \\begin{equation} \\label{eq:m-spin} \\begin{aligned} m^{\\rm spin}_{{\\bm k}n}&amp;=-\\frac{1}{2}g_s\\mu_{\\rm B} \\langle\\psi_{{\\bm k}       n}\\vert\\bf \\sigma\\vert\\psi_{{\\bm k}n}\\rangle\\\\ % \\label{eq:m-orb} {\\bm m}^{\\rm orb}_{{\\bm k}n}&amp;=\\frac{e}{2\\hbar}{\\rm Im} \\langle{\\bm\\partial}_{\\bm k}u_{{\\bm k}n}\\vert\\times (H_{\\bm k}-E_{{\\bm k}n})\\vert{\\bm\\partial}_{\\bm k}u_{{\\bm k}n}\\rangle, \\end{aligned} \\end{equation} \\] <p>where \\(g_s\\approx 2\\) and we chose \\(e&gt;0\\).</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-dos-the-density-of-states","title":"<code>gyrotropic_task=-dos</code>: the density of states","text":"<p>The density of states is calculated with the same width and type of smearing, as the other properties of the <code>gyrotropic</code> module</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-noa-the-interband-contributionto-the-natural-optical-activity","title":"<code>gyrotropic_task=-noa</code>: the interband contributionto the natural optical activity","text":"<p>Natural optical rotatory power is given by <sup>5</sup></p> \\[ \\begin{equation} \\label{eq:rho-c} \\rho_0(\\omega)=\\frac{\\omega^2}{2c^2}{\\rm Re}\\,\\gamma_{xyz}(\\omega). \\end{equation} \\] <p>for light propagating ling the main symmetry axis of a crystal \\(z\\). Here \\(\\gamma_{xyz}(\\omega)\\) is an anti-symmetric (in \\(xy\\)) tensor with units of length, which has both inter- and intraband contributions.</p> <p>Following Ref.\u00a0<sup>6</sup> for the interband contribution we writewe write, with \\(\\partial_c\\equiv\\partial/\\partial k_c\\),</p> \\[ \\begin{equation} \\label{eq:gamma-inter} \\begin{gathered} {\\rm Re}\\,\\gamma_{abc}^{\\mathrm{inter}}(\\omega)=\\frac{e^2}{\\varepsilon_0\\hbar^2} \\int[d{\\bm k}] \\sum_{n,l}^{o,e}\\, \\Bigl[ \\frac{1}{\\omega_{ln}^2-\\omega^2} {\\rm Re}\\left(A_{ln}^bB_{nl}^{ac}-A_{ln}^aB_{nl}^{bc}\\right) \\\\ -\\frac{3\\omega_{ln}^2-\\omega^2}{(\\omega_{ln}^2-\\omega^2)^2} \\partial_c(E_l+E_n){\\rm Im}\\left(A_{nl}^aA_{ln}^b\\right) \\Bigr]. \\end{gathered} \\end{equation} \\] <p>The summations over \\(n\\) and \\(l\\) span the occupied (\\(o\\)) and empty (\\(e\\)) bands respectively, \\(\\omega_{ln}=(E_l-E_n)/\\hbar\\), and \\({\\bm A}_{ln}({\\bm k})\\) is given by Berry Eq. [Berry connection matrix].</p> <p>Finally, the matrix \\(B_{nl}^{ac}\\) has both orbital and spin contributions given by</p> \\[ \\begin{equation} \\label{eq:B-ac-orb} B_{nl}^{ac\\,({\\rm orb})}=   \\langle u_n\\vert(\\partial_aH)\\vert\\partial_c u_l\\rangle  -\\langle\\partial_c u_n\\vert(\\partial_aH)\\vert u_l\\rangle \\end{equation} \\] <p>and</p> \\[ \\begin{equation} \\label{eq:B-ac-spin} B_{nl}^{ac\\,({\\rm spin})}=-\\frac{i\\hbar^2}{m_e}\\epsilon_{abc} \\langle u_n\\vert\\sigma_b\\vert u_l\\rangle. \\end{equation} \\] <p>The spin matrix elements contribute less than 0.5% of the total \\(\\rho_0^{\\rm inter}\\) of Te. Expanding \\(H=\\sum_m \\vert u_m\\rangle E_m \\langle u_m\\vert\\) we obtain for the orbital matrix elements</p> \\[ \\begin{equation} \\label{eq:Bnl-sum} B_{nl}^{ac\\,({\\rm orb})}=-i\\partial_a(E_n+E_l)A_{nl}^c \\sum_m \\Bigl\\{ (E_n-E_m) A_{nm}^aA_{ml}^c -(E_l-E_m) A_{nm}^cA_{ml}^a \\Bigr\\}. \\end{equation} \\] <p>This reduces the calculation of \\(B^{\\text{(orb)}}\\) to the evaluation of band gradients and off-diagonal elements of the Berry connection matrix. Both operations can be carried out efficiently in a Wannier-function basis following Ref.\u00a0<sup>7</sup>.</p>"},{"location":"user_guide/postw90/gyrotropic/#gyrotropic_task-spin-compute-also-the-spin-component-of-noa-and-kme","title":"<code>gyrotropic_task=-spin</code>: compute also the spin component of NOA and KME","text":"<p>Unless this task is specified, only the orbital contributions are calcuated in NOA and KME, thus contributions from Eqs.\u00a0\\(\\eqref{eq:m-spin}\\) and\u00a0\\(\\eqref{eq:B-ac-spin}\\) are omitted.</p> <ol> <li> <p>S. S. Tsirkin, P. Aguado Puente, and I. Souza. Gyrotropic effects in trigonal tellurium studied from first principles. ArXiv e-prints, October 2017. arXiv:1710.03204.\u00a0\u21a9</p> </li> <li> <p>T. Yoda, T. Yokoyama, and S. Murakami. Current-induced orbital and spin magnetizations in crystals with helical structure. Sci. Rep., 5:12024, 2015. URL: http://dx.doi.org/10.1038/srep12024, doi:10.1038/srep12024.\u00a0\u21a9</p> </li> <li> <p>S. Zhong, J. E. Moore, and I. Souza. Gyrotropic magnetic effect and the magnetic moment on the fermi surface. Phys. Rev. Lett., 116:077201, Feb 2016. URL: https://link.aps.org/doi/10.1103/PhysRevLett.116.077201, doi:10.1103/PhysRevLett.116.077201.\u00a0\u21a9</p> </li> <li> <p>Di Xiao, Ming-Che Chang, and Qian Niu. Berry phase effects on electronic properties. Rev. Mod. Phys., 82:1959\u20132007, Jul 2010. doi:10.1103/RevModPhys.82.1959.\u00a0\u21a9</p> </li> <li> <p>E.L. Ivchenko and G.E. Pikus. Natural optical activity of semiconductors (tellurium). Sov. Phys. Solid State, 16(7):1261, 1975. URL: https://www.scopus.com/inward/record.uri?eid=2-s2.0-0016444392&amp;partnerID=40&amp;md5=d44204b27eb4356a166f389a0f8c8a4e.\u00a0\u21a9</p> </li> <li> <p>A. Malashevich and I. Souza. Band theory of spatial dispersion in magnetoelectrics. Phys. Rev. B, 82:245118, 2010. doi:10.1103/PhysRevB.82.245118.\u00a0\u21a9</p> </li> <li> <p>J. R. Yates, X. Wang, D. Vanderbilt, and I. Souza. Spectral and fermi surface properties from wannier interpolation. Phys. Rev. B, 75:195121, 2007.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_guide/postw90/postw90params/","title":"Parameters","text":""},{"location":"user_guide/postw90/postw90params/#introduction","title":"Introduction","text":"<p>The <code>wannier90.x</code> code described in Part\u00a0wannier90.x calculates the maximally-localized Wannier functions.</p> <p>The <code>postw90.x</code> executable contains instead a series of modules that take the Wannier functions calculated by <code>wannier90.x</code> and use them to calculate different properties. This executable is parallel (by means of MPI libraries), so it can be run on multiple CPUs. The information on the calculated Wannier functions is read from the checkpoint <code>seedname.chk</code> file. Note that this is written in an unformatted machine-dependent format. If you need to use this file on a different machine, or you want to use a version of <code>postw90.x</code> compiled with a different compiler, refer to Sec.\u00a0w90chk2chk  in the Appendices for a description of how to export/import this file.</p>"},{"location":"user_guide/postw90/postw90params/#usage","title":"Usage","text":"<p><code>postw90.x</code> can be run in parallel using MPI libraries to reduce the computation time.</p> <p>For serial execution use: <code>postw90.x [seedname]</code></p> <ul> <li><code>seedname</code>: If a seedname string is given the code will read its     input from a file <code>seedname.win</code>. The default value is <code>wannier</code>.     One can also equivalently provide the string <code>seedname.win</code> instead     of <code>seedname</code>.</li> </ul> <p>For parallel execution use: <code>mpirun -np NUMPROCS postw90.x [seedname]</code></p> <ul> <li><code>NUMPROCS</code>: substitute with the number of processors that you want     to use.</li> </ul> <p>Note that the <code>mpirun</code> command and command-line flags may be different in your MPI implementation: read your MPI manual or ask your computer administrator.</p> <p>Note also that this requires that the <code>postw90.x</code> executable has been compiled in its parallel version (follow the instructions in the file <code>README.install</code> in the main directory of the wannier90 distribution) and that the MPI libraries and binaries are installed and correctly configured on your machine.</p>"},{"location":"user_guide/postw90/postw90params/#seednamewin-file","title":"<code>seedname.win</code> File","text":"<p>The <code>postw90.x</code> uses the same <code>seedname.win</code> input file of <code>wannier90.x</code>. The input keywords of <code>postw90.x</code> must thus be added to this file, using the same syntax described in Sec.\u00a0wannier90.x.</p> <p>Note that <code>wannier90.x</code> checks if the syntax of the input file is correct, but then ignores the value of the flags that refer only to modules of <code>postw90.x</code>, so one can safely run <code>wannier90.x</code> on a file that contains also <code>postw90.x</code> flags.</p> <p>Similarly, <code>postw90.x</code> ignores flags that refer only to <code>wannier90.x</code> (as number of iterations, restart flags, ...). However, some parts of the input file must be there, as for instance the number of Wannier functions, etc.</p> <p>The easiest thing to do is therefore to simply add the <code>postw90</code> input keywords to the <code>seedname.win</code> file that was used to obtain the Wannier functions.</p>"},{"location":"user_guide/postw90/postw90params/#list-of-available-modules","title":"List of available modules","text":"<p>The currently available modules in <code>postw90.x</code> are:</p> <ul> <li> <p><code>dos</code>: Calculation of the density of states (DOS), projected density     of states (PDOS), net spin etc.</p> </li> <li> <p><code>kpath</code>: Calculation of \\(k\\)-space quantities such as energy bands,     Berry curvature and Berry curvature-like term of spin Hall     conductivity along a piecewise linear path in the BZ (see tutorials     17,     18     and 29 of the tutorial).</p> </li> <li> <p><code>kslice</code>: Calculation of \\(k\\)-space quantities on a planar slice of     the BZ (see tutorials 17,     18     and 29 of the tutorial).</p> </li> <li> <p><code>berry</code>: Calculation of properties related to the BZ integral of the     Berry curvature, Berry connection and Berry curvature-like term of     spin Hall conductivity, including anomalous Hall conductivity,     orbital magnetisation, optical conductivity, nonlinear shift current     and spin Hall conductivity (see     Chap.\u00a0Berry and tutorials     18,     19,     25,     29     and 30 of the     tutorial). It also includes an option to compute \\(k\\cdot p\\)     expansion coefficients (see     Sec.\u00a0kdotp and tutorial     33 of the tutorial).</p> </li> <li> <p><code>gyrotropic</code>: Calculation of gyrotropic properties, including     natural and current0induced optical rotation, and the     current-induced magnetization (see     Chap.\u00a0Gyrotropic and tutorial     24 of the tutorial).</p> </li> <li> <p><code>BoltzWann</code>: Calculation of electronic transport properties for bulk     materials using the semiclassical Boltzmann transport equation (see     Chap.\u00a0BoltzWann and tutorial     16 of the tutorial).</p> </li> <li> <p><code>geninterp</code> (Generic Band Interpolation): Calculation band energies     (and band derivatives) on a generic list of \\(k\\) points (see     Chap.\u00a0Geninterp).</p> </li> </ul>"},{"location":"user_guide/postw90/postw90params/#keyword-list","title":"Keyword List","text":"<p>On the next pages the list of available \u00a0input keywords is reported. In particular, Table\u00a0Global Parameters of <code>postw90</code> reports keywords that affect the generic behavior of all modules of . Often, these are \"global\" variables that can be overridden by module-specific keywords (as for instance the <code>kmesh</code> flag). The subsequent tables describe the input parameters for each specific module. A description of the behaviour of the global flags is described Sec.\u00a0Global variables; the description of the flags specific to the modules can be found in the following sections.</p>"},{"location":"user_guide/postw90/postw90params/#global-parameters-of-postw90","title":"Global Parameters of <code>postw90</code>","text":"Keyword Type Description kmesh I Dimensions of the uniform interpolation \\(k\\)-mesh (one or three integers) kmesh_spacing R Minimum spacing between \\(k\\) points in \u00c5\\(^{-1}\\) adpt_smr L Use adaptive smearing adpt_smr_fac R Adaptive smearing prefactor adpt_smr_max P Maximum allowed value for the adaptive energy smearing (eV) smr_type S Analytical form used for the broadened delta function smr_fixed_en_width P Energy smearing (if non-adaptive) num_elec_per_state I Number of electrons per state scissors_shift P Scissors shift applied to the conduction bands (eV) (deprecated) num_valence_bands I Number of valence bands spin_decomp L Decompose various properties into up-spin, down-spin, and possibly spin-flip parts spin_axis_polar P Polar angle of the spin quantization axis (deg) spin_axis_azimuth P Azimuthal angle of the spin quantization axis (deg) spin_moment\\(^*\\) L Determines whether to evaluate the spin magnetic moment per cell uHu_formatted L Read a formatted <code>seedname.uHu</code> file spn_formatted L Read a formatted <code>seedname.spn</code> file berry_curv_unit S Unit of Berry curvature <p><code>seedname.win</code> file keywords controlling the general behaviour of   the modules in <code>postw90</code>. Argument types are represented by, I for a integer, R   for a real number, P for a physical value, L for a logical value and S   for a text string.  * The keyword <code>spin_moment</code> does not affect the behavior of the modules   in , and does not really belong to any of them. It is listed here for   lack of a better place.</p>"},{"location":"user_guide/postw90/postw90params/#berry-parameters","title":"<code>berry</code> Parameters","text":"Keyword Type Description berry L Calculate Berry-type quantities berry_task S List of properties to compute [berry_]kmesh I Dimensions of the uniform interpolation \\(k\\)-mesh (one or three integers) [berry_]kmesh_spacing R Minimum spacing between \\(k\\) points in \u00c5\\(^{-1}\\) berry_curv_adpt_kmesh I Linear dimension of the adaptively refined \\(k\\)-mesh used to compute the anomalous/spin Hall conductivity berry_curv_adpt_kmesh_thresh P Threshold magnitude of the Berry curvature for adaptive refinement kubo_freq_min P Lower limit of the frequency range for optical spectra, JDOS, shift current and spin Hall conductivity (eV) kubo_freq_max P Upper limit of the frequency range for optical spectra, JDOS, shift current and spin Hall conductivity (eV) kubo_freq_step R Step for increasing the optical frequency in the specified range kubo_eigval_max P Maximum energy eigenvalue included when evaluating the Kubo-Greenwood conductivity, JDOS, shift current and spin Hall conductivity [kubo_]adpt_smr L Use adaptive energy smearing for the optical conductivity, JDOS, shift current and spin Hall conductivity [kubo_]adpt_smr_fac R Adaptive smearing prefactor [kubo_]adpt_smr_max P Maximum allowed value for the adaptive energy smearing (eV) [kubo_]smr_type S Analytical form used for the broadened delta function when computing the optical conductivity, JDOS, shift current and spin Hall conductivity [kubo_]smr_fixed_en_width P Energy smearing (if non-adaptive) for the optical conductivity, JDOS, shift current and spin Hall conductivity (eV) sc_eta R Energy broadening of energy differences in the sum over virtual states when computing shift current sc_phase_conv I Convention for phase factor of Bloch states when computing shift current sc_w_thr R Frequency threshold for speeding up delta function integration when computing shift current sc_use_eta_corr L Use finite-eta correction for computing shift current shc_freq_scan L Calculate Fermi energy scan or frequency scan of spin Hall conductivity shc_method S How to obtain the spin current matrix elements for SHC shc_alpha I The spin current direction of spin Hall conductivity shc_beta I The direction of applied electrical field of spin Hall conductivity shc_gamma I The spin direction of the spin current of spin Hall conductivity shc_bandshift L Rigid bandshift of the conduction bands shc_bandshift_firstband I Index of the first band to shift shc_bandshift_energyshift P Energy shift of the conduction bands (eV) kdotp_kpoint R \\(k\\) point for \\(k\\cdot p\\) expansion (\\(2\\pi/a\\), with \\(a\\) lattice constant in \u00c5) kdotp_num_bands I Number of bands for \\(k\\cdot p\\) expansion kdotp_bands I Band indexes corresponding to the \\(k\\cdot p\\) bands <p><code>seedname.win</code> file keywords controlling the <code>berry</code> module.   Argument types are represented by, I for a integer, R for a real   number, P for a physical value, L for a logical value and S for a text   string.</p>"},{"location":"user_guide/postw90/postw90params/#dos-parameters","title":"<code>dos</code> Parameters","text":"Keyword Type Description dos L Calculate the density of states and related properties dos_task S List of properties to compute dos_energy_min P Lower limit of the energy range for computing the DOS (eV) dos_energy_max P Upper limit of the energy range for computing the DOS (eV) dos_energy_step R Step for increasing the energy in the specified range (eV) dos_project I List of WFs onto which the DOS is projected [dos_]kmesh I Dimensions of the uniform interpolation \\(k\\)-mesh (one or three integers) [dos_]kmesh_spacing R Minimum spacing between \\(k\\) points in \u00c5\\(^{-1}\\) [dos_]adpt_smr L Use adaptive smearing for the DOS [dos_]adpt_smr_fac R Adaptive smearing prefactor [dos_]adpt_smr_max P Maximum allowed value for the adaptive energy smearing (eV) [dos_]smr_fixed_en_width P Energy smearing (if non-adaptive) for the DOS (eV) [dos_]smr_type S Analytical form used for the broadened delta function when computing the DOS. <p><code>seedname.win</code> file keywords controlling the <code>dos</code> module. Argument types are represented by, I for a integer, R for a real number, P for a physical value, L for a logical value and S for a text string.</p>"},{"location":"user_guide/postw90/postw90params/#kpath-parameters","title":"<code>kpath</code> Parameters","text":"Keyword Type Description kpath L Calculate properties along a piecewise linear path in the BZ kpath_task L List of properties to evaluate kpath_num_points I Number of points in the first kpath segment kpath_bands_colour S Property used to colour the energy bands along the path <p><code>seedname.win</code> file keywords controlling the <code>kpath</code> module.   Argument types are represented by, I for a integer, R for a real   number, P for a physical value, L for a logical value and S for a text   string.</p>"},{"location":"user_guide/postw90/postw90params/#kslice-parameters","title":"<code>kslice</code> Parameters","text":"Keyword Type Description kslice L Calculate properties on a slice in the BZ kslice_task S List of properties to evaluate kslice_corner R Position of the corner of the slice kslice_b1 R First vector defining the slice kslice_b2 R Second vector defining the slice kslice_2dkmesh I Dimensions of the uniform interpolation \\(k\\)-mesh on the slice (one or two integers) kslice_fermi_level P This parameter is not used anymore. Use fermi_energy instead. kslice_fermi_lines_colour S Property used to colour the Fermi lines <p><code>seedname.win</code> file keywords controlling the <code>kslice</code> module. Argument types are represented by, I for a integer, R for a real number, P for a physical value, L for a logical value and S for a text string.</p>"},{"location":"user_guide/postw90/postw90params/#gyrotropic-parameters","title":"<code>gyrotropic</code> Parameters","text":"Keyword Type Description gyrotropic L Calculate gyrotropic quantities gyrotropic_task L List of properties to compute [gyrotropic_]kmesh I Dimensions of the uniform interpolation \\(k\\)-mesh (one or three integers) [gyrotropic_]kmesh_spacing R Minimum spacing between \\(k\\) points in \u00c5\\(^{-1}\\) gyrotropic_freq_min P Lower limit of the frequency range for optical rotation (eV) gyrotropic_freq_max P Upper limit of the frequency range for optical rotation (eV) gyrotropic_freq_step P Step for increasing the optical frequency in the specified range gyrotropic_eigval_max P Maximum energy eigenvalue included when evaluating the interband natural optical activity gyrotropic_degen_thresh P threshold to exclude degenerate bands from the calculation [gyrotropic_]smr_type S Analytical form used for the broadened delta function [gyrotropic_]smr_fixed_en_width P Energy smearing (eV) [gyrotropic_]band_list I list of bands used in the calculation gyrotropic_box_centergyrotropic_box_b1gyrotropic_box_b2gyrotropic_box_b3 RRRR The center and three basis vectors, defining the box for integration (in reduced coordinates, three real numbers for each vector) <p><code>seedname.win</code> file keywords controlling the <code>gyrotropic</code> module.   Argument types are represented by, I for a integer, R for a real   number, P for a physical value, L for a logical value and S for a text   string.</p>"},{"location":"user_guide/postw90/postw90params/#boltzwann-parameters","title":"<code>BoltzWann</code> Parameters","text":"Keyword Type Description boltzwann L Calculate Boltzmann transport coefficients [boltz_]kmesh I Dimensions of the uniform interpolation \\(k\\)-mesh (one or three integers) [boltz_]kmesh_spacing R Minimum spacing between \\(k\\) points in \u00c5\\(^{-1}\\) boltz_2d_dir S Non-periodic direction (for 2D systems only) boltz_relax_time P Relaxation time in fs boltz_mu_min P Minimum value of the chemical potential \\(\\mu\\) in eV boltz_mu_max P Maximum value of the chemical potential \\(\\mu\\) in eV boltz_mu_step R Step for \\(\\mu\\) in eV boltz_temp_min P Minimum value of the temperature\u00a0\\(T\\) in Kelvin boltz_temp_max P Maximum value of the temperature\u00a0\\(T\\) in Kelvin boltz_temp_step R Step for \\(T\\) in Kelvin boltz_tdf_energy_step R Energy step for the TDF (eV) boltz_tdf_smr_fixed_en_width P Energy smearing for the TDF (eV) boltz_tdf_smr_type S Smearing type for the TDF boltz_calc_also_dos L Calculate also DOS while calculating the TDF boltz_dos_energy_min P Minimum value of the energy for the DOS in eV boltz_dos_energy_max P Maximum value of the energy for the DOS in eV boltz_dos_energy_step R Step for the DOS in eV [boltz_]smr_type S Smearing type for the DOS [boltz_]adpt_smr L Use adaptive smearing for the DOS [boltz_]adpt_smr_fac R Adaptive smearing prefactor [boltz_]adpt_smr_max P Maximum allowed value for the adaptive energy smearing (eV) [boltz_]fixed_en_width P Energy smearing (if non-adaptive) for the DOS (eV) boltz_bandshift L Rigid bandshift of the conduction bands boltz_bandshift_firstband I Index of the first band to shift boltz_bandshift_energyshift P Energy shift of the conduction bands (eV) <p><code>seedname.win</code> file keywords controlling the <code>BoltzWann</code>\u00a0module (calculation of   the Boltzmann transport coefficients in the Wannier basis). Argument   types are represented by, I for a integer, R for a real number, P for   a physical value, L for a logical value and S for a text string.</p>"},{"location":"user_guide/postw90/postw90params/#geninterp-parameters","title":"<code>geninterp</code> Parameters","text":"Keyword Type Description geninterp L Calculate bands for given set of \\(k\\) points geninterp_alsofirstder L Calculate also first derivatives geninterp_single_file L Write a single file or one for each process <p><code>seedname.win</code> file keywords controlling the Generic Band Interpolation (<code>geninterp</code>) module. Argument types are represented by,   I for a integer, R for a real number, P for a physical value, L for a logical value and S for a text string.</p>"},{"location":"user_guide/postw90/postw90params/#global-variables","title":"Global variables","text":""},{"location":"user_guide/postw90/postw90params/#integer-kmesh","title":"<code>integer :: kmesh(:)</code>","text":"<p>Dimensions of the interpolation grid used in <code>postw90.x</code>.</p> <p>Not to be confused with the <code>mp_grid</code> input flag, which instead specifies the Monkhorst--Pack grid used in the ab-initio calculation!</p> <p>If three integers \\(l\\) \\(m\\) \\(n\\) are given, the reciprocal-space cell subtended by the three primitive translations is sampled on a uniform \\(l\\times m\\times n\\) grid (including \\(\\Gamma\\)). If only one integer \\(m\\) is given, an \\(m\\times m\\times m\\) grid is used.</p> <p>If you use a module which needs a k-mesh, either <code>kmesh_spacing</code> or <code>kmesh</code> must be defined.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-kmesh_spacing","title":"<code>real(kind=dp) :: kmesh_spacing</code>","text":"<p>An alternative way of specifying the interpolation grid. This flag defines the minimum distance for neighboring \\(k\\) points along each of the three directions in \\(k\\) space.</p> <p>The units are \u00c5\\(^{-1}\\).</p> <p>If you use a module which needs a k-mesh, either <code>kmesh_spacing</code> or <code>kmesh</code> must be defined.</p>"},{"location":"user_guide/postw90/postw90params/#logical-adpt_smr","title":"<code>logical :: adpt_smr</code>","text":"<p>Determines whether to use an adaptive scheme for broadening the DOS and similar quantities defined on the energy axis. If <code>true</code>, the values for the smearing widths are controlled by the flag <code>adpt_smr_fac</code>.</p> <p>The default value is <code>true</code>.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-adpt_smr_fac","title":"<code>real(kind=dp) :: adpt_smr_fac</code>","text":"<p>The width \\(\\eta_{n{\\bf k}}\\) of the broadened delta function used to determine the contribution to the spectral property (DOS, ...) from band \\(n\\) at point \\({\\bf k}\\) is calculated as \\(\\eta_{n{\\bf k}}=\\alpha\\vert \\nabla_{\\bf k} \\varepsilon_{n{\\bf k}}\\vert \\Delta k,\\) where \\(\\varepsilon_{n{\\bf k}}\\) is the energy eigenvalue and the dimensionless factor \\(\\alpha\\) is given by <code>adpt_smr_fac</code>. \\(\\Delta k\\) is taken to be the largest of the mesh spacings along the three reciprocal lattice vectors \\({\\bf b_1}\\), \\({\\bf   b_2}\\), and \\({\\bf b_3}\\). If the calculated value of \\(\\eta_{n{\\bf     k}}\\) exceeds <code>adpt_smr_max</code>, the latter value is used.</p> <p>The default value is \\(\\sqrt{2}\\).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-adpt_smr_max","title":"<code>real(kind=dp) :: adpt_smr_max</code>","text":"<p>See description given immediately above.</p> <p>The units are eV. The default value is 1.0.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-smr_type","title":"<code>character(len=120) :: smr_type</code>","text":"<p>Defines the analytical form used for the broadened delta function in the computation of the DOS and similar quantities defined on the energy axis.</p> <ul> <li> <p><code>gauss</code>: Gaussian smearing</p> </li> <li> <p><code>m-pN</code>: derivative of the \\(N\\)-th order Methfessel-Paxton function     (\\(N\\geq 0\\)). Example: <code>m-p2</code> for the second-order Methfessel-Paxton     function. If only <code>m-p</code> is provided, the first-order function is     used, i.e., it is equivalent to <code>m-p1</code>.</p> </li> <li> <p><code>m-v</code> or <code>cold</code>: derivative of the Marzari--Vanderbilt cold-smearing     function</p> </li> <li> <p><code>f-d</code>: derivative of the Fermi-Dirac distribution function</p> </li> </ul> <p>The default value is <code>gauss</code>.</p>"},{"location":"user_guide/postw90/postw90params/#logical-smr_fixed_en_width","title":"<code>logical :: smr_fixed_en_width</code>","text":"<p>Energy width for the smearing function for the DOS. Used only if <code>adpt_smr</code> is <code>false</code>.</p> <p>The units are eV. The default value is 0\u00a0eV. Note that if the width is smaller than twice the energy step (e.g. <code>dos_energy_step</code> for the <code>dos</code> module), the DOS will be unsmeared (thus the default is to have an unsmeared properties when <code>adpt_smr</code> is set to <code>false</code>.).</p>"},{"location":"user_guide/postw90/postw90params/#integer-num_elec_per_state","title":"<code>integer :: num_elec_per_state</code>","text":"<p>Number of electrons per state. It can only take the values one or two.</p> <p>The default value is 1 if <code>spinors=true</code>, 2 otherwise.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-scissors_shift","title":"<code>real(kind=dp) :: scissors_shift</code>","text":"<p>Scissors shift applied to the conduction bands.</p> <p>Note</p> <p>This variable is deprecated and will be removed in future versions of the code. This applies the scissors shift only to the Hamiltonian, but also other matrices might need to be updated if a scissors shift is applied. If you are using BoltzWann, consider using <code>boltz_bandshift</code> instead. If you are calculating spin Hall conductivity, consider using <code>shc_bandshift</code> instead.</p> <p>The units are eV. The default value is 0\u00a0eV (i.e., no scissors shift applied).</p>"},{"location":"user_guide/postw90/postw90params/#integer-num_valence_bands","title":"<code>integer :: num_valence_bands</code>","text":"<p>Number of valence bands of the system. Used in different modules and for the scissors shift.</p> <p>No default value.</p>"},{"location":"user_guide/postw90/postw90params/#logical-spin_decomp","title":"<code>logical :: spin_decomp</code>","text":"<p>If <code>true</code>, extra columns are added to some output files (such as <code>seedname-dos.dat</code> for the <code>dos</code> module, and analogously for the <code>berry</code> and <code>BoltzWann</code> modules).</p> <p>For the <code>dos</code> and <code>BoltzWann</code> modules, two further columns are generated, which contain the decomposition of the required property (e.g., total or orbital-projected DOS) of a spinor calculation into up-spin and down-spin parts (relative to the quantization axis defined by the input variables <code>spin_axis_polar</code> and <code>spin_axis_azimuth</code>). For the <code>berry</code> module with <code>berry_task = kubo</code>, three extra columns are added to <code>seedname-jdos.dat</code>, containing the decomposition of the JDOS into up \\(\\rightarrow\\) up, down \\(\\rightarrow\\) down, and spin-flip transitions. In the same way, six extra columns are added to the data files <code>seedname-kubo*.dat</code> where the complex optical conductivity is stored.</p> <p>The file <code>seedname.spn</code> must be present at input. Furthermore, if this variable is set to <code>true</code> it requires <code>num_elec_per_state = 1</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-spin_axis_polar","title":"<code>real(kind=dp) :: spin_axis_polar</code>","text":"<p>Polar angle of the spin quantization axis.</p> <p>The units are degrees. The default value is 0.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-spin_axis_azimuth","title":"<code>real(kind=dp) :: spin_axis_azimuth</code>","text":"<p>Azimuthal angle of the spin quantization axis.</p> <p>The units are degrees. The default value is 0.</p>"},{"location":"user_guide/postw90/postw90params/#logical-spin_moment","title":"<code>logical :: spin_moment</code>","text":"<p>Determines whether to evaluate the spin moment.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#logical-uhu_formatted","title":"<code>logical :: uHu_formatted</code>","text":"<p>If <code>uHu_formatted</code>=<code>true</code>, then the uHu matrix elements will be read from disk as formatted (ie ASCII) files; otherwise they will be read as unformatted files.</p> <p>The default value of this parameter is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#logical-spn_formatted","title":"<code>logical :: spn_formatted</code>","text":"<p>If <code>spn_formatted</code>=<code>true</code>, then the spin matrix elements will be read from disk as formatted (ie ASCII) files; otherwise they will be read as unformatted files. Unformatted is generally preferable as the files will take less disk space and I/O is significantly faster. However such files will not be transferable between all machine architectures and formatted files should be used if transferability is required (i.e., for test cases).</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen20-berry_curv_unit","title":"<code>character(len=20) :: berry_curv_unit</code>","text":"<p>Unit in which the Berry curvature is specified at input (in <code>berry_curv_adpt_kmesh_thresh</code>) or written to file (when <code>kpath_task=curv</code> or <code>kpath_task=shc</code> or <code>kslice_task=curv</code> or <code>kslice_task=shc</code>).</p> <ul> <li> <p><code>ang2</code>: Angstrom\\(^2\\)</p> </li> <li> <p><code>bohr2</code>: Bohr\\(^2\\) (atomic units)</p> </li> </ul> <p>The default value is <code>ang2</code>.</p>"},{"location":"user_guide/postw90/postw90params/#logical-sc_use_eta_corr","title":"<code>logical :: sc_use_eta_corr</code>","text":"<p>If <code>sc_use_eta_corr=true</code>, apply the finite-eta correction of the shift current (Eq. (19) of Ref. <sup>1</sup>). Without the correction, the convention of the Bloch sum (determined by <code>sc_phase_conv</code>) can affect the computed shift-current spectra. See Ref. <sup>1</sup> for details.</p> <p>The default value is <code>true</code>.</p>"},{"location":"user_guide/postw90/postw90params/#dos","title":"DOS","text":"<p>Note that the behavior of the <code>dos</code> module is also influenced by the value of some global flags (listed in Table\u00a0Global Parameters of postw90), as <code>spin_decomp</code>, <code>spin_axis_polar</code>, <code>spin_axis_azimuth</code>, <code>scissors_shift</code>, etc. Some of the global flags can be possibly overridden by local flags of the DOS module, listed below, which have the same name of the global flag but are prefixed by <code>dos_</code>.</p>"},{"location":"user_guide/postw90/postw90params/#logical-dos","title":"<code>logical :: dos</code>","text":"<p>Determines whether to enter the DOS routines.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen20-dos_task","title":"<code>character(len=20) :: dos_task</code>","text":"<p>The quantity to compute when <code>dos=true</code></p> <p>The valid options for this parameter are:</p> <ul> <li><code>dos_plot</code> Density of states. An output data file <code>seedname-dos.dat</code>     is created, containing the energy values in eV in the first column,     and the total DOS per unit cell and unit energy range (in eV\\(^{-1}\\))     in the second. Two additional columns are present if     <code>spin_decomp=true</code></li> </ul> <p>The default value is <code>dos_plot</code>.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-dos_energy_min","title":"<code>real(kind=dp) :: dos_energy_min</code>","text":"<p>Lower limit of the energy range for computing the DOS. Units are eV.</p> <p>The default value is the minimum value of the energy eigenvalues stored in <code>seedname.eig</code>, minus 0.6667.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-dos_energy_max","title":"<code>real(kind=dp) :: dos_energy_max</code>","text":"<p>Upper limit of the energy range for computing the DOS. Units are eV.</p> <p>If an inner energy window was specified, the default value is the upper bound of the innter energy window, plus 0.6667. Otherwise it is the maximum value of the energy eigenvalues stored in <code>seedname.eig</code>, plus 0.6667.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-dos_energy_step","title":"<code>real(kind=dp) :: dos_energy_step</code>","text":"<p>Energy step for the grid of energies used to plot the dos. Units are eV.</p> <p>The default value is 0.01\u00a0eV.</p>"},{"location":"user_guide/postw90/postw90params/#integer-dos_project","title":"<code>integer :: dos_project(:)</code>","text":"<p>If present <code>postw90</code> computes, instead of the total DOS, the partial DOS projected onto the WFs listed. The WFs are numbered according to the file <code>seedname.wout</code>.</p> <p>For example, to project onto WFs 2, 6, 7, 8, and 12:</p> <p><code>dos_project : 2, 6-8, 12</code></p> <p>The DOS projected onto a set \\({\\cal S}\\) of orbitals is calculated as</p> \\[ \\begin{equation} \\begin{aligned} \\rho_{\\cal S}(E)&amp;=\\frac{1}{N_k}\\sum_{\\bf k}\\sum_n \\langle \\psi_{n\\bf k}^{({\\rm H})}\\vert \\hat{P}_{\\bf k}({\\cal S})\\vert \\psi_{n\\bf k}^{({\\rm H})}\\rangle\\delta(\\varepsilon_{n\\bf k}-E)\\\\ \\hat{P}_{\\bf k}({\\cal S})&amp;=\\sum_{m\\in{\\cal S}} \\vert \\psi_{n\\bf k}^{({\\rm W})}\\rangle\\langle \\psi_{n\\bf k}^{({\\rm W})}\\vert, \\end{aligned} \\end{equation} \\] <p>where \\(N_k\\) is the number of mesh points used to sample the BZ, and the superscript (H) and (W) refer to Hamiltonian gauge and Wannier gauge <sup>2</sup>.</p>"},{"location":"user_guide/postw90/postw90params/#integer-dos_kmesh","title":"<code>integer :: dos_kmesh(:)</code>","text":"<p>Overrides the <code>kmesh</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-dos_kmesh_spacing","title":"<code>real(kind=dp) :: dos_kmesh_spacing</code>","text":"<p>Overrides the <code>kmesh_spacing</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#logical-dos_adpt_smr","title":"<code>logical :: dos_adpt_smr</code>","text":"<p>Overrides the <code>adpt_smr</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-dos_adpt_smr_fac","title":"<code>real(kind=dp) :: dos_adpt_smr_fac</code>","text":"<p>Overrides the <code>adpt_smr_fac</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-dos_adpt_smr_max","title":"<code>real(kind=dp) :: dos_adpt_smr_max</code>","text":"<p>Overrides the <code>adpt_smr_max</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#logical-dos_smr_fixed_en_width","title":"<code>logical :: dos_smr_fixed_en_width</code>","text":"<p>Overrides the <code>smr_fixed_en_width</code> global variable (see Sec.\u00a0Global variables).</p> <p>Note that if the width is smaller than twice the energy step <code>dos_energy_step</code>, the DOS will be unsmeared (thus the default is to have an unsmeared DOS).</p>"},{"location":"user_guide/postw90/postw90params/#characterlen20-dos_smr_type","title":"<code>character(len=20) :: dos_smr_type</code>","text":"<p>Overrides the <code>smr_type</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#kpath","title":"kpath","text":""},{"location":"user_guide/postw90/postw90params/#logical-kpath","title":"<code>logical :: kpath</code>","text":"<p>Determines whether to enter the kpath routines.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen20-kpath_task","title":"<code>character(len=20) :: kpath_task</code>","text":"<p>The quantities to plot when <code>kpath=true</code></p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>bands</code> Energy bands, in eV. The following files are created:</p> <ul> <li> <p><code>seedname-bands.dat</code> (data file)</p> </li> <li> <p><code>seedname-bands.gnu</code> (<code>gnuplot</code> script)</p> </li> <li> <p><code>seedname-bands.py</code> (<code>python</code> script)</p> </li> <li> <p><code>seedname-path.kpt</code> (list of \\(k\\)-points along the path, written         in the <code>pwscf</code> format)</p> </li> </ul> </li> <li> <p><code>curv</code> Minus the Berry curvature given by     Berry Eq. [anomalous Hall Conductivity] of     Ch.\u00a0Berry, in units of <code>berry_curv_unit</code>. The following     files are created:</p> <ul> <li> <p><code>seedname-curv.dat</code> (data file)</p> </li> <li> <p><code>seedname-curv_{x,y,z}.gnu</code> (<code>gnuplot</code> scripts)</p> </li> <li> <p><code>seedname-curv_{x,y,z}.py</code> (<code>python</code> scripts)</p> </li> </ul> </li> <li> <p><code>morb</code> The integrand of the \\(k\\)-space orbital magnetization formula     [Berry Eq. [orbital magnetization] of     Ch.\u00a0Berry] in eV\\(\\cdot\\)\u00c5\\(^2\\). Four output files are     created:</p> <ul> <li> <p><code>seedname-morb.dat</code> (data file)</p> </li> <li> <p><code>seedname-morb_{x,y,z}.gnu</code> (<code>gnuplot</code> scripts)</p> </li> <li> <p><code>seedname-morb_{x,y,z}.py</code> (<code>python</code> scripts)</p> </li> </ul> </li> <li> <p><code>shc</code> The band-projected Berry curvature-like term of spin Hall     conductivity given by     Berry Eq. [spin Hall conductivity] of     Ch.\u00a0Berry, in units of <code>berry_curv_unit</code>. The following     files are created:</p> <ul> <li> <p><code>seedname-shc.dat</code> (data file)</p> </li> <li> <p><code>seedname-shc.gnu</code> (<code>gnuplot</code> scripts)</p> </li> <li> <p><code>seedname-shc.py</code> (<code>python</code> scripts)</p> </li> </ul> </li> <li> <p>Any combination of the above. The following combinations are of     special interest</p> <ul> <li> <p><code>kpath_task = bands+curv</code></p> </li> <li> <p><code>kpath_task = bands+morb</code></p> </li> <li> <p><code>kpath_task = bands+shc</code></p> </li> </ul> <p>They generate the following files:</p> <ul> <li> <p><code>seedname-bands.dat</code> (data file)</p> </li> <li> <p><code>seedname-{curv,morb,shc}.dat</code> (data file)</p> </li> <li> <p><code>seedname-bands+{curv,morb}_{x,y,z}.py</code> or         <code>seedname-bands+shc.py</code> (<code>python</code> scripts)</p> </li> </ul> <p>Two-panel figures are produced, with the energy bands within \\(\\pm 0.65\\)\u00a0eV of the Fermi level in the top panel, and the Berry curvature (or \\(k\\)-space orbital magnetization, or \\(k\\)-resolved Berry curvature-like term of spin Hall conductivity) in the bottom panel.</p> </li> </ul> <p>The default value is <code>bands</code>.</p>"},{"location":"user_guide/postw90/postw90params/#integer-kpath_num_points","title":"<code>integer :: kpath_num_points</code>","text":"<p>If <code>kpath</code>=<code>true</code>, then the number of points along the first section of the bandstructure plot given by <code>kpoint_path</code>. Other sections will have the same density of \\(k\\)-points.</p> <p>The default value is 100.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen20-kpath_bands_colour","title":"<code>character(len=20) :: kpath_bands_colour</code>","text":"<p>When <code>kpath_task=bands</code>, colour code the energy bands according to the specified quantity.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>spin</code> Spin projection (in units of \\(\\hbar/2\\)) along the     quantization axis defined by the variables <code>spin_axis_polar</code> and     <code>spin_axis_azimuth</code>, for a spinor calculation</p> </li> <li> <p><code>shc</code> Band-projected Berry curvature-like term of spin Hall     conductivity (in units of     <code>berry_curv_unit</code>) defined by the variables <code>shc_alpha</code>, <code>shc_beta</code>     and <code>shc_gamma</code>, for a spinor calculation</p> </li> <li> <p><code>none</code> no colour coding</p> </li> </ul> <p>The default value is <code>none</code>.</p>"},{"location":"user_guide/postw90/postw90params/#kslice","title":"kslice","text":""},{"location":"user_guide/postw90/postw90params/#logical-kslice","title":"<code>logical :: kslice</code>","text":"<p>Determines whether to enter the kslice routines.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen20-kslice_task","title":"<code>character(len=20) :: kslice_task</code>","text":"<p>The quantity to plot when <code>kslice=true</code></p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>fermi_lines</code> Lines of intersection between constant-energy surfaces     and the slice. The energy level is specified by the keyword     <code>fermi_energy</code>. Output files:</p> <ul> <li> <p><code>seedname-kslice-fermi-spn.dat</code> (data file when         <code>kslice_fermi_lines_colour = spin</code>)</p> </li> <li> <p><code>seedname-bnd_n.dat</code> (<code>gnuplot</code> data files when         <code>kslice_fermi_lines_colour = none</code>)</p> </li> <li> <p><code>seedname-kslice-coord.dat</code> (<code>python</code> data files when         <code>kslice_fermi_lines_colour = none</code>)</p> </li> <li> <p><code>seedname-kslice-bands.dat</code> (<code>python</code> data file when         <code>kslice_fermi_lines_colour = none</code>)</p> </li> <li> <p><code>seedname-kslice-fermi_lines.gnu</code> (<code>gnuplot</code> script)</p> </li> <li> <p><code>seedname-kslice-fermi_lines.py</code> (<code>python</code> script)</p> </li> </ul> </li> <li> <p><code>curv</code>[+<code>fermi_lines</code>] Heatmap of the Berry curvature of the     occupied states [together with the constant-energy contours]. The     unit of Berry curvature is <code>berry_curv_unit</code>.</p> <p>Output files:</p> <ul> <li> <p><code>seedname-kslice-coord.dat</code> (data files)</p> </li> <li> <p><code>seedname-kslice-curv.dat</code> (data file)</p> </li> <li> <p><code>[seedname-kslice-bands.dat]</code> (data file)</p> </li> <li> <p><code>seedname-kslice-curv_{x,y,z}[+fermi_lines].py</code> (<code>python</code>         scripts)</p> </li> </ul> </li> <li> <p><code>morb</code>[+<code>fermi_lines</code>] Heatmap of the \\(k\\)-space orbital     magnetization in eV\\(\\cdot\\)\u00c5\\(^2\\) [together with the constant-energy     contours]. Output files:</p> <ul> <li> <p><code>seedname-kslice-coord.dat</code> (data files)</p> </li> <li> <p><code>seedname-kslice-morb.dat</code> (data file)</p> </li> <li> <p><code>[seedname-kslice-bands.dat]</code> (data file)</p> </li> <li> <p><code>seedname-kslice-morb_{x,y,z}[+fermi_lines].py</code> (<code>python</code>         scripts)</p> </li> </ul> </li> <li> <p><code>shc</code>[+<code>fermi_lines</code>] Heatmap of the Berry curvature-like term of     the occupied states [together with the constant-energy contours].     The unit of Berry curvature-like term is <code>berry_curv_unit</code>.</p> <p>Output files:</p> <ul> <li> <p><code>seedname-kslice-coord.dat</code> (data files)</p> </li> <li> <p><code>seedname-kslice-shc.dat</code> (data file)</p> </li> <li> <p><code>[seedname-kslice-bands.dat]</code> (data file)</p> </li> <li> <p><code>seedname-kslice-shc[+fermi_lines].py</code> (<code>python</code> scripts)</p> </li> </ul> </li> </ul> <p>The default value is <code>fermi_lines</code>.</p> <p>Note</p> <p>When <code>kslice_fermi_lines_colour = none</code> the <code>gnuplot</code> scripts draw the \\(k\\)-slices with a square shape, even when <code>kslice_b1</code> and <code>kslice_b2</code> below are not at right angles, or do not have equal lengths. (The <code>python</code> scripts draw the slices with the correct parallelogram shape.)</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-kslice_corner3","title":"<code>real(kind=dp) :: kslice_corner(3)</code>","text":"<p>Reduced coordinates of the lower-left corner of the slice in k-space.</p> <p>The default value is \\((0.0,0.0,0.0)\\)</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-kslice_b13","title":"<code>real(kind=dp) :: kslice_b1(3)</code>","text":"<p>Reduced coordinates of the first reciprocal-space vector defining the slice.</p> <p>The default value is \\((1.0,0.0,0.0)\\).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-kslice_b23","title":"<code>real(kind=dp) :: kslice_b2(3)</code>","text":"<p>Reduced coordinates of the second reciprocal-space vector defining the slice.</p> <p>The default value is \\((0.0,1.0,0.0)\\).</p>"},{"location":"user_guide/postw90/postw90params/#integer-kslice_2dkmesh2","title":"<code>integer :: kslice_2dkmesh(2)</code>","text":"<p>Dimensions of the \\(k\\)-point grid covering the slice. If two integers \\(m\\) \\(n\\) are given, the slice is sampled on a uniform \\(m\\times n\\) grid. If only one integer \\(m\\) is given, an \\(m\\times m\\) grid is used.</p> <p>The default value for <code>kslice_kmesh</code> is 50.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen20-kslice_fermi_lines_colour","title":"<code>character(len=20) :: kslice_fermi_lines_colour</code>","text":"<p>When <code>kslice_task=fermi_lines</code> (but not when combined with <code>curv</code> or <code>morb</code>), colour code the Fermi lines according to the specified quantity.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>spin</code> Spin projection (in units of \\(\\hbar/2\\)) along the     quantization axis defined by the variables <code>spin_axis_polar</code> and     <code>spin_axis_azimuth</code>, for a spinor calculation</p> </li> <li> <p><code>none</code> no colour coding</p> </li> </ul> <p>The default value is <code>none</code>.</p>"},{"location":"user_guide/postw90/postw90params/#berry","title":"berry","text":""},{"location":"user_guide/postw90/postw90params/#logical-berry","title":"<code>logical :: berry</code>","text":"<p>Determines whether to enter the berry routines.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-berry_task","title":"<code>character(len=120) :: berry_task</code>","text":"<p>The quantity to compute when <code>berry=true</code></p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>kubo</code> Complex optical conductivity and joint density of states.</p> <p>Output files:</p> <ul> <li> <p><code>seedname-kubo-S_{xx,yy,zz,xy,xz,yz}.dat</code> (data files). First     column: optical frequency \\(\\hbar\\omega\\) in eV. Second and third     columns: real and imaginary parts of the symmetric conductivity     \\(\\sigma^{\\rm         S}_{\\alpha\\beta}(\\hbar\\omega)=\\sigma^{\\rm         S}_{\\beta\\alpha}(\\hbar\\omega)\\) in S/cm. Six additional     columns are present if <code>spin_decomp = true</code>.</p> </li> <li> <p><code>seedname-kubo-A_{yz,zx,xy}.dat</code> (data files). First column:     optical frequency \\(\\hbar\\omega\\) in eV. Second and third columns:     real and imaginary parts of the antisymmetric conductivity     \\(\\sigma^{\\rm A}_{\\alpha\\beta}(\\hbar\\omega)=-\\sigma^{\\rm         A}_{\\beta\\alpha}(\\hbar\\omega)\\) in S/cm. Six additional     columns are present if <code>spin_decomp = true</code>.</p> </li> <li> <p><code>seedname-jdos.dat</code> (data file). First column: energy difference     \\(\\hbar\\omega\\) in eV between conduction (\\(c\\)) and valence (\\(v\\))     states with the same crystal momentum \\({\\bf         k}\\). Second column: joint density of states     \\(\\rho_{cv}(\\hbar\\omega)\\) (number of states per unit cell per     unit energy range, in eV\\(^{-1}\\)). Three additional columns are     present if <code>spin_decomp = true</code>.</p> </li> </ul> </li> <li> <p><code>ahc</code> Anomalous Hall conductivity, in S/cm. The three independent     components \\(\\sigma_x=\\sigma_{yz}\\), \\(\\sigma_y=\\sigma_{zx}\\), and     \\(\\sigma_z=\\sigma_{xy}\\) are computed.</p> <p>Output files:</p> <ul> <li><code>seedname-ahc-fermiscan.dat</code> (data file). The first column     contains the Fermi level \\(\\varepsilon_F\\) in eV, and the     following three column the values of     \\(\\sigma_{x,y,z}(\\varepsilon_F)\\). This file is written if a range     of Fermi energies is specified via <code>fermi_energy_min</code> and     <code>fermi_energy_max</code>. If a single Fermi energy is given, the AHC     is printed in <code>seedname.wpout</code> only.</li> </ul> </li> <li> <p><code>morb</code> Orbital magnetisation, in bohr magnetons per cell.</p> <p>Output files:</p> <ul> <li><code>seedname-morb-fermiscan.dat</code> (data file). The first column     contains the Fermi level \\(\\varepsilon_F\\) in eV, and the     following three column the values of \\(M^{\\rm         orb}_{x,y,z}(\\varepsilon_F)\\). This file is written if a     range of Fermi energies is specified via <code>fermi_energy_min</code> and     <code>fermi_energy_max</code>. If a single Fermi energy is given, \\({\\bf         M}^{\\rm orb}\\) is printed in <code>seedname.wpout</code> only.</li> </ul> </li> <li> <p><code>sc</code> Nonlinear shift current.</p> <p>Output files:</p> <ul> <li><code>seedname-sc_{xxx,xxy,xxz,...}.dat</code> (data files). The shift     current is described by a \\(3\\times3\\times3\\) tensor     \\(\\sigma^{abc}\\). The program outputs a set of 18 files, and the 9     remaining components can be obtained by taking into account that     \\(\\sigma^{abc}\\) is symmetric under \\(b\\leftrightarrow c\\) index     exchange. First column: optical frequency \\(\\hbar\\omega\\) in eV.     Second column: nonlinear shift current     \\(\\sigma^{abc}(\\hbar\\omega)\\) in A/V\\(^{2}\\).</li> </ul> </li> <li> <p><code>shc</code> Spin Hall conductivity (SHC), in \\((\\hbar/e)\\)S/cm.</p> <p>Output files:</p> <ul> <li> <p><code>seedname-shc-fermiscan.dat</code> (data file). The first column is     the number of entries in the list, the second column contains     the Fermi level \\(\\varepsilon_F\\) in eV, and the last column     contains the values of     \\(\\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}(\\varepsilon_F)\\). This     file is written if a range of Fermi energies is specified via     <code>fermi_energy_min</code> and <code>fermi_energy_max</code>. If a single Fermi     energy is given, the file will contain SHC at this specific     energy.</p> </li> <li> <p><code>seedname-shc-freqscan.dat</code> (data file). The first column is the     number of the entry in the list, the second column contains the     frequency \\(\\hbar\\omega\\) in eV, and the following two columns     contain the values of the real part     \\(\\Re[\\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}(\\omega)]\\) and     imaginary part     \\(\\Im[\\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}(\\omega)]\\) of ac     SHC. This file is written if a range of frequencies is specified     via <code>kubo_freq_min</code> and <code>kubo_freq_max</code>.</p> </li> </ul> </li> <li> <p><code>kdotp</code> \\(k\\cdot p\\) expansion coefficients.</p> <p>Output files:</p> <ul> <li><code>seedname-kdotp_{0,1,2}.dat</code> (data files); respectively, the     zeroth, first and second order \\(k\\cdot p\\) expansion     coefficients, in units of eV, eV\\(\\cdot\\)\u00c5, and eV\\(\\cdot\\)\u00c5\\(^{2}\\).</li> </ul> </li> </ul> <p>There is no default value.</p>"},{"location":"user_guide/postw90/postw90params/#integer-berry_kmesh","title":"<code>integer :: berry_kmesh(:)</code>","text":"<p>Overrides the <code>kmesh</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-berry_kmesh_spacing","title":"<code>real(kind=dp) :: berry_kmesh_spacing</code>","text":"<p>Overrides the <code>kmesh_spacing</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#integer-berry_curv_adpt_kmesh","title":"<code>integer :: berry_curv_adpt_kmesh</code>","text":"<p>If a positive integer \\(n\\) is given and <code>berry_task=ahc</code>[or <code>berry_task=shc</code>], an \\(n\\times n\\times n\\) mesh is placed around points on the uniform mesh (defined by either <code>berry_kmesh</code> or <code>berry_kmesh_spacing</code>) where the magnitude of the \\(k\\)-space Berry curvature[\\(k\\)-space Berry curvature-like term of SHC] exceeds the threshold value specified in <code>berry_curv_adpt_kmesh_thresh</code>. This can be used to densify the BZ integration mesh around spikes in the Berry curvature[Berry curvature-like term of SHC].</p> <p>The default value is 1.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-berry_curv_adpt_kmesh_thresh","title":"<code>real(kind=dp) :: berry_curv_adpt_kmesh_thresh</code>","text":"<p>Magnitude of the Berry curvature[Berry curvature-like term of SHC] (in units of <code>berry_curv_unit</code>) that triggers adaptive mesh refinement when <code>berry_task=ahc</code>[<code>berry_task=shc</code>].</p> <p>The default value is 100.0.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-kubo_freq_min","title":"<code>real(kind=dp) :: kubo_freq_min</code>","text":"<p>Lower limit of the frequency range for computing the optical conductivity, JDOS and ac SHC. Units are eV.</p> <p>The default value 0.0.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-kubo_freq_max","title":"<code>real(kind=dp) :: kubo_freq_max</code>","text":"<p>Upper limit of the frequency range for computing the optical conductivity, JDOS and ac SHC. Units are eV.</p> <p>If an inner energy window was specified, the default value is <code>dis_froz_max</code>-<code>fermi_energy</code>+0.6667. Otherwise it is the difference between the maximum and the minimum energy eigenvalue stored in <code>seedname.eig</code>, plus 0.6667.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-kubo_freq_step","title":"<code>real(kind=dp) :: kubo_freq_step</code>","text":"<p>Difference between consecutive values of the optical frequency between <code>kubo_freq_min</code> and <code>kubo_freq_max</code>. Units are eV.</p> <p>The default value is 0.01.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-kubo_eigval_max","title":"<code>real(kind=dp) :: kubo_eigval_max</code>","text":"<p>Maximum energy eigenvalue of the eigenstates to be included in the evaluation of the optical conductivity, JDOS and ac SHC. Units are eV.</p> <p>If an inner energy window was specified, the default value is the upper bound of the inner energy window plus 0.6667. Otherwise it is the maximum energy eigenvalue stored in <code>seedname.eig</code> plus 0.6667.</p>"},{"location":"user_guide/postw90/postw90params/#logical-kubo_adpt_smr","title":"<code>logical :: kubo_adpt_smr</code>","text":"<p>Overrides the <code>adpt_smr</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-kubo_adpt_smr_fac","title":"<code>real(kind=dp) :: kubo_adpt_smr_fac</code>","text":"<p>Overrides the <code>adpt_smr_fac</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-kubo_adpt_smr_max","title":"<code>real(kind=dp) :: kubo_adpt_smr_max</code>","text":"<p>Overrides the <code>adpt_smr_max</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#logical-kubo_smr_fixed_en_width","title":"<code>logical :: kubo_smr_fixed_en_width</code>","text":"<p>Overrides the <code>smr_fixed_en_width</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-kubo_smr_type","title":"<code>character(len=120) :: kubo_smr_type</code>","text":"<p>Overrides the <code>smr_type</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#logical-shc_freq_scan","title":"<code>logical :: shc_freq_scan</code>","text":"<p>Determines whether to calculate the frequency scan (i.e. the ac SHC) or the Fermi energy scan (i.e. the dc SHC) of the spin Hall conductivity.</p> <p>The default value is <code>false</code>, which means dc SHC is calculated.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-shc_method","title":"<code>character(len=120) :: shc_method</code>","text":"<p>If it is <code>qiao/ryoo</code>, the ac or dc SHC is calculated using Junfeng Qiao's/Jihoon Ryoo's method. To calculate the Kubo formula, the spin current matrix elements are required, and the two methods differ in the degree of approximation. For details, see the section shc.</p>"},{"location":"user_guide/postw90/postw90params/#integer-shc_alpha","title":"<code>integer :: shc_alpha</code>","text":"<p>The \\(\\alpha\\) index of spin Hall conductivity \\(\\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}\\), i.e. the direction of spin current. Possible values are <code>1</code>, <code>2</code> and <code>3</code>, representing the <code>x</code>, <code>y</code> and <code>z</code> directions respectively.</p> <p>The default value is <code>1</code>.</p>"},{"location":"user_guide/postw90/postw90params/#integer-shc_beta","title":"<code>integer :: shc_beta</code>","text":"<p>The \\(\\beta\\) index of spin Hall conductivity \\(\\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}\\), i.e. the direction of applied electric field. Possible values are <code>1</code>, <code>2</code> and <code>3</code>, representing the <code>x</code>, <code>y</code> and <code>z</code> directions respectively.</p> <p>The default value is <code>2</code>.</p>"},{"location":"user_guide/postw90/postw90params/#integer-shc_gamma","title":"<code>integer :: shc_gamma</code>","text":"<p>The \\(\\gamma\\) index of spin Hall conductivity \\(\\sigma_{\\alpha\\beta}^{\\text{spin}\\gamma}\\), i.e. the spin direction of spin current. Possible values are <code>1</code>, <code>2</code> and <code>3</code>, representing the <code>x</code>, <code>y</code> and <code>z</code> directions respectively.</p> <p>The default value is <code>3</code>.</p> <p>If all the <code>shc_alpha</code>, <code>shc_beta</code> and <code>shc_gamma</code> are set as default values, the \\(\\sigma_{xy}^{\\text{spin}z}\\) is computed.</p>"},{"location":"user_guide/postw90/postw90params/#logical-shc_bandshift","title":"<code>logical :: shc_bandshift</code>","text":"<p>Shift all conduction bands by a given amount (defined by <code>shc_bandshift_energyshift</code>).</p> <p>Note</p> <p>this flag slightly differs from the global <code>scissors_shift</code> flag: with <code>shc_bandshift</code>, an exact rigid shift is applied after interpolation; <code>scissors_shift</code> applies instead the shift before interpolation. As a consequence, results may slightly differ (and this is why we provide both possibilities). Note also that with <code>scissors_shift</code> you have to provide the number of valence bands <code>num_valence_bands</code>, while with <code>shc_bandshift</code> you should provide the first band to shift <code>shc_bandshift_firstband</code> = <code>num_valence_bands</code>\\(+1\\).</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#integer-shc_bandshift_firstband","title":"<code>integer :: shc_bandshift_firstband</code>","text":"<p>Index of the first conduction band to shift.</p> <p>That means that all bands with index \\(i\\ge {\\tt shc\\_bandshift\\_firstband}\\) will be shifted by <code>shc_bandshift_energyshift</code>, if <code>shc_bandshift</code> is <code>true</code>.</p> <p>The units are eV. No default value; if <code>shc_bandshift</code> is <code>true</code>, this flag must be provided.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-shc_bandshift_energyshift","title":"<code>real(kind=dp) :: shc_bandshift_energyshift</code>","text":"<p>Energy shift of the conduction bands.</p> <p>The units are eV. No default value; if <code>shc_bandshift</code> is <code>true</code>, this flag must be provided.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-sc_eta","title":"<code>real(kind=dp) :: sc_eta</code>","text":"<p>The width \\(\\eta\\) used to broaden energy differences in denominators of the form</p> \\[ \\begin{equation} \\frac{1}{\\varepsilon_{n\\bf{k}}-\\varepsilon_{m\\bf{k}}}\\rightarrow \\text{Re}\\frac{1}{\\varepsilon_{n\\bf{k}}-\\varepsilon_{m\\bf{k}}+i\\eta}. \\end{equation} \\] <p>The above is needed in shift-current calculations in order to avoid numerical problems caused by near-degeneracies in the sum over virtual states.</p> <p>The units are eV. The default value is 0.4.</p>"},{"location":"user_guide/postw90/postw90params/#integer-sc_phase_conv","title":"<code>integer :: sc_phase_conv</code>","text":"<p>Convention for the expansion of the Bloch states in shift-current calculations. It can only take the values one or two. We follow the convention of Ref.\u00a0<sup>3</sup>:</p> <ul> <li> <p>1: Include Wannier centre     \\({\\bm \\tau}_{n}=\\langle w_{n{\\bf 0}}|{\\bf r}| w_{n{\\bf 0}} \\rangle\\)     in the phase factor (so-called tight-binding convention):</p> \\[ \\begin{equation} |u_{n\\bf{k}}\\rangle = \\sum_{\\bf{R}} e^{-i{\\bf k}({\\bf r}-{\\bf R}     -{\\bm \\tau}_{n})}| w_{n\\bf{R}} \\rangle \\end{equation} \\] </li> <li> <p>2: Do not include Wannier centre in the phase factor (usual     <code>Wannier90</code> convention):</p> \\[ \\begin{equation} |u_{n\\bf{k}}\\rangle = \\sum_{\\bf{R}} e^{-i\\bf{k}(\\bf{r}-\\bf{R})}|     w_{n\\bf{R}} \\rangle \\end{equation} \\] </li> </ul> <p>If <code>sc_use_eta_corr=true</code>, the convention does not affect the full shift-current matrix element, but it does affect the weights of the internal components that compose it (see Ref. <sup>4</sup>). If <code>sc_use_eta_corr=false</code>, the convention can affect the full shift-current matrix element (see Ref. <sup>1</sup>).</p> <p>The default value is 1.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-sc_w_thr","title":"<code>real(kind=dp) :: sc_w_thr</code>","text":"<p>Parameter \\(\\alpha_{t}\\) for speeding up the frequency integration in shift-current calculations. It settles the frequency threshold \\(\\omega_{t}=\\alpha_{t}\\eta_{n{\\bf k}}\\) (a factor times the broadening) beyond which the delta functions are taken as zero.</p> <p>The default value is 5.0.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-kdotp_kpoint3","title":"<code>real(kind=dp) :: kdotp_kpoint(3)</code>","text":"<p>Defines the \\(k\\) point around which the \\(k\\cdot p\\) expansion is performed.</p> <p>The default value is 0.0 0.0 0.0 (\\(\\Gamma\\)).</p>"},{"location":"user_guide/postw90/postw90params/#integer-kdotp_num_bands","title":"<code>integer :: kdotp_num_bands</code>","text":"<p>Number of bands forming the \\(k\\cdot p\\) basis set.</p> <p>No default value.</p>"},{"location":"user_guide/postw90/postw90params/#integer-kdotp_bandskdotp_num_bands","title":"<code>integer :: kdotp_bands(kdotp_num_bands)</code>","text":"<p>Band indexes of bands belonging to \\(k\\cdot p\\) basis. Number of entries must be equal to the integer defined in <code>kdotp_num_bands</code>. The band labelling follows that of \"wannierised\" bands.</p> <p>No default value.</p>"},{"location":"user_guide/postw90/postw90params/#gyrotropic","title":"Gyrotropic","text":""},{"location":"user_guide/postw90/postw90params/#logical-gyrotropic","title":"<code>logical :: gyrotropic</code>","text":"<p>Determines whether to enter the gyrotropic routines.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-gyrotropic_task","title":"<code>character(len=120) :: gyrotropic_task</code>","text":"<p>The quantity to compute when <code>gyrotropic=true</code></p> <p>May contain one or more of the following valid options (note that each option starts with a '-'):</p> <ul> <li> <p><code>-D0</code> The Berry-curvature dipole tensor (dimensionless)</p> <p>Output file: <code>seedname-gyrotropic-D.dat</code> ( see Sec. output data format for file format description)</p> </li> <li> <p><code>-Dw</code> The finite-frequency Berry-curvature dipole tensor     (dimensionless)</p> <p>Output file: <code>seedname-gyrotropic-tildeD.dat</code> ( see Sec. output data format for file format description)</p> </li> <li> <p><code>-C</code> The ohmic conductivity tensor (Ampere/cm)</p> <p>Output file: <code>seedname-gyrotropic-C.dat</code> ( see Sec. output data format for file format description)</p> </li> <li> <p><code>-K</code> The orbital contribution to the kME tensor (Ampere)</p> <p>Output file: <code>seedname-gyrotropic-K_orb.dat</code> ( see Sec. output data format for file format description)</p> <ul> <li> <p><code>-spin</code> : if this task is present, compute also the spin     contribution.</p> <p>Output file: <code>seedname-gyrotropic-K_spin.dat</code></p> </li> </ul> </li> <li> <p><code>-NOA</code> The orbital contribution to the NOA (\u00c5)</p> <p>Output file: <code>seedname-gyrotropic-NOA_orb.dat</code> ( see Sec. output data format for file format description)</p> <ul> <li> <p><code>-spin</code> : if this task is present, compute also the spin     contribution.</p> <p>Output file: <code>seedname-gyrotropic-NOA_spin.dat</code></p> </li> </ul> </li> <li> <p><code>-dos</code> the density of states</p> <p>Output file: <code>seedname-gyrotropic-DOS.dat</code>. First column - energy (eV), second column - DOS (\\(1/(\\mathrm{eV}\\times\\mathring{A}^3)\\))</p> </li> </ul> <p>There is no default value.</p>"},{"location":"user_guide/postw90/postw90params/#output-data-format","title":"output data format","text":"<p>The calculated tensors are written as functions of Fermi level \\(E_F\\) (first column) and frequency \\(\\omega\\) (second column). If the tensor does not denend on \\(\\omega\\), the second column is filled by zeros. Data is grouped in blocks of the same \\(\\omega\\) separated by two blank lines. In case of natural optical activity the columns 3 to 11 contain the independent components of \\(\\gamma_{abc}\\) (antisymmetric in \\(ab\\)): \\(yzx\\), \\(zxy\\) ,\\(xyz\\), \\(yzy\\), \\(yzz\\), \\(zxz\\), \\(xyy\\), \\(yzz\\) and \\(zxx\\). For tensors \\(C_{ab}\\), \\(D_{ab}\\), \\(\\widetilde D_{ab}\\), \\(K_{ab}\\) the symmetric and antisymmetric components are writted. Thus, the columns 3 to 11 are marked as \\(xx\\), \\(yy\\), \\(zz\\), \\(xy\\), \\(xz\\), \\(yz\\), \\(x\\), \\(y\\), \\(z\\), wich correspond ,e.g., for \\(D_{ab}\\) to \\(D_{xx}\\), \\(D_{yy}\\), \\(D_{zz}\\), \\((D_{xy}+D_{yx})/2\\), \\((D_{xz}+D_{zx})/2\\), \\((D_{yz}+D_{zy})/2\\), \\((D_{yz}-D_{zy})/2\\), \\((D_{zx}-D_{xz})/2\\), \\((D_{xy}-D_{yx})/2\\)</p>"},{"location":"user_guide/postw90/postw90params/#integer-gyrotropic_kmesh","title":"<code>integer :: gyrotropic_kmesh(:)</code>","text":"<p>Overrides the <code>kmesh</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-gyrotropic_kmesh_spacing","title":"<code>real(kind=dp) :: gyrotropic_kmesh_spacing</code>","text":"<p>Overrides the <code>kmesh_spacing</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-gyrotropic_freq_min","title":"<code>real(kind=dp) :: gyrotropic_freq_min</code>","text":"<p>Lower limit of the frequency range for computing the optical activity.</p> <p>Units are eV. The default value 0.0.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-gyrotropic_freq_max","title":"<code>real(kind=dp) :: gyrotropic_freq_max</code>","text":"<p>Upper limit of the frequency range for computing the optical activity. Units are eV.</p> <p>If an inner energy window was specified, the default value is <code>dis_froz_max</code>-<code>fermi_energy</code>+0.6667. Otherwise it is the difference between the maximum and the minimum energy eigenvalue stored in <code>seedname.eig</code>, plus 0.6667.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-gyrotropic_freq_step","title":"<code>real(kind=dp) :: gyrotropic_freq_step</code>","text":"<p>Difference between consecutive values of the optical frequency between <code>gyrotropic_freq_min</code> and <code>gyrotropic_freq_max</code>.</p> <p>Units are eV. The default value is 0.01.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-gyrotropic_eigval_max","title":"<code>real(kind=dp) :: gyrotropic_eigval_max</code>","text":"<p>Maximum energy eigenvalue of the eigenstates to be included in the evaluation of the Natural optical activity. Units are eV.</p> <p>If an inner energy window was specified, the default value is the upper bound of the inner energy window plus 0.6667. Otherwise it is the maximum energy eigenvalue stored in <code>seedname.eig</code> plus 0.6667.</p>"},{"location":"user_guide/postw90/postw90params/#logical-gyrotropic_smr_fixed_en_width","title":"<code>logical :: gyrotropic_smr_fixed_en_width</code>","text":"<p>Overrides the <code>smr_fixed_en_width</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-gyrotropic_smr_type","title":"<code>character(len=120) :: gyrotropic_smr_type</code>","text":"<p>Overrides the <code>smr_type</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-gyrotropic_degen_thresh","title":"<code>character(len=120) :: gyrotropic_degen_thresh</code>","text":"<p>The threshould to eliminate degenerate bands from the calculation in order to avoid divergences.</p> <p>Units are eV. The dfault value is 0.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-gyrotropic_box_center","title":"<code>character(len=120) :: gyrotropic_box_center</code>","text":"<p>- three real numbers. Optionally the integration may be restricted to a parallelogram, centered at <code>gyrotropic_box_center</code> and defined by vectors <code>gyrotropic_box_b{1,2,3}</code></p> <p>In reduced coordinates. Default value is 0.5 0.5 0.5</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-gyrotropic_box_b1","title":"<code>character(len=120) :: gyrotropic_box_b1</code>","text":"<p>- three real numbers. In reduced coordinates. Default value is 1.0 0.0 0.0</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-gyrotropic_box_b2","title":"<code>character(len=120) :: gyrotropic_box_b2</code>","text":"<p>- three real numbers. In reduced coordinates. Default value is 0.0 1.0 0.0</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-gyrotropic_box_b3","title":"<code>character(len=120) :: gyrotropic_box_b3</code>","text":"<p>- three real numbers. In reduced coordinates. Default value is 0.0 0.0 1.0</p>"},{"location":"user_guide/postw90/postw90params/#boltzwann","title":"BoltzWann","text":""},{"location":"user_guide/postw90/postw90params/#logical-boltzwann","title":"<code>logical :: boltzwann</code>","text":"<p>Determines whether to enter the \u00a0routines.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#integer-boltz_kmesh","title":"<code>integer :: boltz_kmesh(:)</code>","text":"<p>It determines the interpolation \\(k\\) mesh used to calculate the TDF (from which the transport coefficient are calculated). If <code>boltz_calc_also_dos</code> is <code>true</code>, the same \\(k\\) mesh is used also for the DOS. Overrides the <code>kmesh</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_kmesh_spacing","title":"<code>real(kind=dp) :: boltz_kmesh_spacing</code>","text":"<p>Overrides the <code>kmesh_spacing</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#sec:boltz2ddir","title":"<code>character(len=4) :: boltz_2d_dir</code>","text":"<p>For two-dimensional systems, the direction along which the system is non-periodic. It can assume the following values: <code>x</code> for a 2D system on the \\(yz\\) plane, <code>y</code> for a 2D system on the \\(xz\\) plane, <code>z</code> for a 2D system on the \\(xy\\) plane, or <code>no</code> for a 3D system with periodicity along all threee directions.</p> <p>This value is used when calculating the Seebeck coefficient, where the electrical conductivity tensor needs to be inverted. If the value is different from zero, only the relevant \\(2\\times 2\\) sub-block of the electrical conductivity is inverted.</p> <p>The default value is <code>no</code>.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_relax_time","title":"<code>real(kind=dp) :: boltz_relax_time</code>","text":"<p>The relaxation time to be used for the calculation of the TDF and the transport coefficients.</p> <p>The units are fs. The default value is 10\u00a0fs.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_mu_min","title":"<code>real(kind=dp) :: boltz_mu_min</code>","text":"<p>Minimum value for the chemical potential \\(\\mu\\) for which we want to calculate the transport coefficients.</p> <p>The units are eV. No default value.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_mu_max","title":"<code>real(kind=dp) :: boltz_mu_max</code>","text":"<p>Maximum value for the chemical potential \\(\\mu\\) for which we want to calculate the transport coefficients.</p> <p>The units are eV. No default value.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_mu_step","title":"<code>real(kind=dp) :: boltz_mu_step</code>","text":"<p>Energy step for the grid of chemical potentials \\(\\mu\\) for which we want to calculate the transport coefficients.</p> <p>The units are eV. No default value.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_temp_min","title":"<code>real(kind=dp) :: boltz_temp_min</code>","text":"<p>Minimum value for the temperature \\(T\\) for which we want to calculate the transport coefficients.</p> <p>The units are K. No default value.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_temp_max","title":"<code>real(kind=dp) :: boltz_temp_max</code>","text":"<p>Maximum value for the temperature \\(T\\) for which we want to calculate the transport coefficients.</p> <p>The units are K. No default value.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_temp_step","title":"<code>real(kind=dp) :: boltz_temp_step</code>","text":"<p>Energy step for the grid of temperatures \\(T\\) for which we want to calculate the transport coefficients.</p> <p>The units are K. No default value.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_tdf_energy_step","title":"<code>real(kind=dp) :: boltz_tdf_energy_step</code>","text":"<p>Energy step for the grid of energies for the TDF.</p> <p>The units are eV. The default value is 0.001\u00a0eV.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-boltz_tdf_smr_type","title":"<code>character(len=120) :: boltz_tdf_smr_type</code>","text":"<p>The type of smearing function to be used for the TDF. The available strings are the same of the global <code>smr_type</code> input flag.</p> <p>The default value is the one given via the <code>smr_type</code> input flag (if defined).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_tdf_smr_fixed_en_width","title":"<code>real(kind=dp) :: boltz_tdf_smr_fixed_en_width</code>","text":"<p>Energy width for the smearing function. Note that for the TDF, a standard (non-adaptive) smearing scheme is used.</p> <p>The units are eV. The default value is 0\u00a0eV. Note that if the width is smaller than twice the energy step <code>boltz_tdf_energy_step</code>, the TDF will be unsmeared (thus the default is to have an unsmeared TDF).</p>"},{"location":"user_guide/postw90/postw90params/#logical-boltz_calc_also_dos","title":"<code>logical :: boltz_calc_also_dos</code>","text":"<p>Whether to calculate also the DOS while calculating the TDF.</p> <p>If one needs also the DOS, it is faster to calculate the DOS using this flag instead of using independently the routines of the <code>dos</code> module, since in this way the interpolation on the \\(k\\) points will be performed only once.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_dos_energy_min","title":"<code>real(kind=dp) :: boltz_dos_energy_min</code>","text":"<p>The minimum value for the energy grid for the calculation of the DOS.</p> <p>The units are eV. The default value is <code>minval(eigval)-0.6667</code>, where <code>minval(eigval)</code> i\u00a0s the minimum eigenvalue returned by the ab-initio code on the ab-initio \\(q\\) me\u00a0sh.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_dos_energy_max","title":"<code>real(kind=dp) :: boltz_dos_energy_max</code>","text":"<p>The maximum value for the energy grid for the calculation of the DOS.</p> <p>The units are eV. The default value is <code>maxval(eigval)+0.6667</code>, where <code>maxval(eigval)</code> i\u00a0s the maximum eigenvalue returned by the ab-initio code on the ab-initio \\(q\\) me\u00a0sh.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_dos_energy_step","title":"<code>real(kind=dp) :: boltz_dos_energy_step</code>","text":"<p>Energy step for the grid of energies for the DOS.</p> <p>The units are eV. The default value is 0.001\u00a0eV.</p>"},{"location":"user_guide/postw90/postw90params/#characterlen120-boltz_dos_smr_type","title":"<code>character(len=120) :: boltz_dos_smr_type</code>","text":"<p>Overrides the <code>smr_type</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#logical-boltz_dos_adpt_smr","title":"<code>logical :: boltz_dos_adpt_smr</code>","text":"<p>Overrides the <code>adpt_smr</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_dos_adpt_smr_fac","title":"<code>real(kind=dp) :: boltz_dos_adpt_smr_fac</code>","text":"<p>Overrides the <code>adpt_smr_fac</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_dos_adpt_smr_max","title":"<code>real(kind=dp) :: boltz_dos_adpt_smr_max</code>","text":"<p>Overrides the <code>adpt_smr_max</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#logical-boltz_dos_smr_fixed_en_width","title":"<code>logical :: boltz_dos_smr_fixed_en_width</code>","text":"<p>Overrides the <code>smr_fixed_en_width</code> global variable (see Sec.\u00a0Global variables).</p>"},{"location":"user_guide/postw90/postw90params/#logical-boltz_bandshift","title":"<code>logical :: boltz_bandshift</code>","text":"<p>Shift all conduction bands by a given amount (defined by <code>boltz_bandshift_energyshift</code>).</p> <p>Note</p> <p>this flag slightly differs from the global <code>scissors_shift</code> flag: with <code>boltz_bandshift</code>, an exact rigid shift is applied after interpolation; <code>scissors_shift</code> applies instead the shift before interpolation. As a consequence, results may slightly differ (and this is why we provide both possibilities). Note also that with <code>scissors_shift</code> you have to provide the number of valence bands <code>num_valence_bands</code>, while with <code>boltz_bandshift</code> you should provide the first band to shift <code>boltz_bandshift_firstband</code> = <code>num_valence_bands</code>\\(+1\\).</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#integer-boltz_bandshift_firstband","title":"<code>integer :: boltz_bandshift_firstband</code>","text":"<p>Index of the first conduction band to shift.</p> <p>That means that all bands with index \\(i\\ge {\\tt boltz\\_bandshift\\_firstband}\\) will be shifted by <code>boltz_bandshift_energyshift</code>, if <code>boltz_bandshift</code> is <code>true</code>.</p> <p>The units are eV. No default value; if <code>boltz_bandshift</code> is <code>true</code>, this flag must be provided.</p>"},{"location":"user_guide/postw90/postw90params/#realkinddp-boltz_bandshift_energyshift","title":"<code>real(kind=dp) :: boltz_bandshift_energyshift</code>","text":"<p>Energy shift of the conduction bands.</p> <p>The units are eV. No default value; if <code>boltz_bandshift</code> is <code>true</code>, this flag must be provided.</p>"},{"location":"user_guide/postw90/postw90params/#generic-band-interpolation","title":"Generic Band Interpolation","text":""},{"location":"user_guide/postw90/postw90params/#logical-geninterp","title":"<code>logical :: geninterp</code>","text":"<p>Determines whether to enter the Generic Band Interpolation routines.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#logical-geninterp_alsofirstder","title":"<code>logical :: geninterp_alsofirstder</code>","text":"<p>Whether to calculate also the first derivatives of the bands at the given \\(k\\) points.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/postw90/postw90params/#logical-geninterp_single_file","title":"<code>logical :: geninterp_single_file</code>","text":"<p>Whether to write a single <code>seedname_geninterp.dat</code> file (all I/O is done by the root node); or instead multiple files (one for each node) with names <code>seedname_geninterp_NNNNN.dat</code>, where <code>NNNNN</code> is the node number. See also the discussion in Sec.\u00a0<code>seedname_geninterp.dat</code> or <code>seedname_geninterp_NNNNN.dat</code>.</p> <p>The default value is <code>true</code>.</p> <ol> <li> <p>Jae-Mo Lihm. Comment on \u201cab initio calculation of the shift photocurrent by wannier interpolation\u201d. Phys. Rev. B, 103:247101, Jun 2021. URL: https://link.aps.org/doi/10.1103/PhysRevB.103.247101, doi:10.1103/PhysRevB.103.247101.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>X. Wang, J. R. Yates, I. Souza, and D. Vanderbilt. Ab initio calculation of the anomalous hall conductivity by wannier interpolation. Phys. Rev. B, 74:195118, 2006.\u00a0\u21a9</p> </li> <li> <p>T. Yusufaly, D. Vanderbilt, and S. Coh. Tight-Binding Formalism in the Context of the PythTB Package. \\url http://physics.rutgers.edu/pythtb/formalism.html.\u00a0\u21a9</p> </li> <li> <p>Julen Iba\u00f1ez-Azpiroz, Stepan S. Tsirkin, and Ivo Souza. Ab initio calculation of the shift photocurrent by wannier interpolation. Phys. Rev. B, 97:245143, Jun 2018. URL: https://link.aps.org/doi/10.1103/PhysRevB.97.245143, doi:10.1103/PhysRevB.97.245143.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/code_overview/","title":"Code Overview","text":"<p><code>wannier90</code>\u00a0can operate in two modes:</p> <ol> <li> <p>Post-processing mode: read in the overlaps and projections from     file as computed inside a first-principles code. We expect this to     be the most common route to using <code>wannier90</code>, and is described in     Chapter\u00a0Post-processing;</p> </li> <li> <p>Library mode: as a set of library routines to be called from     within a first-principles code that passes the overlaps and     projections to the <code>wannier90</code>\u00a0library routines and in return gets     the unitary transformation corresponding to MLWF. This route should     be used if the MLWF are needed within the first-principles code, for     example in post-LDA methods such as LDA+U or SIC, and is described     in Chapter\u00a0Library mode.</p> </li> </ol> Schematic overview of the module structure of <code>wannier90</code>. Modules may only use data and subroutines from lower modules."},{"location":"user_guide/wannier90/files/","title":"Files","text":""},{"location":"user_guide/wannier90/files/#seednamewin","title":"<code>seedname.win</code>","text":"<p>INPUT. The master input file; contains the specification of the system and any parameters for the run. For a description of input parameters, see Chapter\u00a0Parameters; for examples, see Section\u00a0<code>seedname.win</code> and the <code>wannier90</code>\u00a0Tutorial.</p>"},{"location":"user_guide/wannier90/files/#units","title":"Units","text":"<p>The following are the dimensional quantities that are specified in the master input file:</p> <ul> <li> <p>Direct lattice vectors</p> </li> <li> <p>Positions (of atomic or projection) centres in real space</p> </li> <li> <p>Energy windows</p> </li> <li> <p>Positions of k-points in reciprocal space</p> </li> <li> <p>Convergence thresholds for the minimisation of \\(\\Omega\\)</p> </li> <li> <p><code>zona</code> (see Section\u00a0Projections)</p> </li> <li> <p><code>wannier_plot_cube</code>: cut-off radius for plotting WF in Gaussian cube     format</p> </li> </ul> <p>Notes:</p> <ul> <li> <p>The units (either <code>ang</code> (default) or <code>bohr</code>) in which the lattice     vectors, atomic positions or projection centres are given can be set     in the first line of the blocks <code>unit_cell_cart</code>, <code>atoms_cart</code> and     <code>projections</code>, respectively, in <code>seedname.win</code>.</p> </li> <li> <p>Energy is always in eV.</p> </li> <li> <p>Convergence thresholds are always in \u00c5\\(^{2}\\)</p> </li> <li> <p>Positions of k-points are always in crystallographic coordinates     relative to the reciprocal lattice vectors.</p> </li> <li> <p><code>zona</code> is always in reciprocal Angstrom (\u00c5\\(^{-1}\\))</p> </li> <li> <p>The keyword <code>length_unit</code> may be set to <code>ang</code> (default) or <code>bohr</code>,     in order to set the units in which the quantities in the output file     <code>seedname.wout</code> are written.</p> </li> <li> <p><code>wannier_plot_radius</code> is in Angstrom</p> </li> </ul> <p>The reciprocal lattice vectors \\(\\{\\mathbf{B}_{1},\\mathbf{B}_{2},\\mathbf{B}_{3}\\}\\) are defined in terms of the direct lattice vectors \\(\\{\\mathbf{A}_{1},\\mathbf{A}_{2},\\mathbf{A}_{3}\\}\\) by the equation</p> \\[ \\mathbf{B}_{1} = \\frac{2\\pi}{\\Omega}\\mathbf{A}_{2}\\times\\mathbf{A}_{3} \\ \\ \\ \\mathrm{etc.}, \\] <p>where the cell volume is \\(V=\\mathbf{A}_{1}\\cdot(\\mathbf{A}_{2}\\times\\mathbf{A}_{3})\\).</p>"},{"location":"user_guide/wannier90/files/#seednamemmn","title":"<code>seedname.mmn</code>","text":"<p>INPUT. Written by the underlying electronic structure code. See Chapter\u00a0Post-processing for details.</p>"},{"location":"user_guide/wannier90/files/#seednameamn","title":"<code>seedname.amn</code>","text":"<p>INPUT. Written by the underlying electronic structure code. See Chapter\u00a0Post-processing for details.</p>"},{"location":"user_guide/wannier90/files/#seednamedmn","title":"<code>seedname.dmn</code>","text":"<p>INPUT. Read if <code>site_symmetry = .true.</code> (symmetry-adapted mode). Written by the underlying electronic structure code. See Chapter\u00a0Post-processing for details.</p>"},{"location":"user_guide/wannier90/files/#seednameeig","title":"<code>seedname.eig</code>","text":"<p>INPUT. Written by the underlying electronic structure code. See Chapter\u00a0Post-processing for details.</p>"},{"location":"user_guide/wannier90/files/#sec:old-nnkp","title":"<code>seedname.nnkp</code>","text":"<p>OUTPUT. Written by <code>wannier90</code>\u00a0when <code>postproc_setup=.TRUE.</code> (or, alternatively, when <code>wannier90</code>\u00a0is run with the <code>-pp</code> command-line option). See Chapter\u00a0Post-processing for details.</p>"},{"location":"user_guide/wannier90/files/#seednamewout","title":"<code>seedname.wout</code>","text":"<p>OUTPUT. The master output file. Here we give a description of the main features of the output. The verbosity of the output is controlled by the input parameter <code>iprint</code>. The higher the value, the more detail is given in the output file. The default value is 1, which prints minimal information.</p>"},{"location":"user_guide/wannier90/files/#header","title":"Header","text":"<p>The header provides some basic information about <code>wannier90</code>, the authors, the code version and release, and the execution time of the current run. The header looks like the following different (the string might slightly change across different versions):</p> Output file<pre><code>             +---------------------------------------------------+\n             |                                                   |\n             |                   WANNIER90                       |\n             |                                                   |\n             +---------------------------------------------------+\n             |                                                   |\n             |        Welcome to the Maximally-Localized         |\n             |        Generalized Wannier Functions code         |\n             |            http://www.wannier.org                 |\n             |                                                   |\n             |  Wannier90 Developer Group:                       |\n             |    Giovanni Pizzi    (EPFL)                       |\n             |    Valerio Vitale    (Cambridge)                  |\n             |    David Vanderbilt  (Rutgers University)         |\n             |    Nicola Marzari    (EPFL)                       |\n             |    Ivo Souza         (Universidad del Pais Vasco) |\n             |    Arash A. Mostofi  (Imperial College London)    |\n             |    Jonathan R. Yates (University of Oxford)       |\n             |                                                   |\n             |  For the full list of Wannier90 3.x authors,      |\n             |  please check the code documentation and the      |\n             |  README on the GitHub page of the code            |\n             |                                                   |\n             |                                                   |\n             |  Please cite                                      |\n                                       .\n                                       .\n             |                                                   |\n             +---------------------------------------------------+\n             |    Execution started on 18Dec2018 at 18:39:42     |\n             +---------------------------------------------------+\n</code></pre>"},{"location":"user_guide/wannier90/files/#system-information","title":"System information","text":"<p>This part of the output file presents information that <code>wannier90</code>\u00a0has read or inferred from the master input file <code>seedname.win</code>. This includes real and reciprocal lattice vectors, atomic positions, k-points, parameters for job control, disentanglement, localisation and plotting.</p> Output file<pre><code>                                    ------\n                                    SYSTEM\n                                    ------\n\n                              Lattice Vectors (Ang)\n                    a_1     3.938486   0.000000   0.000000\n                    a_2     0.000000   3.938486   0.000000\n                    a_3     0.000000   0.000000   3.938486\n\n                   Unit Cell Volume:      61.09251  (Ang^3)\n\n                        Reciprocal-Space Vectors (Ang^-1)\n                    b_1     1.595330   0.000000   0.000000\n                    b_2     0.000000   1.595330   0.000000\n                    b_3     0.000000   0.000000   1.595330\n\n *----------------------------------------------------------------------------*\n |   Site       Fractional Coordinate          Cartesian Coordinate (Ang)     |\n +----------------------------------------------------------------------------+\n | Ba   1   0.00000   0.00000   0.00000   |    0.00000   0.00000   0.00000    |\n | Ti   1   0.50000   0.50000   0.50000   |    1.96924   1.96924   1.96924    |\n                                          .\n                                          . \n *----------------------------------------------------------------------------*\n\n                                ------------\n                                K-POINT GRID\n                                ------------\n\n             Grid size =  4 x  4 x  4      Total points =   64\n\n *---------------------------------- MAIN ------------------------------------*\n |  Number of Wannier Functions               :                 9             |\n |  Number of input Bloch states              :                 9             |\n |  Output verbosity (1=low, 5=high)          :                 1             |\n |  Length Unit                               :               Ang             |\n |  Post-processing setup (write *.nnkp)      :                 F             |\n                                              .\n                                              .\n *----------------------------------------------------------------------------*\n</code></pre>"},{"location":"user_guide/wannier90/files/#nearest-neighbour-k-points","title":"Nearest-neighbour k-points","text":"<p>This part of the output files provides information on the \\(\\mathrm{b}\\)-vectors and weights chosen to satisfy the condition of Eq.\u00a0B1.</p> Output file<pre><code> *---------------------------------- K-MESH ----------------------------------*\n +----------------------------------------------------------------------------+\n |                    Distance to Nearest-Neighbour Shells                    |\n |                    ------------------------------------                    |\n |          Shell             Distance (Ang^-1)          Multiplicity         |\n |          -----             -----------------          ------------         |\n |             1                   0.398833                      6            |\n |             2                   0.564034                     12            |\n                                       .\n                                       .\n +----------------------------------------------------------------------------+\n | The b-vectors are chosen automatically                                     |\n | The following shells are used:   1                                         |\n +----------------------------------------------------------------------------+\n |                        Shell   # Nearest-Neighbours                        |\n |                        -----   --------------------                        |\n |                          1               6                                 |\n +----------------------------------------------------------------------------+\n | Completeness relation is fully satisfied [Eq. (B1), PRB 56, 12847 (1997)]  |\n +----------------------------------------------------------------------------+\n</code></pre>"},{"location":"user_guide/wannier90/files/#disentanglement","title":"Disentanglement","text":"<p>Then (if required) comes the part where \\(\\Omega_{\\mathrm{I}}\\) is minimised to disentangle the optimally-connected subspace of states for the localisation procedure in the next step.</p> <p>First, a summary of the energy windows that are being used is given:</p> Output file<pre><code> *------------------------------- DISENTANGLE --------------------------------*\n +----------------------------------------------------------------------------+\n |                              Energy  Windows                               |\n |                              ---------------                               |\n |                   Outer:    2.81739  to   38.00000  (eV)                   |\n |                   Inner:    2.81739  to   13.00000  (eV)                   |\n +----------------------------------------------------------------------------+\n</code></pre> <p>Then, each step of the iterative minimisation of \\(\\Omega_{\\mathrm{I}}\\) is reported.</p> Output file<pre><code>                   Extraction of optimally-connected subspace                  \n                   ------------------------------------------                  \n +---------------------------------------------------------------------+&lt;-- DIS\n |  Iter     Omega_I(i-1)      Omega_I(i)      Delta (frac.)    Time   |&lt;-- DIS\n +---------------------------------------------------------------------+&lt;-- DIS\n       1       3.82493590       3.66268867       4.430E-02      0.36    &lt;-- DIS\n       2       3.66268867       3.66268867       6.911E-15      0.37    &lt;-- DIS\n                                       .\n                                       .\n\n             &lt;&lt;&lt;      Delta &lt; 1.000E-10  over  3 iterations     &gt;&gt;&gt;\n             &lt;&lt;&lt; Disentanglement convergence criteria satisfied &gt;&gt;&gt;\n\n        Final Omega_I     3.66268867 (Ang^2)\n\n +----------------------------------------------------------------------------+\n</code></pre> <p>The first column gives the iteration number. For a description of the minimisation procedure and expressions for \\(\\Omega_{\\mathrm{I}}^{(i)}\\), see the original paper\u00a0<sup>1</sup>. The procedure is considered to be converged when the fractional difference between \\(\\Omega_{\\mathrm{I}}^{(i)}\\) and \\(\\Omega_{\\mathrm{I}}^{(i-1)}\\) is less than <code>dis_conv_tol</code> over <code>dis_conv_window</code> iterations. The final column gives a running account of the wall time (in seconds) so far. Note that at the end of each line of output, there are the characters \"<code>&lt;\u2013 DIS</code>\". This enables fast searching of the output using, for example, the Unix command <code>grep</code>:</p> <pre><code>grep DIS wannier.wout | less\n</code></pre>"},{"location":"user_guide/wannier90/files/#wannierisation","title":"Wannierisation","text":"<p>The next part of the output file provides information on the minimisation of \\(\\widetilde{\\Omega}\\). At each iteration, the centre and spread of each WF is reported.</p> Output file<pre><code> *------------------------------- WANNIERISE ---------------------------------*\n +--------------------------------------------------------------------+&lt;-- CONV\n | Iter  Delta Spread     RMS Gradient      Spread (Ang^2)      Time  |&lt;-- CONV\n +--------------------------------------------------------------------+&lt;-- CONV\n\n ------------------------------------------------------------------------------\n Initial State\n  WF centre and spread    1  (  0.000000,  1.969243,  1.969243 )     1.52435832\n  WF centre and spread    2  (  0.000000,  1.969243,  1.969243 )     1.16120620\n                                      .\n                                      .\n      0     0.126E+02     0.0000000000       12.6297685260       0.29  &lt;-- CONV\n        O_D=      0.0000000 O_OD=      0.1491718 O_TOT=     12.6297685 &lt;-- SPRD\n ------------------------------------------------------------------------------\n Cycle:      1\n  WF centre and spread    1  (  0.000000,  1.969243,  1.969243 )     1.52414024\n  WF centre and spread    2  (  0.000000,  1.969243,  1.969243 )     1.16059775\n                                      .\n                                      .\n  Sum of centres and spreads ( 11.815458, 11.815458, 11.815458 )    12.62663472\n\n      1    -0.313E-02     0.0697660962       12.6266347170       0.34  &lt;-- CONV\n        O_D=      0.0000000 O_OD=      0.1460380 O_TOT=     12.6266347 &lt;-- SPRD\n Delta: O_D= -0.4530841E-18 O_OD= -0.3133809E-02 O_TOT= -0.3133809E-02 &lt;-- DLTA\n ------------------------------------------------------------------------------\n Cycle:      2\n  WF centre and spread    1  (  0.000000,  1.969243,  1.969243 )     1.52414866\n  WF centre and spread    2  (  0.000000,  1.969243,  1.969243 )     1.16052405\n                                      .\n                                      .\n   Sum of centres and spreads ( 11.815458, 11.815458, 11.815458 )    12.62646411\n\n      2    -0.171E-03     0.0188848262       12.6264641055       0.38  &lt;-- CONV\n        O_D=      0.0000000 O_OD=      0.1458674 O_TOT=     12.6264641 &lt;-- SPRD\n Delta: O_D= -0.2847260E-18 O_OD= -0.1706115E-03 O_TOT= -0.1706115E-03 &lt;-- DLTA\n ------------------------------------------------------------------------------\n                                      .\n                                      .\n ------------------------------------------------------------------------------\n Final State\n  WF centre and spread    1  (  0.000000,  1.969243,  1.969243 )     1.52416618\n  WF centre and spread    2  (  0.000000,  1.969243,  1.969243 )     1.16048545\n                                      .\n                                      .\n  Sum of centres and spreads ( 11.815458, 11.815458, 11.815458 )    12.62645344\n\n         Spreads (Ang^2)       Omega I      =    12.480596753\n        ================       Omega D      =     0.000000000\n                               Omega OD     =     0.145856689\n    Final Spread (Ang^2)       Omega Total  =    12.626453441\n ------------------------------------------------------------------------------\n</code></pre> <p>It looks quite complicated, but things look more simple if one uses <code>grep</code>:</p> Terminal<pre><code>grep CONV wannier.wout\n</code></pre> <p>gives</p> Output file<pre><code> +--------------------------------------------------------------------+&lt;-- CONV\n | Iter  Delta Spread     RMS Gradient      Spread (Ang^2)      Time  |&lt;-- CONV\n +--------------------------------------------------------------------+&lt;-- CONV\n      0     0.126E+02     0.0000000000       12.6297685260       0.29  &lt;-- CONV\n      1    -0.313E-02     0.0697660962       12.6266347170       0.34  &lt;-- CONV\n                                                   .\n                                                   .\n     50     0.000E+00     0.0000000694       12.6264534413       2.14  &lt;-- CONV\n</code></pre> <p>The first column is the iteration number, the second is the change in \\(\\Omega\\) from the previous iteration, the third is the root-mean-squared gradient of \\(\\Omega\\) with respect to variations in the unitary matrices \\(\\mathbf{U}^{(\\mathbf{k})}\\), and the last is the time taken (in seconds). Depending on the input parameters used, the procedure either runs for <code>num_iter</code> iterations, or a convergence criterion is applied on \\(\\Omega\\). See Section Wannierise Parameters for details.</p> <p>Similarly, the command</p> Terminal<pre><code>grep SPRD wannier.wout\n</code></pre> <p>gives</p> Output file<pre><code>        O_D=      0.0000000 O_OD=      0.1491718 O_TOT=     12.6297685 &lt;-- SPRD\n        O_D=      0.0000000 O_OD=      0.1460380 O_TOT=     12.6266347 &lt;-- SPRD\n                                            .\n                                            .\n        O_D=      0.0000000 O_OD=      0.1458567 O_TOT=     12.6264534 &lt;-- SPRD\n</code></pre> <p>which, for each iteration, reports the value of the diagonal and off-diagonal parts of the non-gauge-invariant spread, as well as the total spread, respectively. Recall from Section\u00a0Methodology that \\(\\Omega = \\Omega_{\\mathrm{I}}+ \\Omega_{\\mathrm{D}} + \\Omega_{\\mathrm{OD}}\\).</p>"},{"location":"user_guide/wannier90/files/#wannierisation-with-selective-localization-and-constrained-centres","title":"Wannierisation with selective localization and constrained centres","text":"<p>For full details of the selectively localised Wannier function (SLWF) method, the reader is referred to Ref.\u00a0<sup>2</sup>. When using the SLWF method, only a few things change in the output file and in general the same principles described above will apply. In particular, when minimising the spread with respect to the degrees of freedom of only a subset of functions, it is not possible to cast the total spread functional \\(\\Omega\\) as a sum of a gauge-invariant part and a gauge-dependent part. Instead, one has \\(\\Omega^{'} = \\Omega_{\\mathrm{IOD}} + \\Omega_{\\mathrm{D}}\\), where</p> \\[ \\Omega^{'} = \\sum_{n=1}^{J'&lt;J} \\left[\\langle r^2 \\rangle_n - \\overline{\\mathbf{r}}_{n}^{2}\\right] \\] <p>and</p> \\[ \\Omega_{\\mathrm{IOD}} = \\sum_{n=1}^{J'&lt;J} \\left[\\langle r^2_n \\rangle- \\sum_{\\mathbf{R}} \\vert\\langle\\mathbf{R}n\\vert \\mathbf{r} \\vert n\\mathbf{R}\\rangle\\vert^2 \\right]. \\] <p>The total number of Wannier functions is \\(J\\), whereas \\(J'\\) is the number functions to be selectively localized (so-called objective WFs). The information on the number of functions which are going to be selectively localized (<code>Number of Objective Wannier Functions</code>) is given in the <code>MAIN</code> section of the output file:</p> Output file<pre><code> *---------------------------------- MAIN ------------------------------------*\n |  Number of Wannier Functions               :                 4             |\n |  Number of Objective Wannier Functions     :                 1             |\n |  Number of input Bloch states              :                 4             |\n</code></pre> <p>Whether or not the selective localization procedure has been switched on is reported in the <code>WANNIERISE</code> section as</p> Output file<pre><code> |  Perform selective localization            :                 T             |\n</code></pre> <p>The next part of the output file provides information on the minimisation of the modified spread functional:</p> Output file<pre><code> *------------------------------- WANNIERISE ---------------------------------*\n +--------------------------------------------------------------------+&lt;-- CONV\n | Iter  Delta Spread     RMS Gradient      Spread (Ang^2)      Time  |&lt;-- CONV\n +--------------------------------------------------------------------+&lt;-- CONV\n\n ------------------------------------------------------------------------------\n Initial State\n  WF centre and spread    1  ( -0.857524,  0.857524,  0.857524 )     1.80463310\n  WF centre and spread    2  (  0.857524, -0.857524,  0.857524 )     1.80463311\n  WF centre and spread    3  (  0.857524,  0.857524, -0.857524 )     1.80463311\n  WF centre and spread    4  ( -0.857524, -0.857524, -0.857524 )     1.80463311\n  Sum of centres and spreads ( -0.000000, -0.000000,  0.000000 )     7.21853243\n\n      0    -0.317E+01     0.0000000000       -3.1653368719       0.00  &lt;-- CONV\n       O_D=      0.0000000 O_IOD=     -3.1653369 O_TOT=     -3.1653369 &lt;-- SPRD\n ------------------------------------------------------------------------------\n Cycle:      1\n  WF centre and spread    1  ( -0.853260,  0.853260,  0.853260 )     1.70201498\n  WF centre and spread    2  (  0.857352, -0.857352,  0.862454 )     1.84658331\n  WF centre and spread    3  (  0.857352,  0.862454, -0.857352 )     1.84658331\n  WF centre and spread    4  ( -0.862454, -0.857352, -0.857352 )     1.84658331\n  Sum of centres and spreads ( -0.001010,  0.001010,  0.001010 )     7.24176492\n\n      1    -0.884E-01     0.2093698260       -3.2536918930       0.00  &lt;-- CONV\n       O_IOD=     -3.2536919 O_D=      0.0000000 O_TOT=     -3.2536919 &lt;-- SPRD\nDelta: O_IOD= -0.1245020E+00 O_D=  0.0000000E+00 O_TOT= -0.8835502E-01 &lt;-- DLTA\n ------------------------------------------------------------------------------\n                                      .\n                                      .\n ------------------------------------------------------------------------------\n Final State\n  WF centre and spread    1  ( -0.890189,  0.890189,  0.890189 )     1.42375495\n  WF centre and spread    2  (  0.895973, -0.895973,  0.917426 )     2.14313664\n  WF centre and spread    3  (  0.895973,  0.917426, -0.895973 )     2.14313664\n  WF centre and spread    4  ( -0.917426, -0.895973, -0.895973 )     2.14313664\n  Sum of centres and spreads ( -0.015669,  0.015669,  0.015669 )     7.85316486\n\n         Spreads (Ang^2)       Omega IOD    =     1.423371553\n        ================       Omega D      =     0.000383395\n                               Omega Rest   =     9.276919811\n    Final Spread (Ang^2)       Omega Total  =     1.423754947\n ------------------------------------------------------------------------------\n</code></pre> <p>When comparing the output from an SLWF calculation with a standard wannierisation (see Sec.\u00a0Wannierisation), the only differences are in the definition of the spread functional. Hence, during the minimization <code>O_OD</code> is replaced by <code>O_IOD</code> and <code>O_TOT</code> now reflects the fact that the new total spread functional is \\(\\Omega^{'}\\). The part on the final state has one more item of information: the value of the difference between the global spread functional and the new spread functional given by <code>Omega Rest</code></p> \\[ \\Omega_{R} = \\sum_{n=1}^{J-J'} \\left[\\langle r^2 \\rangle_n - \\overline{\\mathbf{r}}_{n}^{2} \\right] \\] <p>If adding centre-constraints to the SLWFs, you will find the information about the centres of the original projections and the desired centres in the <code>SYSTEM</code> section</p> Output file<pre><code> *----------------------------------------------------------------------------*\n | Wannier#        Original Centres              Constrained centres          |\n +----------------------------------------------------------------------------+\n |    1     0.25000   0.25000   0.25000   |    0.00000   0.00000   0.00000    |\n *----------------------------------------------------------------------------*\n</code></pre> <p>As before one can check that the selective localization with constraints is being used by looking at the <code>WANNIERISE</code> section:</p> Output file<pre><code> |  Perform selective localization            :                 T             |\n |  Use constrains in selective localization  :                 T             |\n |  Value of the Lagrange multiplier          :         0.100E+01             |\n *----------------------------------------------------------------------------*\n</code></pre> <p>which also gives the selected value for the Lagrange multiplier. The output file for the minimisation section is modified as follows: both <code>O_IOD</code> and <code>O_TOT</code> now take into account the factors coming from the new term in the functional due to the constraints, which are implemented by adding the following penalty functional to the spread functional,</p> \\[ \\lambda_c \\sum_{n=1}^{J'} \\left(\\overline{\\mathbf{r}}_n - \\mathbf{r}_{0n} \\right)^2, \\] <p>where \\(\\mathbf{r}_{0n}\\) is the desired centre for the \\(n^{\\text{th}}\\) Wannier function, see Ref.\u00a0<sup>2</sup> for details. The layout of the output file at each iteration is unchanged.</p> Output file<pre><code>      1    -0.884E-01     0.2093698260       -3.2536918930       0.00  &lt;-- CONV\n</code></pre> <p>As regarding the final state, the only addition is the information on the value of the penalty functional associated with the constraints (<code>Penalty func</code>), which should be zero if the final centres of the Wannier functions are at the target centres:</p> Output file<pre><code> Final State\n  WF centre and spread    1  ( -1.412902,  1.412902,  1.412902 )     1.63408756\n  WF centre and spread    2  (  1.239678, -1.239678,  1.074012 )     2.74801593\n  WF centre and spread    3  (  1.239678,  1.074012, -1.239678 )     2.74801592\n  WF centre and spread    4  ( -1.074012, -1.239678, -1.239678 )     2.74801592\n  Sum of centres and spreads ( -0.007559,  0.007559,  0.007559 )     9.87813534\n\n         Spreads (Ang^2)       Omega IOD_C   =    -4.261222001\n        ================       Omega D       =     0.000000000\n                               Omega Rest    =     5.616913337\n                               Penalty func  =     0.000000000\n    Final Spread (Ang^2)       Omega Total_C =    -4.261222001\n ------------------------------------------------------------------------------\n</code></pre>"},{"location":"user_guide/wannier90/files/#plotting","title":"Plotting","text":"<p>After WF have been localised, <code>wannier90</code>\u00a0enters its plotting routines (if required). For example, if you have specified an interpolated bandstucture:</p> Output file<pre><code> *---------------------------------------------------------------------------*\n |                               PLOTTING                                    |\n *---------------------------------------------------------------------------*\n\n Calculating interpolated band-structure\n</code></pre>"},{"location":"user_guide/wannier90/files/#summary-timings","title":"Summary timings","text":"<p>At the very end of the run, a summary of the time taken for various parts of the calculation is given. The level of detail is controlled by the <code>timing_level</code> input parameter (set to 1 by default).</p> Output file<pre><code> *===========================================================================*\n |                             TIMING INFORMATION                            |\n *===========================================================================*\n |    Tag                                                Ncalls      Time (s)|\n |---------------------------------------------------------------------------|\n |kmesh: get                                        :         1         0.212|\n |overlap: read                                     :         1         0.060|\n |wann: main                                        :         1         1.860|\n |plot: main                                        :         1         0.168|\n *---------------------------------------------------------------------------*\n\n All done: wannier90 exiting\n</code></pre>"},{"location":"user_guide/wannier90/files/#seednamechk","title":"<code>seedname.chk</code>","text":"<p>INPUT/OUTPUT. Information required to restart the calculation or enter the plotting phase. If we have used disentanglement this file also contains the rectangular matrices \\(\\bf{U}^{{\\rm dis}({\\bf k})}\\).</p>"},{"location":"user_guide/wannier90/files/#seednamer2mn","title":"<code>seedname.r2mn</code>","text":"<p>OUTPUT. Written if <code>write_r2mn = true</code>. The matrix elements \\(\\langle m|r^2|n\\rangle\\) (where \\(m\\) and \\(n\\) refer to MLWF)</p>"},{"location":"user_guide/wannier90/files/#seedname_banddat","title":"<code>seedname_band.dat</code>","text":"<p>OUTPUT. Written if <code>bands_plot=.TRUE.</code>; The raw data for the interpolated band structure.</p>"},{"location":"user_guide/wannier90/files/#seedname_bandgnu","title":"<code>seedname_band.gnu</code>","text":"<p>OUTPUT. Written if <code>bands_plot=.TRUE.</code> and <code>bands_plot_format=gnuplot</code>; A <code>gnuplot</code> script to plot the interpolated band structure.</p>"},{"location":"user_guide/wannier90/files/#seedname_bandagr","title":"<code>seedname_band.agr</code>","text":"<p>OUTPUT. Written if <code>bands_plot=.TRUE.</code> and <code>bands_plot_format=xmgrace</code>; A <code>grace</code> file to plot the interpolated band structure.</p>"},{"location":"user_guide/wannier90/files/#seedname_bandkpt","title":"<code>seedname_band.kpt</code>","text":"<p>OUTPUT. Written if <code>bands_plot=.TRUE.</code>; The k-points used for the interpolated band structure, in units of the reciprocal lattice vectors. This file can be used to generate a comparison band structure from a first-principles code.</p>"},{"location":"user_guide/wannier90/files/#seednamebxsf","title":"<code>seedname.bxsf</code>","text":"<p>OUTPUT. Written if <code>fermi_surface_plot=.TRUE.</code>; A Fermi surface plot file suitable for plotting with XCrySDen.</p>"},{"location":"user_guide/wannier90/files/#seedname_wxsf","title":"<code>seedname_w.xsf</code>","text":"<p>OUTPUT. Written if <code>wannier_plot=.TRUE.</code> and <code>wannier_plot_format=xcrysden</code>. Contains the <code>w</code>\\(^{\\mathrm{th}}\\) WF in real space in a format suitable for plotting with XCrySDen or VMD, for example.</p>"},{"location":"user_guide/wannier90/files/#seedname_wcube","title":"<code>seedname_w.cube</code>","text":"<p>OUTPUT. Written if <code>wannier_plot=.TRUE.</code> and <code>wannier_plot_format=cube</code>. Contains the <code>w</code>\\(^{\\mathrm{th}}\\) WF in real space in Gaussian cube format, suitable for plotting in XCrySDen, VMD, gopenmol etc.</p>"},{"location":"user_guide/wannier90/files/#unkps","title":"<code>UNKp.s</code>","text":"<p>INPUT. Read if <code>wannier_plot</code>=<code>.TRUE.</code> and used to plot the MLWF. Read if <code>transport_mode</code>=<code>lcr</code> and <code>tran_read_ht</code>=<code>.FALSE.</code> for use in automated lcr transport calculations.</p> <p>The periodic part of the Bloch states represented on a regular real space grid, indexed by k-point <code>p</code> (from 1 to <code>num_kpts</code>) and spin <code>s</code> ('1' for 'up', '2' for 'down').</p> <p>The name of the wavefunction file is assumed to have the form:</p> Fortran<pre><code>    write(wfnname,200) p,spin\n200 format ('UNK',i5.5,'.',i1)\n</code></pre> <p>The first line of each file should contain 5 integers: the number of grid points in each direction (<code>ngx</code>, <code>ngy</code> and <code>ngz</code>), the k-point number <code>ik</code> and the total number of bands <code>num_band</code> in the file. The full file will be read by <code>wannier90</code>\u00a0as:</p> Fortran<pre><code>read(file_unit) ngx,ngy,ngz,ik,nbnd  \ndo loop_b=1,num_bands\n  read(file_unit) (r_wvfn(nx,loop_b),nx=1,ngx*ngy*ngz)\nend do\n</code></pre> <p>If <code>spinors</code>=<code>true</code> then <code>s</code>='NC', and the name of the wavefunction file is assumed to have the form:</p> Fortran<pre><code>    write(wfnname,200) p\n200 format ('UNK',i5.5,'.NC')\n</code></pre> <p>and the file will be read by <code>wannier90</code>\u00a0as:</p> Fortran<pre><code>read(file_unit) ngx,ngy,ngz,ik,nbnd  \ndo loop_b=1,num_bands\n  read(file_unit) (r_wvfn_nc(nx,loop_b,1),nx=1,ngx*ngy*ngz) ! up-spinor\n  read(file_unit) (r_wvfn_nc(nx,loop_b,2),nx=1,ngx*ngy*ngz) ! down-spinor\nend do\n</code></pre> <p>All UNK files can be in formatted or unformatted style, this is controlled by the logical keyword <code>wvfn_formatted</code>.</p>"},{"location":"user_guide/wannier90/files/#seedname_centresxyz","title":"<code>seedname_centres.xyz</code>","text":"<p>OUTPUT. Written if <code>write_xyz=.TRUE.</code>; xyz format atomic structure file suitable for viewing with your favourite visualiser (<code>jmol</code>, <code>gopenmol</code>, <code>vmd</code>, etc.).</p>"},{"location":"user_guide/wannier90/files/#seedname_hrdat","title":"<code>seedname_hr.dat</code>","text":"<p>OUTPUT. Written if <code>write_hr=.TRUE.</code>. The first line gives the date and time at which the file was created. The second line states the number of Wannier functions <code>num_wann</code>. The third line gives the number of Wigner-Seitz grid-points <code>nrpts</code>. The next block of <code>nrpts</code> integers gives the degeneracy of each Wigner-Seitz grid point, with 15 entries per line. Finally, the remaining <code>num_wann</code>\\(^2 \\times\\) <code>nrpts</code> lines each contain, respectively, the components of the vector \\(\\mathbf{R}\\) in terms of the lattice vectors \\(\\{\\mathbf{A}_{i}\\}\\), the indices \\(m\\) and \\(n\\), and the real and imaginary parts of the Hamiltonian matrix element \\(H_{mn}^{(\\mathbf{R})}\\) in the WF basis, e.g.,</p> Output file<pre><code> Created on 24May2007 at 23:32:09                            \n        20\n        17\n    4   1   2    1    4    1    1    2    1    4    6    1    1   1   2\n    1   2\n    0   0  -2    1    1   -0.001013    0.000000\n    0   0  -2    2    1    0.000270    0.000000\n    0   0  -2    3    1   -0.000055    0.000000\n    0   0  -2    4    1    0.000093    0.000000\n    0   0  -2    5    1   -0.000055    0.000000\n    .\n    .\n    .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_rdat","title":"<code>seedname_r.dat</code>","text":"<p>OUTPUT. Written if <code>write_rmn = true</code>. The matrix elements \\(\\langle m\\mathbf{0}|\\mathbf{r}|n\\mathbf{R}\\rangle\\) (where \\(n\\mathbf{R}\\) refers to MLWF \\(n\\) in unit cell \\(\\mathbf{R}\\)). The first line gives the date and time at which the file was created. The second line states the number of Wannier functions <code>num_wann</code>. The third line states the number of \\(\\mathbf{R}\\) vectors <code>nrpts</code>. Similar to the case of the Hamiltonian matrix above, the remaining <code>num_wann</code>\\(^2 \\times\\) <code>nrpts</code> lines each contain, respectively, the components of the vector \\(\\mathbf{R}\\) in terms of the lattice vectors \\(\\{\\mathbf{A}_{i}\\}\\), the indices \\(m\\) and \\(n\\), and the real and imaginary parts of the position matrix element in the WF basis.</p>"},{"location":"user_guide/wannier90/files/#seedname_tbdat","title":"<code>seedname_tb.dat</code>","text":"<p>OUTPUT. Written if <code>write_tb=.TRUE.</code>. This file is essentially a combination of <code>seedname_hr.dat</code> and <code>seedname_r.dat</code>, plus lattice vectors. The first line gives the date and time at which the file was created. The second to fourth lines are the lattice vectors in Angstrom unit.</p> Output file<pre><code> written on 27Jan2020 at 18:08:42 \n  -1.8050234585004898        0.0000000000000000        1.8050234585004898     \n   0.0000000000000000        1.8050234585004898        1.8050234585004898     \n  -1.8050234585004898        1.8050234585004898        0.0000000000000000 \n</code></pre> <p>The next part is the same as <code>seedname_hr.dat</code>. The fifth line states the number of Wannier functions <code>num_wann</code>. The sixth line gives the number of Wigner-Seitz grid-points <code>nrpts</code>. The next block of <code>nrpts</code> integers gives the degeneracy of each Wigner-Seitz grid point, with 15 entries per line. Then, the next <code>num_wann</code>\\(^2 \\times\\) <code>nrpts</code> lines each contain, respectively, the components of the vector \\(\\mathbf{R}\\) in terms of the lattice vectors \\(\\{\\mathbf{A}_{i}\\}\\), the indices \\(m\\) and \\(n\\), and the real and imaginary parts of the Hamiltonian matrix element \\(H_{mn}^{(\\mathbf{R})}\\) in the WF basis, e.g.,</p> Output file<pre><code>           7\n          93\n    4    6    2    2    2    1    2    2    1    1    2    6    2    2    2\n    6    2    2    4    1    1    1    4    1    1    1    1    2    1    1\n    1    2    2    1    1    2    4    2    1    2    1    1    1    1    2\n    1    1    1    2    1    1    1    1    2    1    2    4    2    1    1\n    2    2    1    1    1    2    1    1    1    1    4    1    1    1    4\n    2    2    6    2    2    2    6    2    1    1    2    2    1    2    2\n    2    6    4\n\n   -3    1    1\n    1    1    0.42351556E-02 -0.95722060E-07\n    2    1    0.69481480E-07 -0.20318638E-06\n    3    1    0.10966508E-06 -0.13983284E-06\n    .\n    .\n    .\n</code></pre> <p>Finally, the last part is the same as <code>seedname_r.dat</code>. The <code>num_wann</code>\\(^2 \\times\\) <code>nrpts</code> lines each contain, respectively, the components of the vector \\(\\mathbf{R}\\) in terms of the lattice vectors \\(\\{\\mathbf{A}_{i}\\}\\), the indices \\(m\\) and \\(n\\), and the real and imaginary parts of the position matrix element in the WF basis (the float numbers in columns 3 and 4 are the real and imaginary parts for \\(\\langle m\\mathbf{0}|\\mathbf{r}_x|n\\mathbf{R}\\rangle\\), columns 5 and 6 for \\(\\langle m\\mathbf{0}|\\mathbf{r}_y|n\\mathbf{R}\\rangle\\), and columns 7 and 8 for \\(\\langle m\\mathbf{0}|\\mathbf{r}_z|n\\mathbf{R}\\rangle\\)), e.g.</p> Output file<pre><code>   -3    1    1\n    1    1    0.32277552E-09  0.21174901E-08 -0.85436987E-09  0.26851510E-08  ...\n    2    1   -0.18881883E-08  0.21786973E-08  0.31123076E-03  0.39228431E-08  ...\n    3    1    0.31123242E-03 -0.35322230E-09  0.70867281E-09  0.10433480E-09  ...\n    .\n    .\n    .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seednamebvec","title":"<code>seedname.bvec</code>","text":"<p>OUTPUT. Written if <code>write_bvec = true</code>. This file contains the matrix elements of bvector and their weights. The first line gives the date and time at which the file was created. The second line states the number of k-points and the total number of neighbours for each k-point <code>nntot</code>. Then all the other lines contain the b-vector (x,y,z) coordinate and weigths for each k-points and each of its neighbours.</p>"},{"location":"user_guide/wannier90/files/#seedname_wsvecdat","title":"<code>seedname_wsvec.dat</code>","text":"<p>OUTPUT. Written if <code>write_hr = true</code> or <code>write_rmn = true</code> or <code>write_tb = true</code>. The first line gives the date and time at which the file was created and the value of <code>use_ws_distance</code>. For each pair of Wannier functions (identified by the components of the vector \\(\\mathbf{R}\\) separating their unit cells and their indices) it gives: (i) the number of lattice vectors of the periodic supercell \\(\\mathbf{T}\\) that bring the Wannier function in \\(\\mathbf{R}\\) back in the Wigner-Seitz cell centred on the other Wannier function and (ii) the set of superlattice vectors \\(\\mathbf{T}\\) to make this transformation. These superlattice vectors \\(\\mathbf{T}\\) should be added to the \\(\\mathbf{R}\\) vector to obtain the correct centre of the Wannier function that underlies a given matrix element (e.g. the Hamiltonian matrix elements in <code>seedname_hr.dat</code>) in order to correctly interpolate in reciprocal space.</p> Output file<pre><code>## written on 20Sep2016 at 18:12:37  with use_ws_distance=.true.\n    0    0    0    1    1\n    1\n    0    0    0\n    0    0    0    1    2\n    1\n    0    0    0\n    0    0    0    1    3\n    1\n    0    0    0\n    0    0    0    1    4\n    1\n    0    0    0\n    0    0    0    1    5\n    1\n    0    0    0\n    0    0    0    1    6\n    2\n    0   -1   -1\n    1   -1   -1\n    .\n    .\n    .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_qcdat","title":"<code>seedname_qc.dat</code>","text":"<p>OUTPUT. Written if <code>transport = .TRUE.</code>. The first line gives the date and time at which the file was created. In the subsequent lines, the energy value in units of eV is written in the left column, and the quantum conductance in units of \\(\\frac{2e^2}{h}\\) (\\(\\frac{e^2}{h}\\) for a spin-polarized system) is written in the right column.</p> Output file<pre><code> ## written on 14Dec2007 at 11:30:17\n   -3.000000       8.999999\n   -2.990000       8.999999\n   -2.980000       8.999999\n   -2.970000       8.999999\n    .\n    .\n    .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_dosdat","title":"<code>seedname_dos.dat</code>","text":"<p>OUTPUT. Written if <code>transport = .TRUE.</code>. The first line gives the date and time at which the file was created. In the subsequent lines, the energy value in units of eV is written in the left column, and the density of states in an arbitrary unit is written in the right column.</p> Output file<pre><code> ## written on 14Dec2007 at 11:30:17\n   -3.000000       6.801199\n   -2.990000       6.717692\n   -2.980000       6.640828\n   -2.970000       6.569910\n    .\n    .\n    .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_htbdat","title":"<code>seedname_htB.dat</code>","text":"<p>INPUT/OUTPUT. Read if <code>transport_mode = bulk</code> and <code>tran_read_ht = .TRUE.</code>. Written if <code>tran_write_ht = .TRUE.</code>. The first line gives the date and time at which the file was created. The second line gives <code>tran_num_bb</code>. The subsequent lines contain <code>tran_num_bb</code>\\(\\times\\)<code>tran_num_bb</code> \\(H_{mn}\\) matrix, where the indices \\(m\\) and \\(n\\) span all <code>tran_num_bb</code> WFs located at \\(0^{\\mathrm{th}}\\) principal layer. Then <code>tran_num_bb</code> is recorded again in the new line followed by \\(H_{mn}\\), where \\(m^{\\mathrm{th}}\\) WF is at \\(0^{\\mathrm{th}}\\) principal layer and \\(n^{\\mathrm{th}}\\) at \\(1^{\\mathrm{st}}\\) principal layer. The \\(H_{mn}\\) matrix is written in such a way that \\(m\\) is the fastest varying index.</p> Output file<pre><code> written on 14Dec2007 at 11:30:17\n   150\n   -1.737841   -2.941054    0.052673   -0.032926    0.010738   -0.009515\n    0.011737   -0.016325    0.051863   -0.170897   -2.170467    0.202254\n    .\n    .\n    .\n   -0.057064   -0.571967   -0.691431    0.015155   -0.007859    0.000474\n   -0.000107   -0.001141   -0.002126    0.019188   -0.686423  -10.379876\n   150\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000000\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000000\n    .\n    .\n    .\n    0.000000    0.000000    0.000000    0.000000    0.000000   -0.001576\n    0.000255   -0.000143   -0.001264    0.002278    0.000000    0.000000\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_htldat","title":"<code>seedname_htL.dat</code>","text":"<p>INPUT. Read if <code>transport_mode = lcr</code> and <code>tran_read_ht = .TRUE.</code>. The file must be written in the same way as in <code>seedname_htB.dat</code>. The first line can be any comment you want. The second line gives <code>tran_num_ll</code>. <code>tran_num_ll</code> in <code>seedname_htL.dat</code> must be equal to that in <code>seedname.win</code>. The code will stop otherwise.</p> Output file<pre><code> Created by a WANNIER user\n   105\n    0.316879    0.000000   -2.762434    0.048956    0.000000   -0.016639\n    0.000000    0.000000    0.000000    0.000000    0.000000   -2.809405\n    .\n    .\n    .\n    0.000000    0.078188    0.000000    0.000000   -2.086453   -0.001535\n    0.007878   -0.545485  -10.525435\n   105\n    0.000000    0.000000    0.000315   -0.000294    0.000000    0.000085\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000021\n    .\n    .\n    .\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000000\n    0.000000    0.000000    0.000000\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_htrdat","title":"<code>seedname_htR.dat</code>","text":"<p>INPUT. Read if <code>transport_mode = lcr</code> and <code>tran_read_ht = .TRUE.</code> and <code>tran_use_same_lead = .FALSE.</code>. The file must be written in the same way as in <code>seedname_htL.dat</code>. <code>tran_num_rr</code> in <code>seedname_htR.dat</code> must be equal to that in <code>seedname.win</code>.</p>"},{"location":"user_guide/wannier90/files/#seedname_htcdat","title":"<code>seedname_htC.dat</code>","text":"<p>INPUT. Read if <code>transport_mode = lcr</code> and <code>tran_read_ht = .TRUE.</code>. The first line can be any comment you want. The second line gives <code>tran_num_cc</code>. The subsequent lines contain <code>tran_num_cc</code>\\(\\times\\)<code>tran_num_cc</code> \\(H_{mn}\\) matrix, where the indices \\(m\\) and \\(n\\) span all <code>tran_num_cc</code> WFs inside the central conductor region. <code>tran_num_cc</code> in <code>seedname_htC.dat</code> must be equal to that in <code>seedname.win</code>.</p> Output file<pre><code> Created by a WANNIER user\n    99\n  -10.499455   -0.541232    0.007684   -0.001624   -2.067078   -0.412188\n    0.003217    0.076965    0.000522   -0.000414    0.000419   -2.122184\n    .\n    .\n    .\n   -0.003438    0.078545    0.024426    0.757343   -2.004899   -0.001632\n    0.007807   -0.542983  -10.516896\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_htlcdat","title":"<code>seedname_htLC.dat</code>","text":"<p>INPUT. Read if <code>transport_mode = lcr</code> and <code>tran_read_ht = .TRUE.</code>. The first line can be any comment you want. The second line gives <code>tran_num_ll</code> and <code>tran_num_lc</code> in the given order. The subsequent lines contain <code>tran_num_ll</code>\\(\\times\\)<code>tran_num_lc</code> \\(H_{mn}\\) matrix. The index \\(m\\) spans <code>tran_num_ll</code> WFs in the surface principal layer of semi-infinite left lead which is in contact with the conductor region. The index \\(n\\) spans <code>tran_num_lc</code> WFs in the conductor region which have a non-negligible interaction with the WFs in the semi-infinite left lead. Note that <code>tran_num_lc</code> can be different from <code>tran_num_cc</code>.</p> Output file<pre><code> Created by a WANNIER user\n   105    99\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000000\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000000\n    .\n    .\n    .\n   -0.000003    0.000009    0.000290    0.000001   -0.000007   -0.000008\n    0.000053   -0.000077   -0.000069\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_htcrdat","title":"<code>seedname_htCR.dat</code>","text":"<p>INPUT. Read if <code>transport_mode = lcr</code> and <code>tran_read_ht = .TRUE.</code>. The first line can be any comment you want. The second line gives <code>tran_num_cr</code> and <code>tran_num_rr</code> in the given order. The subsequent lines contain <code>tran_num_cr</code>\\(\\times\\)<code>tran_num_rr</code> \\(H_{mn}\\) matrix. The index \\(m\\) spans <code>tran_num_cr</code> WFs in the conductor region which have a non-negligible interaction with the WFs in the semi-infinite right lead. The index \\(n\\) spans <code>tran_num_rr</code> WFs in the surface principal layer of semi-infinite right lead which is in contact with the conductor region. Note that <code>tran_num_cr</code> can be different from <code>tran_num_cc</code>.</p> Output file<pre><code> Created by a WANNIER user\n    99   105\n   -0.000180    0.000023    0.000133   -0.000001    0.000194    0.000008\n   -0.000879   -0.000028    0.000672   -0.000257   -0.000102   -0.000029\n    .\n    .\n    .\n    0.000000    0.000000    0.000000    0.000000    0.000000    0.000000\n    0.000000    0.000000    0.000000\n</code></pre>"},{"location":"user_guide/wannier90/files/#seednameunkg","title":"<code>seedname.unkg</code>","text":"<p>INPUT. Read if <code>transport_mode = lcr</code> and <code>tran_read_ht = .FALSE.</code>. The first line is the number of G-vectors at which the \\(\\tilde{u}_{m\\mathbf{k}}(\\mathbf{G})\\) are subsequently printed. This number should always be 32 since 32 specific \\(\\tilde{u}_{m\\mathbf{k}}\\) are required. The following lines contain the following in this order: The band index \\(m\\), a counter on the number of G-vectors, the integer co-efficient of the G-vector components \\(a,b,c\\) (where \\(\\mathbf{G}=a\\mathbf{b}_1+b\\mathbf{b}_2+c\\mathbf{b}_3\\)), then the real and imaginary parts of the corresponding \\(\\tilde{u}_{m\\mathbf{k}}(\\mathbf{G})\\) at the \\(\\Gamma\\)-point. We note that the ordering in which the G-vectors and \\(\\tilde{u}_{m\\mathbf{k}}(\\mathbf{G})\\) are printed is not important, but the specific G-vectors are critical. The following example displays for a single band, the complete set of \\(\\tilde{u}_{m\\mathbf{k}}(\\mathbf{G})\\) that are required. Note the G-vectors (\\(a,b,c\\)) needed.</p> Output file<pre><code>      32\n    1    1    0    0    0   0.4023306   0.0000000\n    1    2    0    0    1  -0.0000325   0.0000000\n    1    3    0    1    0  -0.3043665   0.0000000\n    1    4    1    0    0  -0.3043665   0.0000000\n    1    5    2    0    0   0.1447143   0.0000000\n    1    6    1   -1    0   0.2345179   0.0000000\n    1    7    1    1    0   0.2345179   0.0000000\n    1    8    1    0   -1   0.0000246   0.0000000\n    1    9    1    0    1   0.0000246   0.0000000\n    1   10    0    2    0   0.1447143   0.0000000\n    1   11    0    1   -1   0.0000246   0.0000000\n    1   12    0    1    1   0.0000246   0.0000000\n    1   13    0    0    2   0.0000338   0.0000000\n    1   14    3    0    0  -0.0482918   0.0000000\n    1   15    2   -1    0  -0.1152414   0.0000000\n    1   16    2    1    0  -0.1152414   0.0000000\n    1   17    2    0   -1  -0.0000117   0.0000000\n    1   18    2    0    1  -0.0000117   0.0000000\n    1   19    1   -2    0  -0.1152414   0.0000000\n    1   20    1    2    0  -0.1152414   0.0000000\n    1   21    1   -1   -1  -0.0000190   0.0000000\n    1   22    1   -1    1  -0.0000190   0.0000000\n    1   23    1    1   -1  -0.0000190   0.0000000\n    1   24    1    1    1  -0.0000190   0.0000000\n    1   25    1    0   -2  -0.0000257   0.0000000\n    1   26    1    0    2  -0.0000257   0.0000000\n    1   27    0    3    0  -0.0482918   0.0000000\n    1   28    0    2   -1  -0.0000117   0.0000000\n    1   29    0    2    1  -0.0000117   0.0000000\n    1   30    0    1   -2  -0.0000257   0.0000000\n    1   31    0    1    2  -0.0000257   0.0000000\n    1   32    0    0    3   0.0000187   0.0000000\n    2    1    0    0    0  -0.0000461   0.0000000\n    .\n    .\n    .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_umat","title":"<code>seedname_u.mat</code>","text":"<p>OUTPUT. Written if <code>write_u_matrices = .TRUE.</code>. The first line gives the date and time at which the file was created. The second line states the number of kpoints <code>num_kpts</code> and the number of wannier functions <code>num_wann</code> twice. The third line is empty. Then there are <code>num_kpts</code> blocks of data, each of which starts with a line containing the kpoint (in fractional coordinates of the reciprocal lattice vectors) followed by <code>num_wann * num_wann</code> lines containing the matrix elements (real and imaginary parts) of \\(\\mathbf{U}^{(\\mathbf{k})}\\). The matrix elements are in column-major order (ie, cycling over rows first and then columns). There is an empty line between each block of data.</p> Output file<pre><code> written on 15Sep2016 at 16:33:46 \n           64           8           8\n\n   0.0000000000  +0.0000000000  +0.0000000000\n   0.4468355787  +0.1394579978\n  -0.0966033667  +0.4003934902\n  -0.0007748974  +0.0011788678\n  -0.0041177339  +0.0093821027\n   .\n   .\n   .\n\n   0.1250000000   0.0000000000  +0.0000000000\n   0.4694005589  +0.0364941808\n  +0.2287801742  -0.1135511138\n  -0.4776782452  -0.0511719121\n  +0.0142081014  +0.0006203139\n   .\n   .\n   .\n</code></pre>"},{"location":"user_guide/wannier90/files/#seedname_u_dismat","title":"<code>seedname_u_dis.mat</code>","text":"<p>OUTPUT. Written if <code>write_u_matrices = .TRUE.</code> and disentanglement is enabled. The first line gives the date and time at which the file was created. The second line states the number of kpoints <code>num_kpts</code>, the number of wannier functions <code>num_bands</code> and the number of <code>num_bands</code>. The third line is empty. Then there are <code>num_kpts</code> blocks of data, each of which starts with a line containing the kpoint (in fractional coordinates of the reciprocal lattice vectors) followed by <code>num_wann * num_bands</code> lines containing the matrix elements (real and imaginary parts) of \\(\\mathbf{U}^{\\mathrm{dis}(\\mathbf{k})}\\). The matrix elements are in column-major order (ie, cycling over rows first and then columns). There is an empty line between each block of data.</p> Output file<pre><code> written on 15Sep2016 at 16:33:46 \n           64           8          16\n\n   0.0000000000  +0.0000000000  +0.0000000000\n   1.0000000000  +0.0000000000\n  +0.0000000000  +0.0000000000\n  +0.0000000000  +0.0000000000\n  +0.0000000000  +0.0000000000\n   .\n   .\n   .\n\n   0.1250000000   0.0000000000  +0.0000000000\n   1.0000000000  +0.0000000000\n  +0.0000000000  +0.0000000000\n  +0.0000000000  +0.0000000000\n  +0.0000000000  +0.0000000000\n   .\n   .\n   .\n</code></pre> <ol> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9</p> </li> <li> <p>Runzhi Wang, Emanuel A. Lazar, Hyowon Park, Andrew J. Millis, and Chris A. Marianetti. Selectively localized wannier functions. Physical Review B, 10 2014. doi:10.1103/PhysRevB.90.165125.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/library_mode/","title":"<code>wannier90</code>\u00a0as a library","text":"<p>This is a description of the interface between any external program and the wannier code. There are two subroutines: <code>wannier_setup</code> and <code>wannier_run</code>. Calling <code>wannier_setup</code> will return information required to construct the \\(M_{mn}^{(\\mathbf{k,b})}\\) overlaps (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(25)) and \\(A_{mn}^{(\\mathbf{k})}=\\left\\langle   \\psi_{m\\mathbf{k}}|g_{n}\\right\\rangle\\) projections (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(62); Ref.\u00a0<sup>2</sup>, Eq.\u00a0(22)). Once the overlaps and projection have been computed, calling <code>wannier_run</code> activates the minimisation and plotting routines in <code>wannier90</code>.</p> <p>Warning</p> <p>The library mode ONLY works in serial. Please call it from a serial code, or if compiled in parallel, make sure to run it from a single MPI process.</p> <p>You can find a minimal example of how the library mode can be used among the tests, in the file <code>test-suite/library-mode-test/test_library.F90</code> in the Wannier90 git repository.</p>"},{"location":"user_guide/wannier90/library_mode/#subroutines","title":"Subroutines","text":""},{"location":"user_guide/wannier90/library_mode/#wannier_setup","title":"<code>wannier_setup</code>","text":"Fortran<pre><code>wannier_setup(seed_name,mp_grid,num_kpts,real_lattice,recip_lattice,\n              kpt_latt,num_bands_tot,num_atoms,atom_symbols,atoms_cart,\n              gamma_only,spinors,nntot,nnlist,nncell,num_bands,num_wann,proj_site,\n              proj_l,proj_m,proj_radial,proj_z,proj_x,proj_zona,\n              exclude_bands,proj_s,proj_s_qaxis)\n</code></pre> <p>Conditions:</p> <ul> <li> <p>\\(\\texttt{num_kpts} = \\texttt{mp_grid(1)} \\times \\texttt{mp_grid(2)}     \\times \\texttt{mp_grid(3)}\\).</p> </li> <li> <p>\\(\\texttt{num_nnmax} = 12\\)</p> </li> </ul> <p>This subroutine returns the information required to determine the required overlap elements \\(M_{mn}^{(\\mathbf{k,b})}\\) and projections \\(A_{mn}^{(\\mathbf{k})}\\), i.e., <code>M_matrix</code> and <code>A_matrix</code>, described in Section\u00a0<code>wannier_run</code>.</p> <p>For the avoidance of doubt, <code>real_lattice(1,2)</code> is the \\(y-\\)component of the first lattice vector \\(\\mathbf{A}_{1}\\), etc.</p> <p>The list of nearest neighbours of a particular k-point <code>nkp</code> is given by <code>nnlist(nkp,1:nntot)</code>.</p> <p>Additionally, the parameter <code>shell_list</code> may be specified in the <code>wannier90</code>\u00a0input file.</p>"},{"location":"user_guide/wannier90/library_mode/#wannier_run","title":"<code>wannier_run</code>","text":"Fortran<pre><code>wannier_run(seed_name,mp_grid,num_kpts,real_lattice,recip_lattice,\n            kpt_latt,num_bands,num_wann,nntot,num_atoms,atom_symbols,\n            atoms_cart,gamma_only,M_matrix_orig,A_matrix,eigenvalues,\n            U_matrix,U_matrix_opt,lwindow,wann_centres,wann_spreads,\n            spread)\n</code></pre> <ul> <li> <p><code>character(len=*), intent(in) :: seed_name</code>     The seedname of the current calculation.</p> </li> <li> <p><code>integer, dimension(3), intent(in) :: mp_grid</code>     The dimensions of the Monkhorst-Pack k-point grid.</p> </li> <li> <p><code>integer, intent(in) :: num_kpts</code>     The number of k-points on the Monkhorst-Pack grid.</p> </li> <li> <p><code>real(kind=dp), dimension(3,3),</code> <code>intent(in) :: real_lattice</code>     The lattice vectors in Cartesian co-ordinates in units of Angstrom.</p> </li> <li> <p><code>real(kind=dp), dimension(3,3), intent(in) :: recip_lattice</code>     The reciprical lattice vectors in Cartesian co-ordinates in units of     inverse Angstrom.</p> </li> <li> <p><code>real(kind=dp), dimension(3,num_kpts),</code> <code>intent(in) :: kpt_latt</code>     The positions of the k-points in fractional co-ordinates relative to     the reciprocal lattice vectors.</p> </li> <li> <p><code>integer, intent(in) :: num_bands</code>     The total number of bands to be processed.</p> </li> <li> <p><code>integer, intent(in) :: num_wann</code>     The number of MLWF to be extracted.</p> </li> <li> <p><code>integer, intent(in) :: nntot</code>     The number of nearest neighbours for each k-point.</p> </li> <li> <p><code>integer, intent(in) :: num_atoms</code>     The total number of atoms in the system.</p> </li> <li> <p><code>character(len=20), dimension(num_atoms),</code> <code>intent(in) :: atom_symbols</code>     The elemental symbols of the atoms.</p> </li> <li> <p><code>real(kind=dp), dimension(3,num_atoms),</code> <code>intent(in) :: atoms_cart</code>     The positions of the atoms in Cartesian co-ordinates in Angstrom.</p> </li> <li> <p><code>logical, intent(in) :: gamma_only</code>     Set to <code>.true.</code> if the underlying electronic structure calculation     has been performed with only \\(\\Gamma\\)-point sampling and, hence, if     the Bloch eigenstates that are used to construct     \\(A_{mn}^{(\\mathbf{k})}\\) and \\(M_{mn}^{\\mathbf{(k,b)}}\\) are real.</p> </li> <li> <p><code>complex(kind=dp),</code> <code>dimension(num_bands,num_bands,nntot,num_kpts),</code> <code>intent(in) :: M_matrix</code>     The matrices of overlaps between neighbouring periodic parts of the     Bloch eigenstates at each k-point, \\(M_{mn}^{(\\mathbf{(k,b)})}\\)     (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(25)).</p> </li> <li> <p><code>complex(kind=dp), dimension(num_bands,num_wann,num_kpts),</code> <code>intent(in) :: A_matrix</code>     The matrices describing the projection of <code>num_wann</code> trial orbitals     on <code>num_bands</code> Bloch states at each k-point, \\(A_{mn}^{(\\mathbf{k})}\\)     (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(62); Ref.\u00a0<sup>2</sup>, Eq.\u00a0(22)).</p> </li> <li> <p><code>real(kind=dp), dimension(num_bands,num_kpts),</code> <code>intent(in) :: eigenvalues</code>     The eigenvalues \\(\\varepsilon_{n\\mathbf{k}}\\) corresponding to the     eigenstates, in eV.</p> </li> <li> <p><code>complex(kind=dp), dimension(num_wann,num_wann,num_kpts),</code> <code>intent(out) :: U_matrix</code>     The unitary matrices at each k-point (Ref.\u00a0<sup>1</sup>,     Eq.\u00a0(59))</p> </li> <li> <p><code>complex(kind=dp), dimension(num_bands,num_wann,num_kpts),</code> <code>optional, intent(out) :: U_matrix_opt</code>     The unitary matrices that describe the optimal sub-space at each     k-point (see Ref.\u00a0<sup>2</sup>, Section\u00a0IIIa). The array is packed     (see below)</p> </li> <li> <p><code>logical, dimension(num_bands,num_kpts), optional, intent(out) :: lwindow</code>     The element <code>lwindow(nband,nkpt)</code> is <code>.true.</code> if the band <code>nband</code>     lies within the outer energy window at kpoint <code>nkpt</code>.</p> </li> <li> <p><code>real(kind=dp), dimension(3,num_wann), optional, intent(out) :: wann_centres</code>     The centres of the MLWF in Cartesian co-ordinates in Angstrom.</p> </li> <li> <p><code>real(kind=dp), dimension(num_wann), optional, intent(out) :: wann_spreads</code>     The spread of each MLWF in \u00c5\\(^{2}\\).</p> </li> <li> <p><code>real(kind=dp), dimension(3), optional, intent(out) ::</code> <code>spread</code>     The values of \\(\\Omega\\), \\(\\Omega_{\\mathrm{I}}\\) and \\(\\tilde{\\Omega}\\)     (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(13)).</p> </li> </ul> <p>Conditions:</p> <ul> <li> <p>\\(\\texttt{num_wann} \\le \\texttt{num_bands}\\)</p> </li> <li> <p>\\(\\texttt{num_kpts} = \\texttt{mp_grid(1)} \\times \\texttt{mp_grid(2)}     \\times \\texttt{mp_grid(3)}\\).</p> </li> </ul> <p>If \\(\\texttt{num_bands} = \\texttt{num_wann}\\) then <code>U_matrix_opt</code> is the identity matrix and <code>lwindow=.true.</code></p> <p>For the avoidance of doubt, <code>real_lattice(1,2)</code> is the \\(y-\\)component of the first lattice vector \\(\\mathbf{A}_{1}\\), etc.</p> \\[ \\begin{aligned} \\texttt{M_matrix(m,n,nn,nkp)} &amp; = \\left\\langle u_{m\\mathbf{k}} | u_{n\\mathbf{k+b}}\\right\\rangle\\\\ \\texttt{A_matrix(m,n,nkp)} &amp; = \\left\\langle \\psi_{m\\mathbf{k}}|g_{n}\\right\\rangle\\\\ \\texttt{eigenvalues(n,nkp)} &amp;= \\varepsilon_{n\\mathbf{k}} \\end{aligned} \\] <p>where</p> \\[ \\begin{aligned} \\mathbf{k} &amp;=\\texttt{kpt_latt(1:3,nkp)}\\\\ \\mathbf{k+b}&amp;= \\texttt{kpt_latt(1:3,nnlist(nkp,nn))} + \\texttt{nncell(1:3,nkp,nn)} \\end{aligned} \\] <p>and \\(\\left\\{|g_{n}\\rangle\\right\\}\\) are a set of initial trial orbitals. These are typically atom or bond-centred Gaussians that are modulated by appropriate spherical harmonics.</p> <p>Additional parameters should be specified in the <code>wannier90</code>\u00a0input file.</p> <ol> <li> <p>N. Marzari and D. Vanderbilt. Maximally localized generalized wannier functions for composite energy bands. Phys. Rev. B, 56:12847, 1997.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/methodology/","title":"Methodology","text":"<p><code>wannier90</code>\u00a0computes maximally-localised Wannier functions (MLWF) following the method of Marzari and Vanderbilt (MV)\u00a0<sup>1</sup>. For entangled energy bands, the method of Souza, Marzari and Vanderbilt (SMV)\u00a0<sup>2</sup> is used. We introduce briefly the methods and key definitions here, but full details can be found in the original papers and in Ref.\u00a0<sup>3</sup>.</p> <p>First-principles codes typically solve the electronic structure of periodic materials in terms of Bloch states, \\(\\psi_{n{\\bf k}}\\). These extended states are characterised by a band index \\(n\\) and crystal momentum \\({\\bf k}\\). An alternative representation can be given in terms of spatially localised functions known as Wannier functions (WF). The WF centred on a lattice site \\({\\bf R}\\), \\(w_{n{\\bf R}}({\\bf r})\\), is written in terms of the set of Bloch states as</p> \\[ \\begin{equation} w_{n{\\bf R}}({\\bf r})=\\frac{V}{(2\\pi)^3}\\int_{\\mathrm{BZ}} \\left[\\sum_{m} U^{({\\bf k})}_{mn} \\psi_{m{\\bf k}}({\\bf     r})\\right]e^{-\\mathrm{i}{\\bf k}.{\\bf R}} \\:\\mathrm{d}{\\bf k} \\ , \\end{equation} \\] <p>where \\(V\\) is the unit cell volume, the integral is over the Brillouin zone (BZ), and \\(\\mathbf{U}^{(\\mathbf{k})}\\) is a unitary matrix that mixes the Bloch states at each \\({\\bf k}\\). \\(\\mathbf{U}^{(\\mathbf{k})}\\) is not uniquely defined and different choices will lead to WF with varying spatial localisations. We define the spread \\(\\Omega\\) of the WF as</p> \\[ \\begin{equation} \\Omega=\\sum_n \\left[\\langle w_{n{\\bf 0}}({\\bf r})| r^2 | w_{n{\\bf       0}}({\\bf r}) \\rangle - | \\langle w_{n{\\bf 0}}({\\bf r})| {\\bf r}       | w_{n{\\bf 0}}({\\bf r}) \\rangle |^2 \\right]. \\end{equation} \\] <p>The total spread can be decomposed into a gauge invariant term \\(\\Omega_{\\rm I}\\) plus a term \\({\\tilde \\Omega}\\) that is dependant on the gauge choice \\(\\mathbf{U}^{(\\mathbf{k})}\\). \\({\\tilde \\Omega}\\) can be further divided into terms diagonal and off-diagonal in the WF basis, \\(\\Omega_{\\rm D}\\) and \\(\\Omega_{\\rm OD}\\),</p> \\[ \\begin{equation} \\Omega=\\Omega_{\\rm I}+{\\tilde \\Omega}=\\Omega_{\\rm I}+\\Omega_{\\rm   D}+\\Omega_{\\rm OD} \\end{equation} \\] <p>where</p> \\[ \\begin{equation} \\Omega_{{\\rm I}}=\\sum_n \\left[\\langle w_{n{\\bf 0}}({\\bf r})| r^2 | w_{n{\\bf       0}}({\\bf r}) \\rangle - \\sum_{{\\bf R}m} \\left| \\langle w_{m{\\bf       R}}({\\bf r})| {\\bf r} | w_{n{\\bf 0}}({\\bf r}) \\rangle \\right| ^2       \\right] \\end{equation} \\] \\[ \\begin{equation} \\Omega_{\\rm D}=\\sum_n \\sum_{{\\bf R}\\neq{\\bf 0}} |\\langle w_{n{\\bf     R}}({\\bf r})| {\\bf r} | w_{n{\\bf 0}}({\\bf r}) \\rangle|^2 \\end{equation} \\] \\[ \\begin{equation} \\Omega_{\\rm OD}=\\sum_{m\\neq n} \\sum_{{\\bf R}} |\\langle w_{m{\\bf R}}({\\bf   r})| {\\bf r} | w_{n{\\bf 0}}({\\bf r}) \\rangle |^2 \\end{equation} \\] <p>The MV method minimises the gauge dependent spread \\(\\tilde{\\Omega}\\) with respect the set of \\(\\mathbf{U}^{(\\mathbf{k})}\\) to obtain MLWF.</p> <p><code>wannier90</code>\u00a0requires two ingredients from an initial electronic structure calculation.</p> <ol> <li> <p>The overlaps between the cell periodic part of the Bloch states     \\(|u_{n{\\bf k}}\\rangle\\)</p> \\[ \\begin{equation} \\label{eq:overlap-matrix} M_{mn}^{(\\bf{k,b})}=\\langle u_{m{\\bf k}}|u_{n{\\bf k}+{\\bf b}}\\rangle, \\end{equation} \\] <p>where the vectors \\({\\bf b}\\), which connect a given k-point with its neighbours, are determined by <code>wannier90</code>\u00a0according to the prescription outlined in Ref.\u00a0<sup>1</sup>.</p> </li> <li> <p>As a starting guess the projection of the Bloch states     \\(|\\psi_{n\\bf{k}}\\rangle\\) onto trial localised orbitals     \\(|g_{n}\\rangle\\)</p> \\[ \\begin{equation} A_{mn}^{(\\bf{k})}=\\langle \\psi_{m{\\bf k}}|g_{n}\\rangle, \\end{equation} \\] </li> </ol> <p>Note that \\(\\mathbf{M}^{(\\mathbf{k},\\mathbf{b})}\\), \\(\\mathbf{A}^{(\\mathbf{k})}\\) and \\(\\mathbf{U}^{(\\mathbf{k})}\\) are all small, \\(N \\times N\\) matrices (see the following note) that are independent of the basis set used to obtain the original Bloch states.</p> <p>Note</p> <p>Technically, this is true for the case of an isolated group of \\(N\\) bands from which we obtain \\(N\\) MLWF. When using the disentanglement procedure of Ref.\u00a0<sup>2</sup>, \\(\\mathbf{A}^{(\\mathbf{k})}\\), for example, is a rectangular matrix. See Section\u00a0Entangled Energy Bands.</p> <p>To date, <code>wannier90</code>\u00a0has been used in combination with electronic codes based on plane-waves and pseudopotentials (norm-conserving and ultrasoft\u00a0<sup>4</sup>) as well as mixed basis set techniques such as FLAPW\u00a0<sup>5</sup>.</p>"},{"location":"user_guide/wannier90/methodology/#entangled-energy-bands","title":"Entangled Energy Bands","text":"<p>The above description is sufficient to obtain MLWF for an isolated set of bands, such as the valence states in an insulator. In order to obtain MLWF for entangled energy bands we use the \"disentanglement\" procedure introduced in Ref.\u00a0<sup>2</sup>.</p> <p>We define an energy window (the \"outer window\"). At a given k-point \\(\\bf{k}\\), \\(N^{({\\bf k})}_{{\\rm win}}\\) states lie within this energy window. We obtain a set of \\(N\\) Bloch states by performing a unitary transformation amongst the Bloch states which fall within the energy window at each k-point:</p> \\[ \\begin{equation} | u_{n{\\bf k}}^{{\\rm opt}}\\rangle = \\sum_{m\\in N^{({\\bf k})}_{{\\rm win}}} U^{{\\rm dis}({\\bf k})}_{mn} | u_{m{\\bf k}}\\rangle \\end{equation} \\] <p>where \\(\\bf{U}^{{\\rm dis}({\\bf k})}\\) is a rectangular \\(N^{({\\bf k})}_{{\\rm win}} \\times N\\) matrix (see the following note). The set of \\(\\bf{U}^{{\\rm dis}({\\bf k})}\\) are obtained by minimising the gauge invariant spread \\(\\Omega_{{\\rm I}}\\) within the outer energy window. The MV procedure can then be used to minimise \\(\\tilde{\\Omega}\\) and hence obtain MLWF for this optimal subspace.</p> <p>Note</p> <p>As \\({\\bf U}^{{\\rm dis}({\\bf k})}\\) is a rectangular matrix this is a unitary operation in the sense that \\(({\\bf U}^{{\\rm  dis}({\\bf k})})^{\\dagger}{\\bf U}^{{\\rm dis}({\\bf k})}={\\bf 1}_N\\).</p> <p>It should be noted that the energy bands of this optimal subspace may not correspond to any of the original energy bands (due to mixing between states). In order to preserve exactly the properties of a system in a given energy range (e.g., around the Fermi level) we introduce a second energy window. States lying within this inner, or \"frozen\", energy window are included unchanged in the optimal subspace.</p> <ol> <li> <p>N. Marzari and D. Vanderbilt. Maximally localized generalized wannier functions for composite energy bands. Phys. Rev. B, 56:12847, 1997.\u00a0\u21a9\u21a9</p> </li> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>A. A. Mostofi, J. R. Yates, Y.-S. Lee, I. Souza, D. Vanderbilt, and N. Marzari. Wannier90: a tool for obtaining maximally-localised wannier functions. Comput. Phys. Commun., 178:685, 2008.\u00a0\u21a9</p> </li> <li> <p>D. Vanderbilt. Phys. Rev. B, 41:7892, 1990.\u00a0\u21a9</p> </li> <li> <p>M. Posternak, A. Baldereschi, S. Massidda, and N. Marzari. Maximally localized wannier functions in antiferromagnetic mno within the flapw formalism. Phys. Rev. B, 65:184422, 2002.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/notes_interpolations/","title":"Some notes on the interpolation","text":"<p>In <code>wannier90</code> v.2.1, a new flag <code>use_ws_distance</code> has been introduced (and it is set to <code>.true.</code> by default since version v3.0). Setting it to <code>.false.</code> reproduces the \"standard\" behavior of <code>wannier90</code> in v.2.0.1 and earlier, while setting it to <code>.true.</code> changes the interpolation method as described below. In general, this allows a smoother interpolation, helps reducing (a bit) the number of \\(k-\\)points required for interpolation, and reproduces the band structure of large supercells sampled at \\(\\Gamma\\) only (setting it to <code>.false.</code> produces instead flat bands, which might instead be the intended behaviour for small molecules carefully placed at the centre of the cell).</p> <p>The core idea rests on the fact that the Wannier functions \\(w_{n\\mathrm{\\rm{R}}}(\\mathrm{\\rm{r}})\\) that we build from \\(N\\times M\\times L\\) \\(k-\\)points are actually periodic over a supercell of size \\(N\\times M\\times L\\), but when you use them to interpolate you want them to be zero outside this supercell. In 1D it is pretty obvious want we mean here, but in 3D what you really want that they are zero outside the Wigner--Seitz cell of the \\(N\\times M\\times L\\) superlattice.</p> <p>The best way to impose this condition is to check that every real-space distance that enters in the \\(R\\to k\\) Fourier transform is the shortest possible among all the \\(N\\times M\\times L-\\)periodic equivalent copies.</p> <p>If the distances were between unit cells, this would be trivial, but the distances are between Wannier functions which are not centred on \\(\\mathrm{\\rm{R}}=0\\). Hence, when you want to consider the matrix element of a generic operator \\(\\mathrm{\\rm{O}}\\) (i.e., the Hamiltonian) \\(\\langle w_{i\\mathrm{\\rm{0}}}(\\mathrm{\\rm{r}})|\\mathrm{\\rm{O}}|w_{j\\mathrm{\\rm{R}}}(\\mathrm{\\rm{r}})\\rangle\\) you must take in account that the centre \\(\\mathrm{\\rm{\\tau}}_i\\) of \\(w_{i\\mathrm{\\rm{0}}}(\\mathrm{\\rm{r}})\\) may be very far away from \\(\\mathrm{\\rm{0}}\\) and the centre \\(\\mathrm{\\rm{\\tau}}_j\\) of \\(w_{j\\mathrm{\\rm{R}}}(\\mathrm{\\rm{r}})\\) may be very far away from \\(\\mathrm{\\rm{R}}\\).</p> <p>There are many way to find the shortest possible distance between \\(w_{i\\mathrm{\\rm{0}}}(\\mathrm{\\rm{r}})\\) and \\(w_{j\\mathrm{\\rm{R}}}(\\mathrm{\\rm{r}}-\\mathrm{\\rm{R}})\\), the one used here is to consider the distance \\(\\mathrm{\\rm{d}}_{ij\\mathrm{\\rm{R}}} = \\mathrm{\\rm{\\tau}}_i - (\\mathrm{\\rm{\\tau}}_j+\\mathrm{\\rm{R}})\\) and all its superlattice periodic equivalents \\(\\mathrm{\\rm{d}}_{ij\\mathrm{\\rm{R}}}+ \\mathrm{\\rm{\\tilde R}}_{nml}\\), with \\(\\mathrm{\\rm{\\tilde R}}_{nml} = (Nn\\mathrm{\\rm{a}}_1 + Mm\\mathrm{\\rm{a}}_2 + Ll\\mathrm{\\rm{a}}_3)\\) and \\(n,l,m = {-L,-L+1,...0,...,L-1,L}\\), with \\(L\\) controlled by the parameter <code>ws_search_size</code>.</p> <p>Then,</p> <ol> <li> <p>if     \\(\\mathrm{\\rm{d}}_{ij\\mathrm{\\rm{R}}}+ \\mathrm{\\rm{\\tilde R}}_{nml}\\)     is inside the \\(N\\times M \\times L\\) super-WS cell, then it is the     shortest, take it and quit</p> </li> <li> <p>if it is outside the WS, then it is not the shortest, throw it away</p> </li> <li> <p>if it is on the border/corner of the WS then it is the shortest, but     there are other choices of \\((n,m,l)\\) which are equivalent, find all     of them</p> </li> </ol> <p>In all distance comparisons, a small but finite tolerance is considered, which can be controlled with the parameter <code>ws_distance_tol</code>.</p> <p>Because of how the Fourier transform is defined in the <code>wannier90</code> code (not the only possible choice) it is only \\(\\mathrm{\\rm{R}}+\\mathrm{\\rm{\\tilde R}}_{nml}\\) that enters the exponential, but you still have to consider the distance among the actual centres of the Wannier functions. Using the centres of the unit-cell to which the Wannier functions belong is not enough (but is easier, and saves you one index).</p> <p>Point 3 is not stricly necessary, but using it helps enforcing the symmetry of the system in the resulting band structure. You will get some small but evident symmetry breaking in the band plots if you just pick one of the equivalent \\(\\mathrm{\\rm{\\tilde R}}\\) vectors.</p> <p>Note that in some cases, all this procedure does absolutely nothing, for instance if all the Wannier function centres are very close to 0 (e.g., a molecule carefully placed in the periodic cell).</p> <p>In some other cases, the effect may exist but be imperceptible. E.g., if you use a very fine grid of \\(k-\\)points, even if you don't centre each functions perfectly, the periodic copies will still be so far away that the change in centre applied with \\(\\tt use\\_ws\\_distance\\) does not matter.</p> <p>When instead you use few \\(k-\\)points, activating the \\(\\tt use\\_ws\\_distance\\) may help a lot in avoiding spurious oscillations of the band structure even when the Wannier functions are well converged.</p>"},{"location":"user_guide/wannier90/parameters/","title":"Parameters","text":""},{"location":"user_guide/wannier90/parameters/#usage","title":"Usage","text":"<p><code>wannier90.x</code> can be run in parallel using MPI libraries to reduce the computation time.</p> <p>For serial execution use: <code>wannier90.x [-pp] [seedname]</code></p> <ul> <li> <p><code>seedname</code>: If a seedname string is given the code will read its     input from a file <code>seedname.win</code>. The default value is <code>wannier</code>.     One can also equivalently provide the string <code>seedname.win</code> instead     of <code>seedname</code>.</p> </li> <li> <p><code>-pp</code>: This optional flag tells the code to generate a list of the     required overlaps and then exit. This information is written to the     file <code>seedname.nnkp</code>.</p> </li> </ul> <p>For parallel execution use: <code>mpirun -np NUMPROCS wannier90.x [-pp] [seedname]</code></p> <ul> <li><code>NUMPROCS</code>: substitute with the number of processors that you want     to use.</li> </ul> <p>Note that the <code>mpirun</code> command and command-line flags may be different in your MPI implementation: read your MPI manual or ask your computer administrator.</p> <p>Note also that this requires that the <code>wannier90.x</code> executable has been compiled in its parallel version (follow the instructions in the file <code>README.install</code> in the main directory of the <code>wannier90</code> distribution) and that the MPI libraries and binaries are installed and correctly configured on your machine.</p>"},{"location":"user_guide/wannier90/parameters/#seednamewin-file","title":"<code>seedname.win</code> File","text":"<p>The <code>wannier90</code>\u00a0input file <code>seedname.win</code> has a flexible free-form structure.</p> <p>The ordering of the keywords is not significant. Case is ignored (so <code>num_bands</code> is the same as <code>Num_Bands</code>). Characters after !, or # are treated as comments. Most keywords have a default value that is used unless the keyword is given in <code>seedname.win</code>. Keywords can be set in any of the following ways</p> Input file<pre><code>num_wann 4\nnum_wann = 4\nnum_wann : 4\n</code></pre> <p>A logical keyword can be set to <code>true</code> using any of the following strings: <code>T</code>, <code>true</code>, <code>.true.</code>.</p> <p>For further examples see Section Master input file: <code>seedname.win</code> and the the <code>wannier90</code>\u00a0Tutorial.</p>"},{"location":"user_guide/wannier90/parameters/#keyword-list","title":"Keyword List","text":""},{"location":"user_guide/wannier90/parameters/#system-parameters","title":"System Parameters","text":"Keyword Type Description num_wann I Number of WF num_bands I Number of bands passed to the code unit_cell_cart P Unit cell vectors in Cartesian coordinates atoms_cart * P Positions of atoms in Cartesian coordinates atoms_frac * R Positions of atoms in fractional coordinates with respect to the lattice vectors mp_grid I Dimensions of the Monkhorst-Pack grid of k-points kpoints R List of k-points in the Monkhorst-Pack grid gamma_only L Wavefunctions from underlying ab initio calculation are manifestly real spinors L WF are spinors shell_list I Which shells to use in finite difference formula search_shells I The number of shells to search when determining finite difference formula skip_B1_tests L Check the condition B1 of Ref <sup>1</sup>.\u00a0 nnkpts I Explicit list of nearest-neighbour k-points. kmesh_tol R The tolerance to control if two kpoint belong to the same shell <p><code>seedname.win</code> file keywords defining the system. Argument types are represented by, I for a integer, R for a real number, P for a physical value, L for a logical value and S for a text string. * <code>atoms_cart</code> and <code>atoms_frac</code> may not both be defined in the same input file.</p>"},{"location":"user_guide/wannier90/parameters/#job-control-parameters","title":"Job Control Parameters","text":"Keyword Type Description postproc_setup L To output the <code>seedname.nnkp</code> file exclude_bands I List of bands to exclude from the calculation select_projections I List of projections to use in Wannierisation auto_projections L To automatically generate initial projections restart S Restart from checkpoint file iprint I Output verbosity level length_unit S System of units to output lengths wvfn_formatted L Read the wavefunctions from a (un)formatted file spin S Which spin channel to read devel_flag S Flag for development use timing_level I Determines amount of timing information written to output optimisation I Optimisation level translate_home_cell L To translate final Wannier centres to home unit cell when writing xyz file write_xyz L To write atomic positions and final centres in xyz file format write_vdw_data L To write data for futher processing by w90vdw utility write_hr_diag L To write the diagonal elements of the Hamiltonian in the Wannier basis to <code>seedname.wout</code> (in eV) <p><code>seedname.win</code> file keywords defining job control. Argument types are represented by, I for a integer, R for a real number, P for a physical value, L for a logical value and S for a text string. translate_home_cell only relevant if <code>write_xyz</code> is <code>.true.</code></p>"},{"location":"user_guide/wannier90/parameters/#disentanglement-parameters","title":"Disentanglement Parameters","text":"Keyword Type Description dis_win_min P Bottom of the outer energy window dis_win_max P Top of the outer energy window dis_froz_min P Bottom of the inner (frozen) energy window dis_froz_max P Top of the inner (frozen) energy window dis_num_iter I Number of iterations for the minimisation of \\(\\Omega_{\\mathrm{I}}\\) dis_mix_ratio R Mixing ratio during the minimisation of \\(\\Omega_{\\mathrm{I}}\\) dis_conv_tol R The convergence tolerance for finding \\(\\Omega_{\\mathrm{I}}\\) dis_conv_window I The number of iterations over which convergence of \\(\\Omega_{\\mathrm{I}}\\) is assessed. dis_spheres_num I Number of spheres in k-space where disentaglement is performed dis_spheres_first_wann I Index of the first band to be considered a Wannier function dis_spheres R List of centres and radii, for disentanglement only in spheres <p><code>seedname.win</code> file keywords controlling the disentanglement. Argument types are represented by, I for a integer, R for a real number, P for a physical value, L for a logical value and S for a text string.</p>"},{"location":"user_guide/wannier90/parameters/#wannierise-parameters","title":"Wannierise Parameters","text":"Keyword Type Description num_iter I Number of iterations for the minimisation of \\(\\Omega\\) num_cg_steps I During the minimisation of \\(\\Omega\\) the number of Conjugate Gradient steps before resetting to Steepest Descents conv_window I The number of iterations over which convergence of \\(\\Omega\\) is assessed conv_tol P The convergence tolerance for finding \\(\\Omega\\) precond L Use preconditioning conv_noise_amp R The amplitude of random noise applied towards end of minimisation procedure conv_noise_num I The number of times random noise is applied num_dump_cycles I Control frequency of check-pointing num_print_cycles I Control frequency of printing write_r2mn L Write matrix elements of \\(r^2\\) between WF to file guiding_centres L Use guiding centres num_guide_cycles I Frequency of guiding centres num_no_guide_iter I The number of iterations after which guiding centres are used trial_step * R The trial step length for the parabolic line search during the minimisation of \\(\\Omega\\) fixed_step * R The fixed step length to take during the minimisation of \\(\\Omega\\), instead of doing a parabolic line search use_bloch_phases ** L To use phases for initial projections site_symmetry*** L To construct symmetry-adapted Wannier functions symmetrize_eps*** R The convergence tolerance used in the symmetry-adapted mode slwf_num I The number of objective WFs for selective localization slwf_constrain L Whether to constrain the centres of the objective WFs slwf_lambda R Value of the Lagrange multiplier for constraining the objective WFs slwf_centres P The centres to which the objective WFs are to be constrained <p><code>seedname.win</code> file keywords controlling the wannierisation. Argument types are represented by, I for a integer, R for a real number, P for a physical value, L for a logical value and S for a text string. * <code>fixed_step</code> and <code>trial_step</code> may not both be defined in the same input file. **Cannot be used in conjunction with disentanglement. ***Cannot be used in conjunction with the inner (frozen) energy window.</p>"},{"location":"user_guide/wannier90/parameters/#plot-parameters","title":"Plot Parameters","text":"Keyword Type Description wannier_plot L Plot the WF wannier_plot_list I List of WF to plot wannier_plot_supercell I Size of the supercell for plotting the WF wannier_plot_format S File format in which to plot the WF wannier_plot_mode S Mode in which to plot the WF, molecule or crystal wannier_plot_radius R Cut-off radius of WF* wannier_plot_scale R Scaling parameter for cube files wannier_plot_spinor_mode S Quantity to plot for spinor WF wannier_plot_spinor_phase L Include the \u201cphase\u201d when plotting spinor WF bands_plot L Plot interpolated band structure kpoint_path P K-point path for the interpolated band structure bands_num_points I Number of points along the first section of the k-point path bands_plot_format S File format in which to plot the interpolated bands bands_plot_project I WF to project the band structure onto bands_plot_mode S Slater-Koster type interpolation or Hamiltonian cut-off bands_plot_dim I Dimension of the system fermi_surface_plot L Plot the Fermi surface fermi_surface_num_points I Number of points in the Fermi surface plot fermi_energy P The Fermi energy fermi_energy_min P Lower limit of the Fermi energy range fermi_energy_max P Upper limit of the Fermi energy range fermi_energy_step R Step for increasing the Fermi energy in the specified range fermi_surface_plot_format S File format for the Fermi surface plot hr_plot L This parameter is not used anymore. Use write_hr instead. write_hr L Write the Hamiltonian in the WF basis write_rmn L Write the position operator in the WF basis write_bvec L Write to file the matrix elements of the bvectors and their weights write_tb L Write lattice vectors, Hamiltonian, and position operator in WF basis hr_cutoff P Cut-off for the absolute value of the Hamiltonian dist_cutoff P Cut-off for the distance between WF dist_cutoff_mode S Dimension in which the distance between WF is calculated translation_centre_frac R Centre of the unit cell to which final WF are translated use_ws_distance L Improve interpolation using minimum distance between WFs, see Chap. Some notes on the interpolation ws_distance_tol R Absolute tolerance for the distance to equivalent positions. ws_search_size I Maximum extension in each direction of the super-cell of the Born-von Karmann cell to search for points inside the Wigner-Seitz cell write_u_matrices L Write \\(U^{(\\bm{k})}\\) and \\(U^{dis(\\bm{k})}\\) matrices to files <p><code>seedname.win</code> file keywords controlling the plotting. Argument types are represented by, I for a integer, R for a real number, P for a physical value, L for a logical value and S for a text string. * Only applies when <code>wannier_plot_format</code> is <code>cube</code>.</p>"},{"location":"user_guide/wannier90/parameters/#transport-parameters","title":"Transport Parameters","text":"Keyword Type Description transport L Calculate quantum conductance and density of states transport_mode S Bulk or left-lead_conductor_right-lead calculation tran_win_min P Bottom of the energy window for transport calculation tran_win_max P Top of the energy window for transport calculation tran_energy_step R Sampling interval of the energy values fermi_energy R The Fermi energy tran_num_bb I Size of a bulk Hamiltonian tran_num_ll I Size of a left-lead Hamiltonian tran_num_rr I Size of a right-lead Hamiltonian tran_num_cc I Size of a conductor Hamiltonian tran_num_lc I Number of columns in a left-lead_conductor Hamiltonian tran_num_cr I Number of rows in a conductor_right-lead Hamiltonian tran_num_cell_ll I Number of unit cells in PL of left lead tran_num_cell_rr I Number of unit cells in PL of right lead tran_num_bandc I Half-bandwidth+1 of a band-diagonal conductor Hamiltonian tran_write_ht L Write the Hamiltonian for transport calculation tran_read_ht L Read the Hamiltonian for transport calculation tran_use_same_lead L Left and right leads are the same tran_group_threshold R Distance that determines the grouping of WFs hr_cutoff P Cut-off for the absolute value of the Hamiltonian dist_cutoff P Cut-off for the distance between WF dist_cutoff_mode S Dimension in which the distance between WF is calculated one_dim_axis S Extended direction for a one-dimensional system translation_centre_frac R Centre of the unit cell to which final WF are translated <p><code>seedname.win</code> file keywords controlling transport. Argument types are represented by, I for a integer, R for a real number, P for a physical value, L for a logical value and S for a text string.</p>"},{"location":"user_guide/wannier90/parameters/#system","title":"System","text":""},{"location":"user_guide/wannier90/parameters/#integer-num_wann","title":"<code>integer :: num_wann</code>","text":"<p>Number of WF to be found.</p> <p>No default.</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_bands","title":"<code>integer :: num_bands</code>","text":"<p>Total number of bands passed to the code in the <code>seedname.mmn</code> file.</p> <p>Default <code>num_bands</code>=<code>num_wann</code></p>"},{"location":"user_guide/wannier90/parameters/#cell-lattice-vectors","title":"Cell Lattice Vectors","text":"<p>The cell lattice vectors should be specified in Cartesian coordinates.</p> Input file<pre><code>begin unit_cell_cart\n[units]\n</code></pre> \\[\\begin{array}{ccc} A_{1x} &amp; A_{1y} &amp; A_{1z} \\\\ A_{2x} &amp; A_{2y} &amp; A_{2z} \\\\ A_{3x} &amp; A_{3y} &amp; A_{3z} \\end{array}\\] Input file<pre><code>end unit_cell_cart\n</code></pre> <p>Here \\(A_{1x}\\) is the \\(x\\)-component of the first lattice vector \\(\\mathbf{A}_1\\), \\(A_{2y}\\) is the \\(y\\)-component of the second lattice vector \\(\\mathbf{A}_2\\), etc.</p> <p><code>[units]</code> specifies the units in which the lattice vectors are defined: either <code>Bohr</code> or <code>Ang</code>.</p> <p>The default value is <code>Ang</code>.</p>"},{"location":"user_guide/wannier90/parameters/#ionic-positions","title":"Ionic Positions","text":"<p>The ionic positions may be specified in fractional coordinates relative to the lattice vectors of the unit cell, or in absolute Cartesian coordinates. Only one of <code>atoms_cart</code> and <code>atoms_frac</code> may be given in the input file.</p>"},{"location":"user_guide/wannier90/parameters/#cartesian-coordinates","title":"Cartesian coordinates","text":"Input file<pre><code>begin atoms_cart\n[units]\n</code></pre> \\[\\begin{array}{cccc} P  &amp; R^{P}_{x} &amp; R^{P}_{y} &amp; R^{P}_{z} \\\\ Q  &amp; R^{Q}_{x} &amp; R^{Q}_{y} &amp; R^{Q}_{z} \\\\ \\vdots \\end{array}\\] Input file<pre><code>end atoms_cart\n</code></pre> <p>The first entry on a line is the atomic symbol. The next three entries are the atom's position \\(\\mathbf{R}=(R_x , R_y, R_z)\\) in Cartesian coordinates. The first line of the block, <code>[units]</code>, specifies the units in which the coordinates are given and can be either <code>bohr</code> or <code>ang</code>. If not present, the default is <code>ang</code>.</p>"},{"location":"user_guide/wannier90/parameters/#fractional-coordinates","title":"Fractional coordinates","text":"Input file<pre><code>begin atoms_frac\n</code></pre> \\[\\begin{array}{cccc} P  &amp; F^{P}_{1} &amp; F^{P}_{2} &amp; F^{P}_{3} \\\\ Q  &amp; F^{Q}_{1} &amp; F^{Q}_{2} &amp; F^{Q}_{3} \\\\ \\vdots \\end{array}\\] Input file<pre><code>end atoms_frac\n</code></pre> <p>The first entry on a line is the atomic symbol. The next three entries are the atom's position in fractional coordinates \\(\\mathbf{F} = F_1 \\mathbf{A}_{1} + F_2 \\mathbf{A}_{2} + F_3 \\mathbf{A}_{3}\\) relative to the cell lattice vectors \\(\\mathbf{A}_i\\), \\(i\\in [1,3]\\).</p>"},{"location":"user_guide/wannier90/parameters/#integer-dimension-mp_grid3","title":"<code>integer, dimension :: mp_grid(3)</code>","text":"<p>Dimensions of the regular (Monkhorst-Pack) k-point mesh. For example, for a \\(2\\times2\\times2\\) grid:</p> Input file<pre><code>mp_grid : 2  2  2\n</code></pre> <p>No default.</p>"},{"location":"user_guide/wannier90/parameters/#k-points","title":"K-points","text":"<p>Each line gives the coordinate \\(\\mathbf{K}=K_1 \\mathbf{B}_{1} + K_2 \\mathbf{B}_{2} + K_3 \\mathbf{B}_3\\) of a k-point in relative (crystallographic) units, i.e., in fractional units with respect to the primitive reciprocal lattice vectors \\(\\mathbf{B}_{i}\\), \\(i \\in [1,3]\\). The position of each k-point in this list assigns its numbering; the first k-point is k-point 1, the second is k-point 2, and so on.</p> Input file<pre><code>begin kpoints\n</code></pre> \\[\\begin{array}{ccc}  K^{1}_{1} &amp; K^{1}_{2} &amp; K^{1}_{3} \\\\  K^{2}_{1} &amp; K^{2}_{2} &amp; K^{2}_{3} \\\\ \\vdots \\end{array}\\] Input file<pre><code>end kpoints\n</code></pre> <p>There is no default.</p> <p>Note</p> <p>There is an utility provided with <code>wannier90</code>, called <code>kmesh.pl</code>, which helps to generate the explicit list of \\(k\\) points required by <code>wannier90</code>. See Sec.\u00a0<code>kmesh.pl</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-gamma_only","title":"<code>logical :: gamma_only</code>","text":"<p>If <code>gamma_only=true</code>, then <code>wannier90</code>\u00a0uses a branch of algorithms for disentanglement and localisation that exploit the fact that the Bloch eigenstates obtained from the underlying ab initio calculation are manifestly real. This can be the case when only the \\(\\Gamma\\)-point is used to sample the Brillouin zone. The localisation procedure that is used in the \\(\\Gamma\\)-only branch is based on the method of Ref.\u00a0<sup>2</sup>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-spinors","title":"<code>logical :: spinors</code>","text":"<p>If <code>spinors=true</code>, then <code>wannier90</code>\u00a0assumes that the WF correspond to singularly occupied spinor states and <code>num_elec_per_state=1</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#shells","title":"Shells","text":"<p>The MV scheme requires a finite difference expression for \\(\\nabla_{\\bf k}\\) defined on a uniform Monkhorst-Pack mesh of k-points. The vectors \\(\\{{\\bf b}\\}\\) connect each mesh-point \\({\\bf k}\\) to its nearest neighbours. \\(N_{\\mathrm{sh}}\\) shells of neighbours are included in the finite-difference formula, with \\(M_s\\) vectors in the \\(s^{\\mathrm{th}}\\) shell. For \\(\\nabla_{{\\bf k}}\\) to be correct to linear order, we require that the following equation is satisfied (Eq.\u00a0B1 of Ref.\u00a0<sup>1</sup>):</p> \\[ \\begin{equation} \\label{eq:B1} \\sum_{s}^{N_{\\mathrm{sh}}} w_s \\sum_i^{M_{\\mathrm{s}}} b_{\\alpha}^{i,s} b_{\\beta}^{i,s} = \\delta_{\\alpha\\beta}\\:, \\end{equation} \\] <p>where \\({\\bf b}^{i,s}\\), \\(i\\in[1,M_s]\\), is the \\(i^{\\mathrm{th}}\\) vector belonging to the \\(s^{\\mathrm{th}}\\) shell with associated weight \\(w_s\\), and \\(\\alpha\\) and \\(\\beta\\) run over the three Cartesian indices.</p>"},{"location":"user_guide/wannier90/parameters/#integer-shell_list","title":"<code>integer :: shell_list(:)</code>","text":"<p><code>shell_list</code> is vector listing the shells to include in the finite difference expression. If this keyword is absent, the shells are chosen automatically.</p>"},{"location":"user_guide/wannier90/parameters/#integer-search_shells","title":"<code>integer :: search_shells</code>","text":"<p>Specifies the number of shells of neighbours over which to search in attempting to determine an automatic solution to the B1 condition Eq.\u00a0\\(\\eqref{eq:B1}\\). Larger values than the default may be required in special cases e.g. for very long thin unit cells.</p> <p>The default value is 36.</p>"},{"location":"user_guide/wannier90/parameters/#logical-skip_b1_tests","title":"<code>logical :: skip_B1_tests</code>","text":"<p>If set to <code>.true.</code>, does not check the B1 condition Eq.\u00a0\\(\\eqref{eq:B1}\\). This should only be used if one knows why the B1 condition should not be verified. A typical use of this flag is in conjunction with the Z2PACK code: https://z2pack.greschd.ch/en/latest/.</p> <p>The default value is <code>.false.</code>.</p>"},{"location":"user_guide/wannier90/parameters/#integer-dimension-5-nnkpts","title":"<code>integer, dimension(:, 5) :: nnkpts</code>","text":"<p>Specifies the nearest-neighbour k-points which are written to the <code>.nnkp</code> file. This can be used to explicitly specify which overlap matrices should be calculated.</p> Input file<pre><code>begin nnkpts\n1   2   0  0  0\n.\n.\nend nnkpts\n</code></pre> <p>Each nearest neighbour \\(\\mathbf{k + b}\\) is given by a line of 5 integers. The first specifies the k-point number <code>nkp</code> of \\(\\mathbf{k}\\). The second is the k-point number of the neighbour. The final three integers specify the reciprocal lattice vector which brings the k-point specified by the second integer to \\(\\mathbf{k + b}\\).</p> <p>This format is the same as in the <code>.nnkp</code> file, except that the number of neighbours per k-point is not specified. However, the number of neighbours still needs to be a multiple of the number of k-points.</p> <p>This input parameter can be used only if <code>postproc_setup = .true.</code>, and is not intended to be used with a full Wannier90 run. It can be used also if the k-points do not describe a regular mesh.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-kmesh_tol","title":"<code>real(kind=dp) :: kmesh_tol</code>","text":"<p>Two kpoints belong to the same shell if the distance between them is less than <code>kmesh_tol</code>. Units are Ang.</p> <p>The default value is 0.000001 Ang.</p>"},{"location":"user_guide/wannier90/parameters/#projection","title":"Projection","text":"<p>The projections block defines a set of localised functions used to generate an initial guess for the unitary transformations. This data will be written in the <code>seedname.nnkp</code> file to be used by a first-principles code.</p> Input file<pre><code>begin projections\n.  \n.  \nend projections\n</code></pre> <p>If <code>guiding_centres</code>=<code>true</code>, then the projection centres are used as the guiding centres in the Wannierisation routine.</p> <p>For details see Section\u00a0Specification of projections in <code>seedname.win</code>.</p>"},{"location":"user_guide/wannier90/parameters/#job-control","title":"Job Control","text":""},{"location":"user_guide/wannier90/parameters/#logical-postproc_setup","title":"<code>logical :: postproc_setup</code>","text":"<p>If <code>postproc_setup</code>=<code>true</code>, then the wannier code will write <code>seedname.nnkp</code> file and exit. If <code>wannier90</code>\u00a0is called with the option <code>-pp</code>, then <code>postproc_setup</code> is set to <code>true</code>, over-riding its value in the <code>seedname.win</code> file.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#integer-iprint","title":"<code>integer :: iprint</code>","text":"<p>This indicates the level of verbosity of the output from 0 (\"low\"), the bare minimum, to 3 (\"high\"), which corresponds to full debugging output.</p> <p>The default value is 1.</p>"},{"location":"user_guide/wannier90/parameters/#integer-optimisation","title":"<code>integer :: optimisation</code>","text":"<p>This indicates the level of optimisation used in the code. This is a trade between speed and memory. A positive number indicates fastest execution time at the cost of more memory. Zero or negative numbers indicates a smaller memory footprint - at increased execution time.</p> <p>At the moment the only values that have an effect are <code>optimisation&lt;=0</code> (low memory) and <code>optimisation&gt;0</code> (fast)</p> <p>The default value is 3.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-length_unit","title":"<code>character(len=20) :: length_unit</code>","text":"<p>The length unit to be used for writing quantities in the output file <code>seedname.wout</code>.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>Ang</code> (default)</p> </li> <li> <p><code>Bohr</code></p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#characterlen50-devel_flag","title":"<code>character(len=50) :: devel_flag</code>","text":"<p>Not a regular keyword. Its purpose is to allow a developer to pass a string into the code to be used inside a new routine as it is developed.</p> <p>No default.</p>"},{"location":"user_guide/wannier90/parameters/#integer-exclude_bands","title":"<code>integer :: exclude_bands(:)</code>","text":"<p>A k-point independent list of states to excluded from the calculation of the overlap matrices; for example to select only valence states, or ignore semi-core states. This keyword is passed to the first-principles code via the <code>seedname.nnkp</code> file. For example, to exclude bands 2, 6, 7, 8 and 12:</p> <p><code>exclude_bands : 2, 6-8, 12</code></p>"},{"location":"user_guide/wannier90/parameters/#integer-select_projections","title":"<code>integer :: select_projections(:)</code>","text":"<p>A list of projections to be included in the wannierisation procedure. In the case that <code>num_proj</code> is greater than <code>num_wann</code>, this keyword allows a subset of the projections in the projection matrices to be used. For example, to select the projections given by the indices 2, 6, 7, 8 and 12:</p> <p><code>select_projections : 2, 6-8, 12</code></p>"},{"location":"user_guide/wannier90/parameters/#logical-auto_projections","title":"<code>logical :: auto_projections</code>","text":"<p>If <code>.true.</code> and no projections block is defined, then <code>wannier90</code>\u00a0writes an additional block in the <code>.nnkp</code> file during the pre-processing step, to instruct the interface code to automatically generate the \\(A_{mn}^{(\\mathbf{k})}\\).</p> <p>For additional information on the behavior and on the added block, see Sec.\u00a0<code>auto_projections</code> block.</p> <p>Note</p> <p>the interface code (e.g. <code>pw2wannier90.x</code>) must have at least one implementation of a method to automatically generate initial projections in order for this option to be usable.</p> <p>The default value of this parameter is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-restart","title":"<code>character(len=20) :: restart</code>","text":"<p>If <code>restart</code> is present the code will attempt to restart the calculation from the <code>seedname.chk</code> file. The value of the parameter determines the position of the restart</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>default</code>. Restart from the point at which the check file     <code>seedname.chk</code> was written</p> </li> <li> <p><code>wannierise</code>. Restart from the beginning of the wannierise routine</p> </li> <li> <p><code>plot</code>. Go directly to the plotting phase</p> </li> <li> <p><code>transport</code>. Go directly to the transport routines</p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#characterlen20-wvfn_formatted","title":"<code>character(len=20) :: wvfn_formatted</code>","text":"<p>If <code>wvfn_formatted</code>=<code>true</code>, then the wavefunctions will be read from disk as formatted (ie ASCII) files; otherwise they will be read as unformatted files. Unformatted is generally preferable as the files will take less disk space and I/O is significantly faster. However such files will not be transferable between all machine architectures and formatted files should be used if transferability is required (i.e., for test cases).</p> <p>The default value of this parameter is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-spin","title":"<code>character(len=20) :: spin</code>","text":"<p>For bands from a spin polarised calculation <code>spin</code> determines which set of bands to read in, either <code>up</code> or <code>down</code>.</p> <p>The default value of this parameter is <code>up</code>.</p>"},{"location":"user_guide/wannier90/parameters/#integer-timing_level","title":"<code>integer :: timing_level</code>","text":"<p>Determines the amount of timing information regarding the calculation that will be written to the output file. A value of 1 produces the least information.</p> <p>The default value is 1.</p>"},{"location":"user_guide/wannier90/parameters/#logical-translate_home_cell","title":"<code>logical :: translate_home_cell</code>","text":"<p>Determines whether to translate the final Wannier centres to the home unit cell at the end of the calculation. Mainly useful for molecular systems in which the molecule resides entirely within the home unit cell and user wants to write an xyz file (<code>write_xyz=.true.</code>) for the WF centres to compare with the structure.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_xyz","title":"<code>logical :: write_xyz</code>","text":"<p>Determines whether to write the atomic positions and final Wannier centres to an xyz file, <code>seedname_centres.xyz</code>, for subsequent visualisation.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_vdw_data","title":"<code>logical :: write_vdw_data</code>","text":"<p>Determines whether to write <code>seedname.vdw</code> for subsequent post-processing by the <code>w90vdw</code> utility (in the <code>utility/w90vdw/</code> directory of the distribution) for calculating van der Waals energies. Brillouin zone sampling must be at the Gamma-point only.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#disentanglement","title":"Disentanglement","text":"<p>These keywords control the disentanglement routine of Ref.\u00a0<sup>3</sup>, i.e., the iterative minimisation of \\(\\Omega_{\\mathrm{I}}\\). This routine will be activated if <code>num_wann</code>\\(\\:&lt;\\:\\)<code>num_bands</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_win_min","title":"<code>real(kind=dp) :: dis_win_min</code>","text":"<p>The lower bound of the outer energy window for the disentanglement procedure. Units are eV.</p> <p>The default is the lowest eigenvalue in the system.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_win_max","title":"<code>real(kind=dp) :: dis_win_max</code>","text":"<p>The upper bound of the outer energy window for the disentanglement procedure. Units are eV.</p> <p>The default is the highest eigenvalue in the given states (i.e., all states are included in the disentanglement procedure).</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_froz_min","title":"<code>real(kind=dp) :: dis_froz_min</code>","text":"<p>The lower bound of the inner energy window for the disentanglement procedure. Units are eV.</p> <p>If <code>dis_froz_max</code> is given, then the default for <code>dis_froz_min</code> is <code>dis_win_min</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_froz_max","title":"<code>real(kind=dp) :: dis_froz_max</code>","text":"<p>The upper bound of the inner (frozen) energy window for the disentanglement procedure. If <code>dis_froz_max</code> is not specified, then there are no frozen states. Units are eV.</p> <p>No default.</p>"},{"location":"user_guide/wannier90/parameters/#logical-dis_froz_proj","title":"<code>logical :: dis_froz_proj</code>","text":"<p>To activate projectability disentanglement procedure, which selectively discard/disentangle/freeze state \\(\\vert n \\mathbf{k}\\rangle\\) based on its projectability onto some localized atomic orbitals.</p> <p>Note</p> <p>this requires the <code>amn</code> file is properly normalized, i.e., projectability computed from \\(A A^\\dagger\\) must be smaller than or equal to 1. The pseudo-atomic projection satisfies such requirement, see Projections via pseudo-atomic orbitals in pw2wannier90.</p> <p>Additionally, one can combine projectability disentanglement with energy disentanglement, i.e., enable both <code>dis_proj_min/max</code> and <code>dis_froz_min/max</code> simultaneously in the <code>win</code> file. These settings will freeze the union of inner energy window and high-projectability states, and exclude the union of states outside outer energy window and having low projectability.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_proj_min","title":"<code>real(kind=dp) :: dis_proj_min</code>","text":"<p>The lower bound for the projectability disentanglement procedure.</p> <p>For states with projectabilities smaller than <code>dis_proj_min</code>, they will be discarded in the disentanglement procedure, i.e., similar to the case of outside of the outer energy window.</p> <p>For states with projectabilities larger than or equal to <code>dis_proj_min</code>, they will be included in the disentanglement procedure, i.e., similar to the case of inside the outer energy window.</p> <p>No unit.</p> <p>The default value is 0.95.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_proj_max","title":"<code>real(kind=dp) :: dis_proj_max</code>","text":"<p>The upper bound for the projectability disentanglement procedure. For states with projectability larger than or equal to <code>dis_proj_max</code>, they will be freezed in the disentanglement procedure, i.e., similar to the case of inside the inner energy window.</p> <p>No unit.</p> <p>The default value is 0.01.</p>"},{"location":"user_guide/wannier90/parameters/#integer-dis_num_iter","title":"<code>integer :: dis_num_iter</code>","text":"<p>In the disentanglement procedure, the number of iterations used to extract the most connected subspace.</p> <p>The default value is 200.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_mix_ratio","title":"<code>real(kind=dp) :: dis_mix_ratio</code>","text":"<p>In the disentanglement procedure, the mixing parameter to use for convergence (see pages 4-5 of Ref.\u00a0<sup>3</sup>). A value of 0.5 is a 'safe' choice. Using 1.0 (i.e., no mixing) often gives faster convergence, but may cause the minimisation of \\(\\Omega_{\\mathrm{I}}\\) to be unstable in some cases.</p> <p>Restriction: \\(0.0&lt;\\:\\)<code>dis_mix_ratio</code>\\(\\:\\leq 1.0\\)</p> <p>The default value is 0.5</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dis_conv_tol","title":"<code>real(kind=dp) :: dis_conv_tol</code>","text":"<p>In the disentanglement procedure, the minimisation of \\(\\Omega_{\\mathrm{I}}\\) is said to be converged if the fractional change in the gauge-invariant spread between successive iterations is less than <code>dis_conv_tol</code> for <code>dis_conv_window</code> iterations. Units are \u00c5\\(^2\\).</p> <p>The default value is 1.0E-10</p>"},{"location":"user_guide/wannier90/parameters/#integer-dis_conv_window","title":"<code>integer :: dis_conv_window</code>","text":"<p>In the disentanglement procedure, the minimisation is said to be converged if the fractional change in the spread between successive iterations is less than <code>dis_conv_tol</code> for <code>dis_conv_window</code> iterations.</p> <p>The default value of this parameter is 3.</p>"},{"location":"user_guide/wannier90/parameters/#integer-dis_spheres_num","title":"<code>integer :: dis_spheres_num</code>","text":"<p>Number of spheres in reciprocal space where the k-dependent disentanglement is performed. No disentanglement is performed for those k-points that are not included in any of the spheres.</p> <p>The default is 0, which means disentangle at every k-point in the full BZ (the standard mode in Wannier90).</p>"},{"location":"user_guide/wannier90/parameters/#integer-dis_spheres_first_wann","title":"<code>integer :: dis_spheres_first_wann</code>","text":"<p>Index of the first band that has to be considered as a Wannier function. Used only if <code>dis_spheres_num</code> is greater than zero. At k-points where disentanglement is not performed the bands from <code>dis_spheres_first_wann</code> to <code>dis_spheres_first_wann+num_wann</code> are used to wannierise. The bands excluded using <code>exclude_bands</code> should not be counted.</p> <p>The default is 1, the band at the lowest energy.</p>"},{"location":"user_guide/wannier90/parameters/#dis_spheres","title":"dis_spheres","text":"<p>Each line gives the coordinate \\(\\mathbf{K}=K_1 \\mathbf{B}_{1} + K_2 \\mathbf{B}_{2} + K_3 \\mathbf{B}_3\\) of a k-point representing the center of one of the spheres used for k-dependent disentanglement. The same crystallographic units as for <code>kpoints</code> are used here. Each k-point coordinate \\(\\mathbf{K}^i\\) must the followed by the respectice sphere radius \\(r_{i}\\) in inverse angstrom (on the same line).</p> <p>The number of lines must be equal to <code>dis_spheres_num</code>.</p> Input file<pre><code>begin dis_spheres\n</code></pre> \\[\\begin{array}{cccc}  K^{1}_{1} &amp; K^{1}_{2} &amp; K^{1}_{3} &amp; r_{1} \\\\  K^{2}_{1} &amp; K^{2}_{2} &amp; K^{2}_{3} &amp; r_{2} \\\\ \\vdots \\end{array}\\] Input file<pre><code>end dis_spheres\n</code></pre> <p>There is no default.</p>"},{"location":"user_guide/wannier90/parameters/#wannierise","title":"Wannierise","text":"<p>Iterative minimisation of \\(\\widetilde{\\Omega}\\), the non-gauge-invariant part of the spread functional.</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_iter","title":"<code>integer :: num_iter</code>","text":"<p>Total number of iterations in the minimisation procedure. Set <code>num_iter=0</code> if you wish to generate projected WFs rather than maximally-localized WFs (see Tutorial\u00a08 in the Tutorial).</p> <p>The default value is 100</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_cg_steps","title":"<code>integer :: num_cg_steps</code>","text":"<p>Number of conjugate gradient steps to take before resetting to steepest descents.</p> <p>The default value is 5</p>"},{"location":"user_guide/wannier90/parameters/#integer-conv_window","title":"<code>integer :: conv_window</code>","text":"<p>If <code>conv_window</code>\\(\\:&gt;1\\), then the minimisation is said to be converged if the change in \\(\\Omega\\) over <code>conv_window</code> successive iterations is less than <code>conv_tol</code>. Otherwise, the minimisation proceeds for num_iter iterations (default).</p> <p>The default value is -1</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-conv_tol","title":"<code>real(kind=dp) :: conv_tol</code>","text":"<p>If <code>conv_window</code>\\(\\:&gt;1\\), then this is the convergence tolerance on \\(\\Omega\\), otherwise not used. Units are \u00c5\\(^2\\).</p> <p>The default value is 1.0E-10</p>"},{"location":"user_guide/wannier90/parameters/#logical-precond","title":"<code>logical :: precond</code>","text":"<p>Whether or not to use preconditioning to speed up the minimization of the spreads. This is based on the same idea as the classical Tetter-Payne-Allan preconditionning for DFT and dampens the high-frequency oscillations of the gradient due to contributions from large real lattice vectors. It is useful when the optimization is slow, especially on fine grids. When <code>optimisation&lt;3</code>, this uses a slower algorithm to save memory.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-conv_noise_amp","title":"<code>real(kind=dp) :: conv_noise_amp</code>","text":"<p>If <code>conv_noise_amp</code>\\(\\:&gt;0\\), once convergence (as defined above) is achieved, some random noise \\(f\\) is added to the search direction, and the minimisation is continued until convergence is achieved once more. If the same value of \\(\\Omega\\) as before is arrived at, then the calculation is considered to be converged. If not, then random noise is added again and the procedure repeated up to a maximum of <code>conv_noise_num</code> times. <code>conv_noise_amp</code> is the amplitude of the random noise \\(f\\) that is added to the search direction: \\(0 &lt; |f| &lt;\\:\\)<code>conv_noise_amp</code>. This functionality requires <code>conv_window</code>\\(\\:&gt;1\\). If <code>conv_window</code> is not specified, it is set to the value 5 by default.</p> <p>If <code>conv_noise_amp</code>\\(\\:\\leq 0\\), then no noise is added (default).</p> <p>The default value is -1.0</p>"},{"location":"user_guide/wannier90/parameters/#integer-conv_noise_num","title":"<code>integer :: conv_noise_num</code>","text":"<p>If <code>conv_noise_amp</code>\\(\\:&gt;0\\), then this is the number of times in the minimisation that random noise is added.</p> <p>The default value is 3</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_dump_cycles","title":"<code>integer :: num_dump_cycles</code>","text":"<p>Write sufficient information to do a restart every <code>num_dump_cycles</code> iterations.</p> <p>The default is 100</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_print_cycles","title":"<code>integer :: num_print_cycles</code>","text":"<p>Write data to the master output file <code>seedname.wout</code> every <code>num_print_cycles</code> iterations.</p> <p>The default is 1</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_r2mn","title":"<code>logical :: write_r2mn</code>","text":"<p>If <code>write_r2mn = true</code>, then the matrix elements \\(\\langle m|r^2|n\\rangle\\) (where \\(m\\) and \\(n\\) refer to WF) are written to file <code>seedname.r2mn</code> at the end of the Wannierisation procedure.</p> <p>The default value of this parameter is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-guiding_centres","title":"<code>logical :: guiding_centres</code>","text":"<p>Use guiding centres during the minimisation, in order to avoid local minima.</p> <p><code>wannier90</code>\u00a0uses a logarithm definition of the spread functional. As we are taking the log of a complex argument there is a possibility that the algorithm might make inconsistent choices for the branch cut. This manifests itself as complex WF with a large spread. By using guiding centres the code will attempt to make a consistent choice of branch cut. Experience shows that with <code>guiding_centres</code> set to true this problem is avoided and doing so does not cause any problems. For this reason we recommend setting <code>guiding_centres</code> to <code>true</code> where possible (it is only not possible if an explicit projection block is not defined).</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_guide_cycles","title":"<code>integer :: num_guide_cycles</code>","text":"<p>If <code>guiding_centres</code> is set to <code>true</code>, then the guiding centres are used only every <code>num_guide_cycles</code>.</p> <p>The default value is 1.</p>"},{"location":"user_guide/wannier90/parameters/#integer-num_no_guide_iter","title":"<code>integer :: num_no_guide_iter</code>","text":"<p>If <code>guiding_centres</code> is set to true, then the guiding centres are used only after <code>num_no_guide_iter</code> minimisation iterations have been completed.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-trial_step","title":"<code>real(kind=dp) :: trial_step</code>","text":"<p>The value of the trial step for the parabolic fit in the line search minimisation used in the minimisation of the spread function. Cannot be used in conjunction with <code>fixed_step</code> (see below). If the minimisation procedure doesn't converge, try decreasing the value of <code>trial_step</code> to give a more accurate line search.</p> <p>The default value is 2.0</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-fixed_step","title":"<code>real(kind=dp) :: fixed_step</code>","text":"<p>If this is given a value in the input file, then a fixed step of length <code>fixed_step</code> (instead of a parabolic line search) is used at each iteration of the spread function minimisation. Cannot be used in conjunction with <code>trial_step</code>. This can be useful in cases in which minimisation with a line search fails to converge.</p> <p>There is no default value.</p>"},{"location":"user_guide/wannier90/parameters/#logical-use_bloch_phases","title":"<code>logical :: use_bloch_phases</code>","text":"<p>Determines whether to use the Bloch functions as the initial guess for the projections. Can only be used if <code>disentanglement = false</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-site_symmetry","title":"<code>logical :: site_symmetry</code>","text":"<p>Construct symmetry-adapted Wannier functions. For the detail of the theoretical background, see Ref.\u00a0<sup>4</sup>. Cannot be used in conjunction with the inner (frozen) energy window.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-symmetrize_eps","title":"<code>real(kind=dp) :: symmetrize_eps</code>","text":"<p>Convergence threshold to check whether the symmetry condition (Eq. (19) in Ref.\u00a0<sup>4</sup>) on the unitary matrix \\(\\mathbf{U}^{(\\mathbf{k})}\\) is satisfied or not. See also Eq. (29) in Ref.\u00a0<sup>4</sup>. Used when <code>site_symmetry = .true</code>.</p> <p>The default value is 1.0E-3.</p>"},{"location":"user_guide/wannier90/parameters/#integer-slwf_num","title":"<code>integer :: slwf_num</code>","text":"<p>The number of objective Wannier functions for selective localisation in the selectively localised Wannier function (SLWF) method of Ref.\u00a0<sup>5</sup>. These functions are obtained by minimising the spread functional only with respect to the degrees of freedom of a subset of <code>slwf_num</code> &lt; <code>num_wann</code> functions. At convergence, the objective WFs will have a minimum cumulative spread, whereas the remaining <code>num_wann - slwf_num</code> functions are left unoptimised. The initial guesses for the objective WFs are given by the first <code>slwf_num</code> orbitals in the <code>projections</code> block. If <code>slwf_num = num_wann</code> no selective minimisation is performed. In this case, <code>wannier90</code>\u00a0will simply generate a set of <code>num_wann</code> MLWFs.</p> <p>The default is <code>num_wann</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-slwf_constrain","title":"<code>logical :: slwf_constrain</code>","text":"<p>If <code>slwf_constrain=true</code>, then the centres of the objective Wannier functions are constrained to either the centres of the first <code>slwf_num</code> orbitals in the <code>projections</code> block or to new positions specified in the <code>slwf_centres</code> block (see Sec.\u00a0Constraints on centres). In this case, a modified spread functional, \\(\\Omega_c\\), with the addition of a constraint term, as described in Ref.\u00a0<sup>5</sup>.</p> <p>The default is <code>false</code></p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-slwf_lambda","title":"<code>real(kind=dp) :: slwf_lambda</code>","text":"<p>The value of the Lagrange multiplier \\(\\lambda\\) for the constraint term in term added to modify the spread functional: \\(\\lambda \\sum_{n=1}^{J'} \\left(\\overline{\\mathbf{r}}_n - \\mathbf{r}_{0n}\\right)^2\\), where \\(J'\\) is <code>slwf_num</code>, and \\(\\overline{\\mathbf{r}}_{n}\\) and \\(\\mathbf{r}_{0n}\\) are the centre and target centre, respectively, for the \\(n^{\\text{th}}\\) objective WF.</p> <p>The default is <code>0.0</code>.</p>"},{"location":"user_guide/wannier90/parameters/#constraints-on-centres","title":"Constraints on centres","text":"<p>If <code>slwf_constrain=true</code>, then by default the centres to which the <code>slwf_num</code> objective Wannier function centres are constrained are given by the first <code>slwf_num</code> rows of the <code>projections</code> block.</p> <p>Optionally, the <code>slwf_centres</code> block may be used to define alternative target centres for some or all of the <code>slwf_num</code> objective Wannier functions.</p> <p>The block below shows an example of how to set the constraints:</p> Input file<pre><code>begin slwf_centres\n   2  0.0   0.0  0.0\n   4  0.25  0.0  0.0\nend slwf_centres\n</code></pre> <ul> <li> <p>The first line sets the constraint for the centre of objective WF     number 2 (as defined by the order of WFs in the <code>projections</code> block)     to (0.0, 0.0, 0.0) in fractional coordinates.</p> </li> <li> <p>The second line sets the constraint for the centre of objective WF     number 4 (as defined by the order of WFs in the <code>projections</code> block)     to (0.25, 0.0, 0.0) in fractional coordinates.</p> </li> <li> <p>The target centres of all other objective Wannier functions remain     as the centres given in the corresponding rows of the <code>projections</code>     block.</p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#post-processing","title":"Post-Processing","text":"<p>Capabilities:</p> <ul> <li> <p>Plot the WF</p> </li> <li> <p>Plot the interpolated band structure</p> </li> <li> <p>Plot the Fermi surface</p> </li> <li> <p>Output the Hamiltonian in the WF basis</p> </li> <li> <p>Transport calculation (quantum conductance and density of states)</p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#logical-wannier_plot","title":"<code>logical :: wannier_plot</code>","text":"<p>If <code>wannier_plot = true</code>, then the code will write out the Wannier functions in a format specified by <code>wannier_plot_format</code></p> <p>The default value of this parameter is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#integer-wannier_plot_list","title":"<code>integer :: wannier_plot_list(:)</code>","text":"<p>A list of WF to plot. The WF numbered as per the <code>seedname.wout</code> file after the minimisation of the spread.</p> <p>The default behaviour is to plot all WF. For example, to plot WF 4, 5, 6 and 10:</p> Input file<pre><code>wannier_plot_list : 4-6, 10\n</code></pre>"},{"location":"user_guide/wannier90/parameters/#integer-wannier_plot_supercell","title":"<code>integer :: wannier_plot_supercell</code>","text":"<p>The code generates the WFs on a grid corresponding to a 'super-unit-cell'. If <code>wannier_plot_supercell</code> is provided as a single integer, then the size of the super-unit-cell is <code>wannier_plot_supercell</code> times the size of the unit cell along all three linear dimensions (the 'home' unit cell is kept approximately in the middle); otherwise, if three integers are provided, the size of the super-unit-cell is <code>wannier_plot_supercell(i)</code> times the size of the unit cell along the \\(i-\\)th linear dimension.</p> <p>The default value is 2.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-wannier_plot_format","title":"<code>character(len=20) :: wannier_plot_format</code>","text":"<p>WF can be plotted in either XCrySDen (xsf) format or Gaussian cube format. The valid options for this parameter are:</p> <ul> <li> <p><code>xcrysden</code> (default)</p> </li> <li> <p><code>cube</code></p> </li> </ul> <p>If <code>wannier_plot_format=xsf</code>: the code outputs the WF on the entire super-unit-cell specified by <code>wannier_plot_supercell</code>.</p> <p>If <code>wannier_plot_format=cube</code>: the code outputs the WF on a grid that is smaller than the super-unit-cell specified by <code>wannier_plot_supercell</code>. This grid is determined by <code>wannier_plot_mode</code>, <code>wannier_plot_radius</code> and <code>wannier_plot_scale</code>, described in detail below.</p> <p>The code is able to output Gaussian cube files for systems with non-orthogonal lattice vectors. Many visualisation programs (including XCrySDen), however, are only able to handle cube files for systems with orthogonal lattice vectors. One visualisation program that is capable of dealing with non-orthogonal lattice vectors is VESTA (http://jp-minerals.org/vesta/en/).</p> <p>Note</p> <p>It's worth noting that another visualisation program, VMD (http://www.ks.uiuc.edu/Research/vmd), is able to deal with certain special cases of non-orthogonal lattice vectors; see http://www.ks.uiuc.edu/Research/vmd/plugins/molfile/cubeplugin.html for details.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-wannier_plot_mode","title":"<code>character(len=20) :: wannier_plot_mode</code>","text":"<p>Choose the mode in which to plot the WF, either as a molecule or as a crystal.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>crystal</code> (default)</p> </li> <li> <p><code>molecule</code></p> </li> </ul> <p>If <code>wannier_plot_format=cube</code>:</p> <ul> <li> <p>if <code>wannier_plot_mode = molecule</code>, then wherever the WF centre sits     in the supercell, the origin of the cube is shifted (for the purpose     of plotting only, ie, nothing is done to the U matrices etc) to     coincide with the centre of mass of the atomic positions specified     by the user in the <code>.win</code> input file. These atomic positions are     also written to the cube file, so when it is visualised, the WF     appears superimposed on the molecular structure.</p> </li> <li> <p>if <code>wannier_plot_mode = crystal</code>, then the WF is not shifted, but     instead the code searches for atoms that are within a radius of     <code>wannier_plot_scale</code> \\(\\times\\) <code>wannier_plot_radius</code> of the WF centre     and writes the coordinates of these atoms to the cube file. In this     way, when the cube file is visualised, the WF appears superimposed     on the nearest atoms to the WF centre.</p> </li> <li> <p><code>crystal</code> mode can be used for molecules, and <code>molecule</code> mode can be     used for crystals.</p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#realkinddp-wannier_plot_radius","title":"<code>real(kind=dp) :: wannier_plot_radius</code>","text":"<p>If <code>wannier_plot_format=cube</code>, then <code>wannier_plot_radius</code> is the radius of the sphere that must fit inside the parallelepiped in which the WF is plotted. <code>wannier_plot_radius</code> must be greater than 0. Units are \u00c5.</p> <p>The default value is 3.5.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-wannier_plot_scale","title":"<code>real(kind=dp) :: wannier_plot_scale</code>","text":"<p>If <code>wannier_plot_format=cube</code> and <code>wannier_plot_mode=crystal</code>, then the code searches for atoms that are within a radius of <code>wannier_plot_scale</code> \\(\\times\\) <code>wannier_plot_radius</code> of the WF centre and writes the coordinates of these atoms to the cube file. In this way, when the cube file is visualised, the WF appears superimposed on the nearest atoms to the WF centre. <code>wannier_plot_scale</code> must be greater than 0. This parameter is dimensionless.</p> <p>The default value is 1.0.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-wannier_plot_spinor_mode","title":"<code>character(len=20) :: wannier_plot_spinor_mode</code>","text":"<p>If <code>spinors = true</code> then this parameter controls the quantity to plot. For a spinor WF with components \\([\\phi,\\psi]\\) the quatity plotted is</p> <ul> <li> <p><code>total</code> (default). \\(\\sqrt{[|\\phi|^2+|\\psi|^2]}\\)</p> </li> <li> <p><code>up</code>. \\(|\\phi|\\times sign(Re\\{\\phi\\})\\) if     <code>wannier_plot_spinor_phase = true</code>, otherwise \\(|\\phi|\\)</p> </li> <li> <p><code>down</code>. \\(|\\psi|\\times sign(Re\\{\\psi\\})\\) if     <code>wannier_plot_spinor_phase = true</code>, otherwise \\(|\\psi|\\)</p> </li> </ul> <p>Note</p> <p>making a visual representation of a spinor WF is not as straightforward as for a scalar WF. While a scalar WF is typically a real valued function, a spinor WF is a complex, two component spinor. <code>wannier90</code>\u00a0is able to plot several different quantities derived from a spinor WF which should give you a good idea of the nature of the WF.</p>"},{"location":"user_guide/wannier90/parameters/#logical-wannier_plot_spinor_phase","title":"<code>logical :: wannier_plot_spinor_phase</code>","text":"<p>If <code>wannier_plot_spinor_phase = true</code> phase information will be taken into account when plotting a spinor WF.</p>"},{"location":"user_guide/wannier90/parameters/#logical-bands_plot","title":"<code>logical :: bands_plot</code>","text":"<p>If <code>bands_plot = true</code>, then the code will calculate the band structure, through Wannier interpolation, along the path in k-space defined by <code>bands_kpath</code> using <code>bands_num_points</code> along the first section of the path and write out an output file in a format specified by <code>bands_plot_format</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#kpoint_path","title":"kpoint_path","text":"<p>Defines the path in k-space along which to calculate the bandstructure. Each line gives the start and end point (with labels) for a section of the path. Values are in fractional coordinates with respect to the primitive reciprocal lattice vectors.</p> Input file<pre><code>begin kpoint_path\n</code></pre> \\[\\begin{array}{cccccccc} G &amp; 0.0 &amp; 0.0 &amp; 0.0 &amp; L &amp; 0.0 &amp; 0.0 &amp; 1.0 \\\\ L &amp; 0.0 &amp; 0.0 &amp; 1.0 &amp; N &amp; 0.0 &amp; 1.0 &amp; 1.0 \\\\ \\vdots \\end{array}\\] Input file<pre><code>end kpoint_path\n</code></pre> <p>There is no default</p>"},{"location":"user_guide/wannier90/parameters/#integer-bands_num_points","title":"<code>integer :: bands_num_points</code>","text":"<p>If <code>bands_plot = true</code>, then the number of points along the first section of the bandstructure plot given by <code>kpoint_path</code>. Other sections will have the same density of k-points.</p> <p>The default value for <code>bands_num_points</code> is 100.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-bands_plot_format","title":"<code>character(len=20) :: bands_plot_format</code>","text":"<p>Format in which to plot the interpolated band structure. The valid options for this parameter are:</p> <ul> <li> <p><code>gnuplot</code> (default)</p> </li> <li> <p><code>xmgrace</code></p> </li> </ul> <p>Note</p> <p>it is possible to request output in both formats eg <code>bands_format = gnuplot xmgrace</code></p>"},{"location":"user_guide/wannier90/parameters/#integer-bands_plot_project","title":"<code>integer :: bands_plot_project(:)</code>","text":"<p>If present <code>wannier90</code>\u00a0will compute the contribution of this set of WF to the states at each point of the interpolated band structure. The WF are numbered according to the seedname.wout file. The result is written in the <code>seedname_band.dat</code> file, and a corresponding gnuplot script to <code>seedname_band_proj.dat</code> .</p> <p>For example, to project on to WFs 2, 6, 7, 8 and 12:</p> Input file<pre><code>bands_plot_project : 2, 6-8, 12\n</code></pre>"},{"location":"user_guide/wannier90/parameters/#characterlen20-bands_plot_mode","title":"<code>character(len=20) :: bands_plot_mode</code>","text":"<p>To interpolate the band structure along the k-point path, either use the Slater-Koster interpolation scheme or truncate the Hamiltonian matrix in the WF basis. Truncation criteria are provided by <code>hr_cutoff</code> and <code>dist_cutoff</code>.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>s-k</code> (default)</p> </li> <li> <p><code>cut</code></p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#integer-bands_plot_dim","title":"<code>integer :: bands_plot_dim</code>","text":"<p>Dimension of the system. If <code>bands_plot_dim &lt; 3</code> and <code>bands_plot_mode = cut</code>, lattice vector \\(\\mathbf{R}=N_1 \\mathbf{A}_{1} + N_2 \\mathbf{A}_{2} + N_3 \\mathbf{A}_3\\), where \\(N_i=0\\) if \\(\\mathbf{A}_i\\) is parallel to any of the confined directions specified by <code>one_dim_axis</code>, are exclusively used in the band structure interpolation.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p>3 (default)</p> </li> <li> <p>2</p> </li> <li> <p>1</p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#logical-fermi_surface_plot","title":"<code>logical :: fermi_surface_plot</code>","text":"<p>If <code>fermi_surface_plot = true</code>, then the code will calculate, through Wannier interpolation, the eigenvalues on a regular grid with <code>fermi_surface_num_points</code> in each direction. The code will write a file in bxsf format which can be read by XCrySDen in order to plot the Fermi surface.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#integer-fermi_surface_num_points","title":"<code>integer :: fermi_surface_num_points</code>","text":"<p>If <code>fermi_surface_plot = true</code>, then the number of divisions in the regular k-point grid used to calculate the Fermi surface.</p> <p>The default value for <code>fermi_surface_num_points</code> is 50.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-fermi_energy","title":"<code>real(kind=dp) :: fermi_energy</code>","text":"<p>The Fermi energy in eV. If <code>fermi_energy</code> is specified, <code>fermi_energy_min</code>, <code>fermi_energy_max</code>, and <code>fermi_energy_step</code> should not be specified, and vice-versa.</p> <p>The default value is 0.0</p> <ul> <li> <p>For Fermi surface:     This parameter is written into the bxsf file.</p> </li> <li> <p>For transport:     The energy axis of the quantum conductance and     density of states data will be shifted rigidly by this amount.</p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#realkinddp-fermi_energy_min","title":"<code>real(kind=dp) :: fermi_energy_min</code>","text":"<p>Instead of specifyfing a single Fermi energy, it is possible to scan the Fermi level over a range of values, and recompute certain quantities for each \\(\\varepsilon_F\\). This is the minimum value in the range (in eV).</p> <p>Note</p> <p>Scanning the Fermi level is currently supported only by the <code>postw90</code> module <code>berry</code>, for <code>berry_task=ahc,morb</code>. For all other functionalities that require a knowledge of \\(\\varepsilon_F\\), use <code>fermi_energy</code> instead.</p> <p>There is no default value.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-fermi_energy_max","title":"<code>real(kind=dp) :: fermi_energy_max</code>","text":"<p>The maximum value in the range of Fermi energies. Units are eV.</p> <p>The default value is <code>fermi_energy_min + 1.0</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-fermi_energy_step","title":"<code>real(kind=dp) :: fermi_energy_step</code>","text":"<p>Difference between consecutive values of the Fermi energy when scanning from <code>fermi_energy_min</code> to <code>fermi_energy_max</code>. Units are eV.</p> <p>The default value is 0.01.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-fermi_surface_plot_format","title":"<code>character(len=20) :: fermi_surface_plot_format</code>","text":"<p>Format in which to plot the Fermi surface. The valid options for this parameter are:</p> <ul> <li><code>xcrysden</code> (default)</li> </ul>"},{"location":"user_guide/wannier90/parameters/#logical-write_hr","title":"<code>logical :: write_hr</code>","text":"<p>If <code>write_hr = true</code>, then the Hamiltonian matrix in the WF basis will be written to a file <code>seedname_hr.dat</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_rmn","title":"<code>logical :: write_rmn</code>","text":"<p>If <code>write_rmn = true</code>, then the position operator in the WF basis will be written to a file <code>seedname_r.dat</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_bvec","title":"<code>logical :: write_bvec</code>","text":"<p>If <code>write_bvec = true</code>, then the the matrix elements of bvector and their weights will be written to a file <code>seedname.bvec</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_tb","title":"<code>logical :: write_tb</code>","text":"<p>If <code>write_tb = true</code>, then the lattice vectors, together with the Hamiltonian and position-operator matrices in the WF basis, will be written to a file <code>seedname_tb.dat</code>, in units of Angstrom and eV.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-transport","title":"<code>logical :: transport</code>","text":"<p>If <code>transport = true</code>, then the code will calculate quantum conductance and density of states of a one-dimensional system. The results will be written to files <code>seedname_qc.dat</code> and <code>seedname_dos.dat</code>, respectively. Since both quantities are a function of energy, they will be evaluated from <code>tran_win_min</code> to <code>tran_win_max</code> with an interval of <code>tran_energy_step</code>.</p> <p>The default value of this parameter is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-transport_mode","title":"<code>character(len=20) :: transport_mode</code>","text":"<p>If <code>transport_mode = bulk</code>, quantum conductance and density of states are calculated for a perfectly-periodic one-dimensional system. In this case, the transport part can either use the Hamiltonian matrix in the WF basis generated by <code>wannier90</code>\u00a0or a Hamiltonian matrix provided by the external file <code>seedname_htB.dat</code>.</p> <p>If <code>transport_mode = lcr</code>, quantum conductance and density of states are calculated for a system where semi-infinite, left and right leads are connected through a central conductor region. In this case, the transport part will work independently from the disentanglement and wannierise procedure. Details of the method is described in Ref. <sup>6</sup>.</p> <p>If <code>tran_read_ht = true</code> then the Hamiltonian matrices must be provided by the five external files: <code>seedname_htL.dat, seedname_htLC.dat, seedname_htC.dat, seedname_htCR.dat, seedname_htR.dat</code>. If <code>tran_read_ht = false</code> then the Hamiltonian matrices are found automatically provided the supercell adheres to conditions outlined in Section Automated lcr Transport Calculations: The 2c2 Geometry.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>bulk</code> (default)</p> </li> <li> <p><code>lcr</code></p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#realkinddp-tran_win_min","title":"<code>real(kind=dp) :: tran_win_min</code>","text":"<p>The lower bound of the energy window for the transport calculation. Units are eV.</p> <p>The default value is -3.0.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-tran_win_max","title":"<code>real(kind=dp) :: tran_win_max</code>","text":"<p>The upper bound of the energy window for the transport calculation. Units are eV.</p> <p>The default value is 3.0.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-tran_energy_step","title":"<code>real(kind=dp) :: tran_energy_step</code>","text":"<p>Sampling interval of the energy values from <code>tran_win_min</code> to <code>tran_win_max</code>. Units are eV.</p> <p>The default value is 0.01.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_bb","title":"<code>integer :: tran_num_bb</code>","text":"<p>Size of a bulk Hamiltonian matrix. This number is equal to the number of WFs in one principal layer.</p> <p>A one-dimensional system can be viewed as an array of principal layers which are defined in a way that localized basis functions inside a certain principal layer only interact with those in the nearest neighbor principal layer. In <code>wannier90</code>\u00a0a principal layer will be an integer multiple of a unit cell, and the size is determined by <code>hr_cutoff</code> and/or <code>dist_cutoff</code>. The criterion is rather arbitrary when WFs are adopted as a localized basis set, and it is up to a user's choice.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_ll","title":"<code>integer :: tran_num_ll</code>","text":"<p>Size of a left-lead Hamiltonian matrix. If <code>transport_mode = lcr</code> and <code>tran_read_ht = false</code> then <code>tran_num_ll</code> is the number of Wannier functions in a principal layer.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_rr","title":"<code>integer :: tran_num_rr</code>","text":"<p>Size of a right-lead Hamiltonian matrix.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_cc","title":"<code>integer :: tran_num_cc</code>","text":"<p>Size of a conductor Hamiltonian matrix.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_lc","title":"<code>integer :: tran_num_lc</code>","text":"<p>Number of columns in a left-lead_conductor Hamiltonian matrix. Number of rows must be equal to <code>tran_num_ll</code>.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_cr","title":"<code>integer :: tran_num_cr</code>","text":"<p>Number of rows in a conductor_right-lead Hamiltonian matrix. Number of columns must be equal to <code>tran_num_rr</code>.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_cell_ll","title":"<code>integer :: tran_num_cell_ll</code>","text":"<p>Number of unit cells in one principal layer of left lead. Used if <code>transport_mode = lcr</code> and <code>tran_read_ht = false</code>.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_cell_rr","title":"<code>integer :: tran_num_cell_rr</code>","text":"<p>Number of unit cells in one principal layer of right lead. Not used at present.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#integer-tran_num_bandc","title":"<code>integer :: tran_num_bandc</code>","text":"<p>Half-bandwidth+1 of a band-diagonal conductor Hamiltonian matrix.</p> <p>The Hamiltonian matrix of a central conductor part, which is read from <code>seedname_htC.dat</code>, will be diagonally dominant when <code>tran_num_cc</code> is very large. <code>tran_num_bandc</code> is used to construct a compact matrix which contains the non-zero band-diagonal part of a full conductor Hamiltonian matrix. Setting this parameter is only meaningful when <code>tran_num_bandc</code> is greater than <code>tran_num_lc</code> and <code>tran_num_cr</code>.</p> <p>The default value is 0.</p>"},{"location":"user_guide/wannier90/parameters/#logical-tran_write_ht","title":"<code>logical :: tran_write_ht</code>","text":"<p>If <code>tran_write_ht = true</code>, then the Hamiltonian matrix formatted for the transport calculation will be written to a file <code>seedname_htB.dat</code>.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-tran_read_ht","title":"<code>logical :: tran_read_ht</code>","text":"<p>If <code>tran_write_ht = true</code>, then the Hamiltonian matrix formatted for the transport calculation will be read from a set of files described in the parameter <code>transport_mode</code>. Set <code>tran_write_ht = false</code> to perform automated lcr calculations (see Section Automated lcr Transport Calculations: The 2c2 Geometry).</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#logical-tran_use_same_lead","title":"<code>logical :: tran_use_same_lead</code>","text":"<p>If <code>tran_use_same_lead = true</code>, then the left and the right leads are the same. In this case, <code>seedname_htR.dat</code> is not required.</p> <p>The default value is <code>true</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-tran_group_threshold","title":"<code>real(kind=dp) :: tran_group_threshold</code>","text":"<p>Used to group and sort Wannier functions according to the positions of their centres. Wannier functions in a group are within <code>tran_group_threshold</code> from one another in <code>x,y</code> and <code>z</code> directions. Units are \u00c5</p> <p>The default is 0.15</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-translation_centre_frac3","title":"<code>real(kind=dp) :: translation_centre_frac(3)</code>","text":"<p>Centre of the unit cell to which the final Wannier centres are translated. Numbers are in fractional coordinates with respect to the lattice vectors.</p> <p>The default value is (0.0,0.0,0.0).</p>"},{"location":"user_guide/wannier90/parameters/#logical-use_ws_distance","title":"<code>logical :: use_ws_distance</code>","text":"<p>Improves the interpolation of the k-space Hamiltonian, by applying a translation to each WF by a basis vector of the super-lattice that minimises the distance between their centres. The translation is dependent on both WF and on the unit cell vector to which they belong, i.e., translate function \\(W_j({\\bf r}-{\\bf R})\\) inside the Wigner-Seitz cell centred on WF \\(W_i({\\bf r})\\).</p> <p>For a longer explanation, see Chapter\u00a0Some notes on the interpolation.</p> <p>If <code>false</code> the code puts all the WF in the home cell, only possible choice until wannier90 v2.0.1.</p> <p>The default value is <code>true</code> (default changed since v.3.0). Introduced in v2.1.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-ws_distance_tol","title":"<code>real(kind=dp) :: ws_distance_tol</code>","text":"<p>Tolerance when determining whether two values \\(\\|\\mathbf{d}_{ij\\mathbf{R}} + \\tilde{\\mathbf{R}}_{nml} \\|\\) and \\(\\|\\mathbf{d}_{ij\\mathbf{R}} + \\tilde{\\mathbf{R}}_{n'm'l'} \\|\\) (as defined in chapter\u00a0Some notes on the interpolation) for the shortest distance between two Wannier functions are equivalent. If the difference in distance (in Angstrom) is less than <code>ws_distance_tol</code>, they are taken to be equivalent.</p> <p>The default value is \\(10^{-5}\\).</p>"},{"location":"user_guide/wannier90/parameters/#ws_search_size","title":"<code>:: ws_search_size</code>","text":"<p>Maximum absolute value for the integers \\(n,m,l\\) that identify the super-lattice vectors \\(\\tilde{\\mathbf{R}}_{nml}\\) (see chapter\u00a0Some notes on the interpolation) when searching for points inside the Wigner-Seitz cell. If <code>ws_search_size</code> is provided as a single integer, then the number of repetitions of the Born-von Karman cell is the same along all three linear dimensions; otherwise, if three integers are provided, the number of repetitions along the \\(i-\\)th linear dimension is <code>ws_search_size(i)</code>. The variable is used both in <code>hamiltonian.F90</code> and in <code>ws_distance.F90</code>. In the latter case, its value is incremented by one in order to account for WFs whose centre wanders away from the original reference unit cell. The default value is generally sufficient, but might need to be increased in case of elongated cells.</p> <p>The default value is 2.</p>"},{"location":"user_guide/wannier90/parameters/#logical-write_u_matrices","title":"<code>logical :: write_u_matrices</code>","text":"<p>Write the \\(\\mathbf{U}^{(\\mathbf{k})}\\) and \\(\\mathbf{U}^{\\mathrm{dis}(\\mathbf{k})}\\) matrices obtained at the end of wannierization to files <code>seedname_u.mat</code> and <code>seedname_u_dis.mat</code>, respectively.</p> <p>The default value is <code>false</code>.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-hr_cutoff","title":"<code>real(kind=dp) :: hr_cutoff</code>","text":"<p>The absolute value of the smallest matrix element of the Hamiltonian in the WF basis. If \\(h_{mn}(\\mathbf{R})&gt;\\:\\)<code>hr_cutoff</code>, then the matrix element \\(h_{mn}(\\mathbf{R})\\) is retained and used in the band structure interpolation (when <code>bands_plot_mode = cut</code>) or in the transport calculation. Otherwise it is deemed to be insignificant and is discarded. Units are eV.</p> <p>The default value is 0.0.</p>"},{"location":"user_guide/wannier90/parameters/#realkinddp-dist_cutoff","title":"<code>real(kind=dp) :: dist_cutoff</code>","text":"<p>The largest distance between two WFs for which the Hamiltonian matrix element is retained and used in the band interpolation (when <code>bands_plot_mode = cut</code>) or in the transport calculation. Units are \u00c5.</p> <p>The default value is 1000.0.</p>"},{"location":"user_guide/wannier90/parameters/#characterlen20-dist_cutoff_mode","title":"<code>character(len=20) :: dist_cutoff_mode</code>","text":"<p>Dimension in which the distance between two WFs is calculated. The vector connecting two WFs may be projected to a line (<code>one_dim</code>) or a plane (<code>two_dim</code>). The size of the projected vector is calculated, and <code>dist_cutoff</code> is applied. When <code>one_dim</code> or <code>two_dim</code> is used, <code>one_dim_axis</code> must be given to specify extended or confined direction.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>three_dim</code> (default)</p> </li> <li> <p><code>two_dim</code></p> </li> <li> <p><code>one_dim</code></p> </li> </ul>"},{"location":"user_guide/wannier90/parameters/#characterlen20-one_dim_axis","title":"<code>character(len=20) :: one_dim_axis</code>","text":"<p>Extended direction for a one-dimensional system or confined direction for a two-dimensional system. This direction must be parallel to one of the Cartesian axes.</p> <p>The valid options for this parameter are:</p> <ul> <li> <p><code>x</code></p> </li> <li> <p><code>y</code></p> </li> <li> <p><code>z</code></p> </li> </ul> <p>No default.</p> <ol> <li> <p>N. Marzari and D. Vanderbilt. Maximally localized generalized wannier functions for composite energy bands. Phys. Rev. B, 56:12847, 1997.\u00a0\u21a9\u21a9</p> </li> <li> <p>F. Gygi, J. L. Fattebert, and E. Schwegler. Computation of maximally localized wannier functions using a simultaneous diagonalization algorithm. Comput. Phys. Commun., 155:1\u20136, 2003.\u00a0\u21a9</p> </li> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9\u21a9</p> </li> <li> <p>R. Sakuma. Symmetry-adapted wannier functions in the maximal localization procedure. Phys. Rev. B, 87:235109, 2013.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Runzhi Wang, Emanuel A. Lazar, Hyowon Park, Andrew J. Millis, and Chris A. Marianetti. Selectively localized wannier functions. Physical Review B, 10 2014. doi:10.1103/PhysRevB.90.165125.\u00a0\u21a9\u21a9</p> </li> <li> <p>Marco Buongiorno Nardelli. Electronic transport in extended systems: application to carbon nanotubes. Phys. Rev. B, 60:7828, 1999.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/postproc/","title":"<code>wannier90</code>\u00a0as a post-processing tool","text":"<p>This is a description of how to use <code>wannier90</code>\u00a0as a post-processing tool.</p> <p>The code must be run twice. On the first pass either the logical keyword <code>postproc_setup</code> must be set to <code>.true.</code> in the input file <code>seedname.win</code> or the code must be run with the command line option <code>-pp</code>. Running the code then generates the file <code>seedname.nnkp</code> which provides the information required to construct the \\(M_{mn}^{(\\mathbf{k,b})}\\) overlaps (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(25)) and \\(A_{mn}^{(\\mathbf{k})}\\) (Ref.\u00a0<sup>1</sup>, Eq.\u00a0(62); Ref.\u00a0<sup>2</sup>, Eq.\u00a0(22)).</p> <p>Once the overlaps and projection have been computed and written to files <code>seedname.mmn</code> and <code>seedname.amn</code>, respectively, set <code>postproc_setup</code> to <code>.false.</code> and run the code. Output is written to the file <code>seedname.wout</code>.</p>"},{"location":"user_guide/wannier90/postproc/#seednamennkp-file","title":"<code>seedname.nnkp</code> file","text":"<p>OUTPUT, if <code>postproc_setup = .true.</code></p> <p>The file <code>seedname.nnkp</code> provides the information needed to determine the required overlap elements \\(M_{mn}^{(\\mathbf{k,b})}\\) and projections \\(A_{mn}^{(\\mathbf{k})}\\). It is written automatically when the code is invoked with the <code>-pp</code> command-line option (or when <code>postproc_setup=.true.</code> in <code>seedname.win</code>. There should be no need for the user to edit this file.</p> <p>Much of the information in <code>seedname.nnkp</code> is arranged in blocks delimited by the strings <code>begin block_name</code> ... <code>end block_name</code>, as described below.</p>"},{"location":"user_guide/wannier90/postproc/#keywords","title":"Keywords","text":"<p>The first line of the file is a user comment, e.g., the date and time:</p> <p><code>File written on 12Feb2006 at 15:13:12</code></p> <p>The only logical keyword is <code>calc_only_A</code>, eg,</p> <p><code>calc_only_A  :  F</code></p>"},{"location":"user_guide/wannier90/postproc/#real_lattice-block","title":"<code>Real_lattice</code> block","text":"Input file<pre><code>begin real_lattice\n 2.250000   0.000000   0.000000\n 0.000000   2.250000   0.000000\n 0.000000   0.000000   2.250000\nend real_lattice\n</code></pre> <p>The real lattice vectors in units of Angstrom.</p>"},{"location":"user_guide/wannier90/postproc/#recip_lattice-block","title":"<code>Recip_lattice</code> block","text":"Input file<pre><code>begin recip_lattice\n 2.792527   0.000000   0.000000\n 0.000000   2.792527   0.000000\n 0.000000   0.000000   2.792527\nend recip_lattice\n</code></pre> <p>The reciprocal lattice vectors in units of inverse Angstrom.</p>"},{"location":"user_guide/wannier90/postproc/#kpoints-block","title":"<code>Kpoints</code> block","text":"Input file<pre><code>begin kpoints\n  8\n  0.00000   0.00000   0.00000\n  0.00000   0.50000   0.00000\n  .\n  .\n  .\n  0.50000   0.50000   0.50000\nend kpoints\n</code></pre> <p>The first line in the block is the total number of k-points <code>num_kpts</code>. The subsequent <code>num_kpts</code> lines specify the k-points in crystallographic co-ordinates relative to the reciprocal lattice vectors.</p>"},{"location":"user_guide/wannier90/postproc/#projections-block","title":"<code>Projections</code> block","text":"Input file<pre><code>begin projections\n   n_proj\n   centre   l  mr  r\n     z-axis   x-axis   zona\n   centre   l  mr  r\n     z-axis   x-axis   zona\n   .\n   .\nend projections\n</code></pre> <p>Notes:</p> <p><code>n_proj</code>: integer; the number of projection centres, equal to the number of MLWF <code>num_wann</code>.</p> <p><code>centre</code>: three real numbers; projection function centre in crystallographic co-ordinates relative to the direct lattice vectors.</p> <p><code>l  mr  r</code>: three integers; \\(l\\) and \\(m_\\mathrm{r}\\) specify the angular part \\(\\Theta_{lm_{\\mathrm{r}}}(\\theta,\\varphi)\\), and \\(\\mathrm{r}\\) specifies the radial part \\(R_{\\mathrm{r}}(r)\\) of the projection function (see Tables\u00a0Angular functions, Hybrids and Radial functions).</p> <p><code>z-axis</code>: three real numbers; default is <code>0.0 0.0 1.0</code>; defines the axis from which the polar angle \\(\\theta\\) in spherical polar coordinates is measured.</p> <p><code>x-axis</code>: three real numbers; must be orthogonal to <code>z-axis</code>; default is <code>1.0 0.0 0.0</code> or a vector perpendicular to <code>z-axis</code> if <code>z-axis</code> is given; defines the axis from with the azimuthal angle \\(\\varphi\\) in spherical polar coordinates is measured.</p> <p><code>zona</code>: real number; the value of \\(\\frac{Z}{a}\\) associated with the radial part of the atomic orbital. Units are in reciprocal Angstrom.</p>"},{"location":"user_guide/wannier90/postproc/#spinor_projections-block","title":"<code>spinor_projections</code> block","text":"Input file<pre><code>begin spinor_projections\n   n_proj\n   centre   l  mr  r\n    z-axis   x-axis   zona\n     spin spn_quant\n   centre   l  mr  r\n    z-axis   x-axis   zona\n     spin spn_quant\n   .\n   .\nend spinor_projections\n</code></pre> <p>Notes: Only one of projections and spinor_projections should be defined. Variables are the same as the projections block with the addition of <code>spin</code> and <code>spn_quant</code>.</p> <p><code>spin</code>: integer. '1' or '-1' to denote projection onto up or down states.</p> <p><code>spn_quant</code>: three real numbers. Defines the spin quantisation axis in Cartesian coordinates.</p>"},{"location":"user_guide/wannier90/postproc/#nnkpts-block","title":"<code>nnkpts</code> block","text":"Input file<pre><code>begin nnkpts\n  10\n  1   2   0  0  0\n  .\n  .\nend nnkpts\n</code></pre> <p>First line: <code>nntot</code>, the number of nearest neighbours belonging to each k-point of the Monkhorst-Pack mesh</p> <p>Subsequent lines: <code>nntot</code>\\(\\times\\)<code>num_kpts</code> lines, ie, <code>nntot</code> lines of data for each k-point of the mesh.</p> <p>Each line of consists of 5 integers. The first is the k-point number <code>nkp</code>. The second to the fifth specify it's nearest neighbours \\(\\mathbf{k+b}\\): the second integer points to the k-point that is the periodic image of the \\(\\mathbf{k+b}\\) that we want; the last three integers give the G-vector, in reciprocal lattice units, that brings the k-point specified by the second integer (which is in the first BZ) to the actual \\(\\mathbf{k+b}\\) that we need.</p>"},{"location":"user_guide/wannier90/postproc/#exclude_bands-block","title":"<code>exclude_bands</code> block","text":"Input file<pre><code>begin exclude_bands \n  8 \n  1 \n  2 \n  .\n  .\nend exclude_bands\n</code></pre> <p>To exclude bands (independent of k-point) from the calculation of the overlap and projection matrices, for example to ignore shallow-core states. The first line is the number of states to exclude, the following lines give the states for be excluded.</p>"},{"location":"user_guide/wannier90/postproc/#auto_projections-block","title":"<code>auto_projections</code> block","text":"Input file<pre><code>begin auto_projections\n   8\n   0\nend auto_projections\n</code></pre> <p>This block is only printed if <code>auto_projections=true</code> in the input. The choice of an additional block has been made in order to maintain back-compatibility with codes that interface with <code>wannier90</code>, e.g. <code>pw2wannier90</code>. The first entry in the block (in the example above, <code>8</code>) is the total number of target projections and it is equal to the number of sought Wannier functions.</p> <p>The second entry is a reserved flag with the value of zero. The implementations of the interface codes MUST check for this value to be zero and stop otherwise. In the future, one possible extension that we plan is to combine the automatic generation of initial projections with the selection of projections via a projections block. This will allow the user to specify only a subset of initial projections in the projections block and leave the interface code to automatically generate the remaining ones. In that case the constraint on the second entry will be lifted, so that it can take on the meaning of the number of projections that need to be generated automatically.</p> <p>The selected columns of the density matrix (SCDM) method\u00a0<sup>3</sup> is one way of generating the initial \\(A_{mn}^{(\\mathbf{k})}\\) in an automatic way. This has been implemented in the <code>pw2wannier90</code> interface code (you need v6.3 with the files provided in the <code>pwscf</code> folder of Wannier90, or v6.4), see for instance Tutorial 27 in the <code>wannier90</code>\u00a0tutorial that shows how to use it.</p> <p>Moreover, also the automatic generation of initial projections with spinor WFs is implemented in the <code>pw2wannier90</code> interface. See Tutorial 31 in the <code>wannier90</code>\u00a0tutorial that shows how to use it.</p> <p>Another automatic projection method is projectability-disentangled Wannier function (PDWF) <sup>4</sup>, which uses pseudo-atomic orbitals inside pseudopotentials as initial guesses.</p>"},{"location":"user_guide/wannier90/postproc/#an-example-of-projections","title":"An example of projections","text":"<p>As a concrete example: one wishes to have a set of four sp\\(^3\\) projection orbitals on, say, a carbon atom at (0.5,0.5,0.5) in fractional co-ordinates relative to the direct lattice vectors. In this case <code>seedname.win</code> will contain the following lines:</p> Input file<pre><code>begin projections\n C:l=-1\nend projections\n</code></pre> <p>and <code>seedname.nnkp</code>, generated on the first pass of <code>wannier90</code>\u00a0(with <code>postproc_setup=T</code>), will contain:</p> Input file<pre><code>begin projections\n   4\n   0.50000    0.50000    0.50000    -1  1  1\n     0.000  0.000  1.000   1.000  0.000  0.000   2.00\n   0.50000    0.50000    0.50000    -1  2  1\n     0.000  0.000  1.000   1.000  0.000  0.000   2.00\n   0.50000    0.50000    0.50000    -1  3  1\n     0.000  0.000  1.000   1.000  0.000  0.000   2.00\n   0.50000    0.50000    0.50000    -1  4  1\n     0.000  0.000  1.000   1.000  0.000  0.000   2.00\nend projections\n</code></pre> <p>where the first line tells us that in total four projections are specified, and the subsequent lines provide the projection centre, the angular and radial parts of the orbital (see Section Orbital Definitions for definitions), the \\(z\\) and \\(x\\) axes, and the diffusivity and cut-off radius for the projection orbital.</p> <p><code>pwscf</code>, or any other ab initio electronic structure code, then reads <code>seedname.nnkp</code> file, calculates the projections and writes them to <code>seedname.amn</code>.</p>"},{"location":"user_guide/wannier90/postproc/#seednamemmn-file","title":"<code>seedname.mmn</code> file","text":"<p>INPUT.</p> <p>The file <code>seedname.mmn</code> contains the overlaps \\(M_{mn}^{(\\mathbf{k,b})}\\).</p> <p>First line: a user comment, e.g., the date and time</p> <p>Second line: 3 integers: <code>num_bands</code>, <code>num_kpts</code>, <code>nntot</code></p> <p>Then: <code>num_kpts * nntot</code> blocks of data:</p> <p>First line of each block: 5 integers. The first specifies the \\(\\mathbf{k}\\) (i.e., gives the ordinal corresponding to its position in the list of k-points in <code>seedname.win</code>). The 2<sup>nd</sup> to 5<sup>th</sup> integers specify \\(\\mathbf{k+b}\\). The 2<sup>nd</sup> integer, in particular, points to the k-point on the list that is a periodic image of \\(\\mathbf{k+b}\\), and in particular is the image that is actually mentioned in the list. The last three integers specify the \\(\\mathbf{G}\\) vector, in reciprocal lattice units, that brings the k-point specified by the second integer, and that thus lives inside the first BZ zone, to the actual \\(\\mathbf{k+b}\\) that we need.</p> <p>Subsequent <code>num_bands * num_bands</code> lines of each block: two real numbers per line. These are the real and imaginary parts, respectively, of the actual scalar product \\(M_{mn}^{(\\mathbf{k,b})}\\) for \\(m,n \\in [1,\\texttt{num_bands}]\\). The order of these elements is such that the first index \\(m\\) is fastest.</p>"},{"location":"user_guide/wannier90/postproc/#seednameamn-file","title":"<code>seedname.amn</code> file","text":"<p>INPUT.</p> <p>The file <code>seedname.amn</code> contains the projection \\(A_{mn}^{(\\mathbf{k})}\\).</p> <p>First line: a user comment, e.g., the date and time</p> <p>Second line: 3 integers: <code>num_bands</code>, <code>num_kpts</code>, <code>num_wann</code></p> <p>Subsequently \\(\\texttt{num_bands} \\times \\texttt{num_wann} \\times \\texttt{num_kpts}\\) lines: 3 integers and 2 real numbers on each line. The first two integers are the band index \\(m\\) and the projection index \\(n\\), respectively. The third integer specifies the \\(\\mathbf{k}\\) by giving the ordinal corresponding to its position in the list of \\(k\\)-points in <code>seedname.win</code>. The real numbers are the real and imaginary parts, respectively, of the actual \\(A_{mn}^{(\\mathbf{k})}\\).</p>"},{"location":"user_guide/wannier90/postproc/#seednamedmn-file","title":"<code>seedname.dmn</code> file","text":"<p>INPUT.</p> <p>The file <code>seedname.dmn</code> contains the data needed to construct symmetry-adapted Wannier functions\u00a0<sup>5</sup>. Required if <code>site_symmetry = .true.</code></p> <p>First line: a user comment, e.g., the date and time</p> <p>Second line: 4 integers: <code>num_bands</code>, <code>nsymmetry</code>, <code>nkptirr</code>, <code>num_kpts</code>.</p> <ul> <li><code>nsymmetry</code>: the number of symmetry operations</li> <li><code>nkptirr</code>: the number of irreducible k-points</li> </ul> <p>Blank line</p> <p><code>num_kpts</code> integers: Mapping between full k- and irreducible k-points. Each k-point is related to some k-point in the irreducible BZ. The information of this mapping is written. Each entry corresponds to a k-point in the full BZ, in the order in which they appear in the k-point list in <code>seedname.win</code> file. The (integer) value of each entry is the k-point index in the IBZ to which the k-point maps. The number of unique values is equal to the number of k-points in the IBZ. The data is written 10 values per line.</p> <p>Blank line</p> <p><code>nkptirr</code> integers: List of irreducible k-points. Each entry corresponds to a k-point of the IBZ. The (integer) value of each entry is the k-point index corresponding to the k-point list in <code>seedname.win</code> file. The values should be between 1 and <code>num_kpts</code>. The data is written 10 values per line.</p> <p>Blank line</p> <p><code>nkptirr</code> blocks of <code>nsymmetry</code> integer data (each block separated by a blank line): List of k-points obtained by acting the symmetry operations on the irreducible k-points. The data is written 10 values per line.</p> <p>Blank line</p> <p>\\(\\texttt{nsymmetry} \\times \\texttt{nkptirr}\\) blocks of data: The information of \\(D\\) matrix in Eq. (15) of Ref.\u00a0<sup>5</sup>. Each block contains \\(\\texttt{num_wann} \\times \\texttt{num_wann}\\) lines and is separated by a blank line. The data are stored in <code>d_matrix_wann(m,n,isym,ikirr)</code> with \\(\\texttt{m}, \\texttt{n} \\in [1,\\texttt{num_wann}]\\), \\(\\texttt{isym} \\in [1,\\texttt{nsymmetry}]\\), and \\(\\texttt{ikirr} \\in [1,\\texttt{nkptirr}]\\). The order of the elements is such that left indices run faster than right indices (<code>m</code>: fastest, <code>ikirr</code>: slowest).</p> <p>Blank line</p> <p>\\(\\texttt{nsymmetry} \\times \\texttt{nkptirr}\\) blocks of data:\\ The information of \\(\\tilde d\\) matrix in Eq. (17) of Ref.\u00a0<sup>5</sup>. Each block contains \\(\\texttt{num_bands} \\times \\texttt{num_bands}\\) lines and is separated by a blank line. The data are stored in <code>d_matrix_band(m,n,isym,ikirr)</code> with \\(\\texttt{m}, \\texttt{n} \\in [1,\\texttt{num_bands}]\\), \\(\\texttt{isym} \\in [1,\\texttt{nsymmetry}]\\), and \\(\\texttt{ikirr} \\in [1,\\texttt{nkptirr}]\\). The order of the elements is such that left indices run faster than right indices (<code>m</code>: fastest, <code>ikirr</code>: slowest).</p>"},{"location":"user_guide/wannier90/postproc/#seednameeig-file","title":"<code>seedname.eig</code> file","text":"<p>INPUT.</p> <p>Required if any of <code>disentanglement</code>, <code>plot_bands</code>, <code>plot_fermi_surface</code> or <code>write_hr</code> are <code>.true.</code></p> <p>The file <code>seedname.eig</code> contains the Kohn-Sham eigenvalues \\(\\varepsilon_{n\\mathbf{k}}\\) (in eV) at each point in the Monkhorst-Pack mesh.</p> <p>Each line consist of two integers and a real number. The first integer is the band index, the second integer gives the ordinal corresponding to the \\(k\\)-point in the list of \\(k\\)-points in <code>seedname.win</code>, and the real number is the eigenvalue.</p> <p>E.g.,</p> Input file<pre><code>            1           1  -6.43858831271328\n            2           1   19.3977795287297\n            3           1   19.3977795287297\n            4           1   19.3977795287298\n</code></pre>"},{"location":"user_guide/wannier90/postproc/#interface-with-pwscf","title":"Interface with pwscf","text":"<p>Interfaces between <code>wannier90</code>\u00a0and many ab-initio codes such as <code>pwscf</code>, <code>abinit</code> (http://www.abinit.org), <code>siesta</code> (http://www.icmab.es/siesta/), <code>fleur</code>, <code>VASP</code> and <code>Wien2k</code> (http://www.wien2k.at) are available. Here we describe the seamless interface between <code>wannier90</code>\u00a0and <code>pwscf</code>, a plane-wave DFT code that comes as part of the Quantum ESPRESSO package (see http://www.quantum-espresso.org). You will need to download and compile <code>pwscf</code>\u00a0(i.e., the <code>pw.x</code> code) and the post-processing interface <code>pw2wannier90.x</code>. Please refer to the documentation that comes with the Quantum ESPRESSO distribution for instructions.</p> <ol> <li> <p>Run 'scf'/'nscf' calculation(s) with <code>pw</code></p> </li> <li> <p>Run <code>wannier90</code>\u00a0with <code>postproc_setup</code>\u00a0=\u00a0<code>.true.</code> to generate     <code>seedname.nnkp</code></p> </li> <li> <p>Run <code>pw2wannier90</code>. First it reads an input file, e.g.,     <code>seedname.pw2wan</code>, which defines <code>prefix</code> and <code>outdir</code> for the     underlying 'scf' calculation, as well as the name of the file     <code>seedname.nnkp</code>, and does a consistency check between the direct and     reciprocal lattice vectors read from <code>seedname.nnkp</code> and those     defined in the files specified by <code>prefix</code>. <code>pw2wannier90</code> generates     <code>seedname.mmn</code>, <code>seedname.amn</code> and <code>seedname.eig</code>. <code>seedname.dmn</code>     and <code>seedname.sym</code> files are additionally created when     <code>write_dmn = .true.</code> (see below).</p> </li> <li> <p>Run <code>wannier90</code> with <code>postproc_setup</code>\u00a0=\u00a0<code>.false.</code> to disentangle     bands (if required), localise MLWF, and use MLWF for plotting,     bandstructures, Fermi surfaces etc.</p> </li> </ol> <p>Examples of how the interface with <code>pwscf</code>\u00a0works are given in the <code>wannier90</code>\u00a0Tutorial.</p>"},{"location":"user_guide/wannier90/postproc/#seednamepw2wan","title":"<code>seedname.pw2wan</code>","text":"<p>A number of keywords may be specified in the <code>pw2wannier90</code> input file:</p> <ul> <li> <p><code>outdir</code> -- Location to write output files. Default is <code>`./'</code></p> </li> <li> <p><code>prefix</code> -- Prefix for the <code>pwscf</code>\u00a0calculation. Default     is <code>` '</code></p> </li> <li> <p><code>seedname</code> -- Seedname for the <code>wannier90</code>\u00a0calculation. Default is     <code>`wannier'</code></p> </li> <li> <p><code>spin_component</code> -- Spin component. Takes values <code>`up'</code>,     <code>`down'</code> or <code>`none'</code> (default).</p> </li> <li> <p><code>wan_mode</code> -- Either <code>`standalone'</code> (default) or <code>`library'</code></p> </li> <li> <p><code>write_unk</code> -- Set to <code>.true.</code> to write the periodic part of the     Bloch functions for plotting in <code>wannier90</code>. Default is <code>.false.</code></p> </li> <li> <p><code>reduce_unk</code> -- Set to <code>.true.</code> to reduce file-size (and resolution)     of Bloch functions by a factor of 8. Default is <code>.false.</code> (only     relevant if <code>write_unk=.true.</code>)</p> <p>Note</p> <p>Note that there is a small bug with this feature in v3.2 (and subsequent patches) of <code>quantum-espresso</code>. Please use a later version (if available) or the CVS version of <code>pw2wannier90.f90</code>, which has been fixed.</p> </li> <li> <p><code>wvfn_formatted</code> -- Set to <code>.true.</code> to write formatted     wavefunctions. Default is <code>.false.</code> (only relevant if     <code>write_unk=.true.</code>)</p> </li> <li> <p><code>write_amn</code> -- Set to <code>.false.</code> if \\(A_{mn}^{(\\mathbf{k})}\\) not     required. Default is <code>.true.</code></p> </li> <li> <p><code>write_mmn</code> -- Set to <code>.false.</code> if \\(M_{mn}^{(\\mathbf{k,b})}\\) not     required. Default is <code>.true.</code></p> </li> <li> <p><code>write_spn</code> -- Set to <code>.true.</code> to write out the matrix elements of     \\(S\\) between Bloch states (non-collinear spin calculation only).     Default is <code>.false.</code></p> </li> <li> <p><code>spn_formatted</code> -- Set to <code>.true.</code> to write spn data as a formatted     file. Default is <code>.false.</code> (only relevant if <code>write_spn=.true.</code>)</p> </li> <li> <p><code>write_uHu</code> -- Set to <code>.true.</code> to write out the matrix elements</p> \\[ \\langle u_{n{\\bf k}+{\\bf b}_1}\\vert H_{\\bf k}\\vert u_{m{\\bf k}+{\\bf b}_2}\\rangle. \\] <p>Default is <code>.false.</code></p> </li> <li> <p><code>uHu_formatted</code> -- Set to <code>.true.</code> to write uHu data as a formatted     file. Default is <code>.false.</code> (only relevant if <code>write_uHu=.true.</code>)</p> </li> <li> <p><code>write_uIu</code> -- Set to <code>.true.</code> to write out the matrix elements of</p> \\[ \\langle  u_{n{\\bf k}+{\\bf b}_1}\\vert u_{m{\\bf k}+{\\bf b}_2}\\rangle. \\] <p>Default is <code>.false.</code></p> </li> <li> <p><code>uIu_formatted</code> -- Set to <code>.true.</code> to write uIu data as a formatted     file. Default is <code>.false.</code> (only relevant if <code>write_uIu=.true.</code>)</p> </li> <li> <p><code>write_unkg</code> -- Set to <code>.true.</code> to write the first few Fourier     components of the periodic parts of the Bloch functions.</p> </li> <li> <p><code>write_dmn</code> -- Set to <code>.true.</code> to construct symmetry-adapted Wannier     functions. Default is <code>.false.</code></p> </li> <li> <p><code>read_sym</code> -- Set to <code>.true.</code> to customize symmetry operations to be     used in symmetry-adapted mode. When <code>read_sym = .true.</code>, an     additional input <code>seedname.sym</code> is required. Default is <code>.false.</code>     (only relevant if <code>write_dmn=.true.</code>).</p> </li> <li> <p><code>irr_bz</code> -- Set to <code>.true.</code> to use the irreducible BZ calculation     (see Section \"Irreducible BZ calculation\").</p> </li> <li> <p><code>atom_proj</code> -- Set to <code>.true.</code> to use pseudo-atomic orbitals for     computing <code>amn</code>. Default is <code>.false.</code>.</p> </li> <li> <p><code>atom_proj_exclude</code> -- A list of integers specifying the indices of     pseudo-atomic projectors to be excluded from computing <code>amn</code>. Used     only when <code>atom_proj = .true.</code>. No default.</p> </li> <li> <p><code>atom_proj_ext</code> -- Set to <code>.true.</code> to use external pseudo-atomic     orbitals for computing <code>amn</code>, will read data files from directory     <code>atom_proj_dir</code>. Used only when <code>atom_proj = .true.</code>. Default is     <code>.false.</code>.</p> </li> <li> <p><code>atom_proj_dir</code> -- A string specifying the directory for external     pseudo-atomic projectors. Used only when <code>atom_proj = .true.</code> and     <code>atom_proj_ext = .true.</code>. No default.</p> </li> </ul> <p>For examples of use, refer to the <code>wannier90</code>\u00a0Tutorial.</p>"},{"location":"user_guide/wannier90/postproc/#seednamesym","title":"<code>seedname.sym</code>","text":"<p>If <code>read_sym = .true.</code>, then this additional input file is required for <code>pw2wannier90.x</code> if <code>read_sym = .false.</code>, then this file is written by <code>pw2wannier90.x</code> (only for reference -- it is not used in subsequent calculations)</p> <p>The file <code>seedname.sym</code> contains the information of symmetry operations used to create symmetry-adapted Wannier functions. If <code>read_sym = .false.</code> (default), <code>pw2wannier90.x</code> uses the full symmetry recognized by <code>pw.x</code>. If <code>read_sym = .true.</code>, you can specify symmetry operations to be used in symmetry-adapted mode.</p> <p>First line: an integer: <code>nsymmetry</code> (number of symmetry operations)</p> <p>Second line: blank</p> <p>Then: <code>nsymmetry</code> blocks of data. Each block (separated by a blank line) consists of four lines. The order of the data in each block is as follows:</p> Input file<pre><code>      R(1,1)   R(2,1)   R(3,1)\n      R(1,2)   R(2,2)   R(3,2)\n      R(1,3)   R(2,3)   R(3,3)\n       t(1)     t(2)     t(3)   \n</code></pre> <p>Here, \\(R\\) is the rotational part of symmetry operations (\\(3\\times3\\) matrix), and \\(\\bf t\\) is the fractional translation in the unit of \"<code>alat</code>\" (refer the definition of \"<code>alat</code>\" to the manual of <code>pwscf</code>). Both data are given in Cartesian coordinates. The symmetry operations act on a point \\(\\bf r\\) as \\({\\bf r} R - {\\bf t}\\).</p>"},{"location":"user_guide/wannier90/postproc/#irreducible-bz-calculation","title":"Irreducible BZ calculation","text":"<p>This section explains how to construct Wannier functions using wavefunctions calculated only in the irreducible BZ (IBZ). Using this option, users only have to calculate wavefunctions, overlap matrices (\\(M_{mn}\\)) and projection matrices (\\(A_{mn}\\)) in the IBZ, which will reduce the computational cost. Currently, this feature is implemented only in the interface code with Quantum ESPRESSO and requires an additional python package, symWannier. See also the website of symWannier and Ref. <sup>6</sup>.</p> <p>Note</p> <p>The <code>symWannier</code> package also has the ability to construct symmetry-adapted Wannier functions only from the <code>.mmn,</code>.amn<code>and</code>.eig` files in the IBZ and some symmetry information.</p> <p>The procedure is as follows.</p> <ol> <li> <p>Run <code>scf</code>/<code>nscf</code> calculation(s) with Quantum ESPRESSO <code>pw.x</code>. In the <code>nscf</code>     calculation, users only have to calculate k-points in the IBZ.</p> <p>E.g.:</p> Input file<pre><code>K_POINTS {automatic}\n4 4 4 0 0 0\n</code></pre> <p>Users also have the option to skip the <code>nscf</code> calculation, if the grid of the <code>scf</code> step is already sufficient.</p> </li> <li> <p>Run\u00a0Wannier90 with <code>postproc_setup = .true.</code> (or equivalently with     the <code>-pp</code> command line flag) to generate the file <code>seedname.nnkp</code>.</p> </li> <li> <p>Run <code>pw2wannier90</code> with <code>irr_bz = .true.</code> in the input file.     <code>pw2wannier90</code> then generates the files <code>seedname.immn</code>, <code>seedname.iamn</code>,     <code>seedname.ieig</code> and <code>seedname.isym</code>.</p> </li> <li> <p>Run the python code <code>write_full_data.py</code>, part of the <code>symWannier</code> package.     You can first install the package from     GitHub and then     run the script as</p> Terminal<pre><code>python write_full_data.py &lt;seedname&gt;\n</code></pre> <p>(replace <code>&lt;seedname&gt;</code> with the seedname of your calculation).</p> <p>This python script generates the \\(M_{mn}\\) and \\(A_{mn}\\) matrices, and Kohn-Sham eigenvalues in the full BZ (<code>seedname.mmn</code>, <code>seedname.amn</code>, and <code>seedname.eig</code>) from those in the IBZ (<code>seedname.immn</code>, <code>seedname.iamn</code>, and <code>seedname.ieig</code>) by using the symmetry information (<code>seedname.isym</code>). The relations between these quantites in the IBZ and full BZ are explained in Ref.\u00a0<sup>6</sup>.</p> </li> <li> <p>Run <code>wannier90</code> (with <code>postproc_setup = .false.</code> or, equivalently,     without the <code>-pp</code> command line option).</p> </li> </ol>"},{"location":"user_guide/wannier90/postproc/#seednameimmn-file","title":"<code>seedname.immn</code> file","text":"<p>INPUT</p> <p>The format is the same as <code>seedname.mmn</code>, except that the number of kpoints is the number of k-points in the IBZ. See also the section on the <code>seedname.mmn</code> file.</p>"},{"location":"user_guide/wannier90/postproc/#seednameiamn-file","title":"<code>seedname.iamn</code> file","text":"<p>INPUT</p> <p>The format is the same as <code>seedname.amn</code>, except that the number of kpoints is the number of k-points in the IBZ. See also See also\u00a0the section on the  <code>seedname.amn</code> file.</p>"},{"location":"user_guide/wannier90/postproc/#seednameieig-file","title":"<code>seedname.ieig</code> file","text":"<p>INPUT</p> <p>The format is the same as <code>seedname.eig</code>, except that the number of kpoints is the number of k-points in the IBZ. See also See also\u00a0the section on the  <code>seedname.eig</code> file.</p>"},{"location":"user_guide/wannier90/postproc/#seednameisym-file","title":"<code>seedname.isym</code> file","text":"<p>INPUT</p> <p>The file <code>seedname.isym</code> contains the data needed to construct Wannier functions from imformation computed only in the IBZ.</p> <p>First line: a user comment, e.g., the date and time</p> <p>Second line: 2 integers: <code>nsymmetry</code>, <code>spinors</code>, where:</p> <ul> <li><code>nsymmetry</code>: the number of symmetry operations</li> <li><code>spinors</code>: <code>1</code> for spinor case or <code>0</code> for non-spinor case</li> </ul> <p>Then: <code>nsymmetry</code> blocks of data. Each block describes a symmetry operation, \\(\\hat{g}\\), and consists of 7 lines (11 lines for the spinor case). The order of the data in each block is as follows:</p> <p>Non-spinor case:</p> Input file<pre><code>a comment\nR(1,1)   R(2,1)   R(3,1)\nR(1,2)   R(2,2)   R(3,2)\nR(1,3)   R(2,3)   R(3,3)\n t(1)     t(2)     t(3)\n T\n invs\n</code></pre> <p>Spinor case:</p> Input file<pre><code>a comment\nR(1,1)   R(2,1)   R(3,1)\nR(1,2)   R(2,2)   R(3,2)\nR(1,3)   R(2,3)   R(3,3)\n t(1)     t(2)     t(3)\n T\nu(1,1).real  u(1,1).imag\nu(2,1).real  u(2,1).imag\nu(1,2).real  u(1,2).imag\nu(2,2).real  u(2,2).imag\n invs\n</code></pre> <p>Here, \\(R\\) is the rotational part of symmetry operations, (\\(3 \\times 3\\) integer matrix), and \\(\\bf t\\) is the fractional translation in crystal coordinates. The symmetry operations act on a point \\(\\bf r\\) in crystal coordinates as \\(\\hat{g} {\\bf r} = {\\bf r} R - {\\bf t}\\). \\(T=1\\) (\\(T=0\\)) indicates that this symmetry operation includes (does not include) time-reversal operation, respectively. \\(u\\) is the SU(2) rotation matrix for the spinor part. <code>invs</code> represents the symmetry operation corresponding to \\(\\hat{g}^{-1}\\).</p> <p>2 blank lines</p> <p>Then: An integer: <code>nk_ibz</code>, the number of k-points in the IBZ.</p> <p>Then: <code>nk_ibz</code> lines, with 3 real numbers on each line corresponding to a list of k-points in the IBZ in crystal coordinates.</p> <p>2 blank lines</p> <p>Then: 2 integers: <code>num_bands</code>, <code>nblocks</code></p> <p>Then: <code>nblocks</code> blocks of data for \\(h_{mn}({\\bf k})\\). <code>nblocks</code> is a number of symmetry operations, \\(\\hat{h}({\\bf k})\\), where \\(\\hat{h} \\bf k = \\bf k\\) and \\(\\bf k \\in\\) IBZ.</p> <p>First line of each block: 3 integers. These specify the k-point in the IBZ (a number from 1 to <code>nk_ibz</code>), the symmetry operation, \\(\\hat{h}({\\bf k})\\), (a number from 1 to <code>nsymmetry</code>) and a number of non-zero elements of \\(\\hat{h}({\\bf k})\\).</p> <p>Subsequent lines of each block: 2 integers and 2 real numbers per line. These specify band indeces, \\(m\\) and \\(n\\), and real and imaginary parts of \\(h_{mn}({\\bf k})\\). Only non-zero components of \\(h_{mn}({\\bf k})\\) are written.</p> <p>2 blank lines</p> <p>Then: An integer: <code>num_wann</code>: The number of Wannier functions.</p> <p>Then: <code>nsymmetry</code> blocks of data.</p> <p>First line of each block: 2 integers. These specify the symmetry operation, \\(\\hat{g}\\), and a number of non-zero elements of the rotation matrix, \\(D_{mn}(\\hat{g})\\).</p> <p>Subsequent lines of each block: 2 integers and 2 real numbers per line. These specify indeces of Wannier functions, \\(m\\) and \\(n\\), and real and imaginary parts of \\(D_{mn}(\\hat{g})\\).</p> <ol> <li> <p>N. Marzari and D. Vanderbilt. Maximally localized generalized wannier functions for composite energy bands. Phys. Rev. B, 56:12847, 1997.\u00a0\u21a9\u21a9</p> </li> <li> <p>I. Souza, N. Marzari, and D. Vanderbilt. Maximally localized wannier functions for entangled energy bands. Phys. Rev. B, 65:035109, 2001.\u00a0\u21a9</p> </li> <li> <p>A. Damle and L. Lin. Disentanglement via entanglement: A unified method for Wannier localization. ArXiv e-prints, March 2017. URL: http://adsabs.harvard.edu/abs/2017arXiv170306958D, arXiv:1703.06958.\u00a0\u21a9</p> </li> <li> <p>Junfeng Qiao, Giovanni Pizzi, and Nicola Marzari. Projectability disentanglement for accurate and automated electronic-structure Hamiltonians. npj Comput. Mater., 9(1):208, Nov 2023. doi:10.1038/s41524-023-01146-w.\u00a0\u21a9</p> </li> <li> <p>R. Sakuma. Symmetry-adapted wannier functions in the maximal localization procedure. Phys. Rev. B, 87:235109, 2013.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Takashi Koretsune. Construction of maximally-localized wannier functions using crystal symmetry. Comp. Phys. Comm., 285:108645, 2023. doi:10.1016/j.cpc.2022.108645.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/projections/","title":"Projections","text":""},{"location":"user_guide/wannier90/projections/#sec:proj","title":"Specification of projections in <code>seedname.win</code>","text":"<p>Here we describe the projection functions used to construct the initial guess \\(A_{mn}^{(\\mathbf{k})}\\) for the unitary transformations.</p> <p>Each projection is associated with a site and an angular momentum state defining the projection function. Optionally, one may define, for each projection, the spatial orientation, the radial part, the diffusivity, and the volume over which real-space overlaps \\(A_{mn}\\) are calculated.</p> <p>The code is able to</p> <ol> <li> <p>project onto s,p,d and f angular momentum states, plus the hybrids     sp, sp\\(^2\\), sp\\(^3\\), sp\\(^3\\)d, sp\\(^3\\)d\\(^2\\).</p> </li> <li> <p>control the radial part of the projection functions to allow higher     angular momentum states, e.g., both 3s and 4s in silicon.</p> </li> </ol> <p>The atomic orbitals of the hydrogen atom provide a good basis to use for constructing the projection functions: analytical mathematical forms exist in terms of the good quantum numbers \\(n\\), \\(l\\) and \\(m\\); hybrid orbitals (sp, sp\\(^{2}\\), sp\\(^{3}\\), sp\\(^{3}\\)d etc.) can be constructed by simple linear combination \\(|\\phi\\rangle = \\sum_{nlm} C_{nlm}|nlm\\rangle\\) for some coefficients \\(C_{nlm}\\).</p> <p>The angular functions that use as a basis for the projections are not the canonical spherical harmonics \\(Y_{lm}\\) of the hydrogenic Schr\u00f6dinger equation but rather the real (in the sense of non-imaginary) states \\(\\Theta_{lm_{\\mathrm{r}}}\\), obtained by a unitary transformation. For example, the canonical eigenstates associated with \\(l=1\\), \\(m=\\{-1,0,1\\}\\) are not the real p\\(_{x}\\), p\\(_{y}\\) and p\\(_{z}\\) that we want. See Section\u00a0Orbital Definitions for our mathematical conventions regarding projection orbitals for different \\(n\\), \\(l\\) and \\(m_{\\mathrm{r}}\\).</p> <p>We use the following format to specify projections in <code>&lt;seedname&gt;.win</code>:</p> Input file<pre><code>Begin Projections\n[units]\nsite:ang_mtm:zaxis:xaxis:radial:zona\n    \u22ee\nEnd Projections\n</code></pre>"},{"location":"user_guide/wannier90/projections/#notes","title":"Notes","text":"<p><code>units</code>: Optional. Either <code>Ang</code> or <code>Bohr</code> to specify whether the projection centres specified in this block (if given in Cartesian co-ordinates) are in units of Angstrom or Bohr, respectively. The default value is <code>Ang</code>.</p> <p><code>site</code>: <code>C</code>, <code>Al</code>, etc. applies to all atoms of that type <code>f=0,0.50,0</code> -- centre on <code>(0.0,0.5,0.0)</code> in fractional coordinates (crystallographic units) relative to the direct lattice vectors <code>c=0.0,0.805,0.0</code> -- centre on <code>(0.0,0.805,0.0)</code> in Cartesian coordinates in units specified by the optional string <code>units</code> in the first line of the projections block (see above).</p> <p><code>ang_mtm</code>: Angular momentum states may be specified by <code>l</code> and <code>mr</code>, or by the appropriate character string. See Tables\u00a0Angular functions and Hybrids. Examples: <code>l=2,mr=1</code> or <code>dz2</code> -- a single projection with \\(l=2\\), \\(m_{\\textrm{r}}=1\\) (i.e., d\\(_{z^{2}}\\)) <code>l=2,mr=1,4</code> or <code>dz2,dx2-y2</code> -- two functions: d\\(_{z^{2}}\\) and d\\(_{xz}\\) <code>l=-3</code> or <code>sp3</code> -- four sp\\(^{3}\\) hybrids Specific hybrid orbitals may be specified as follows: <code>l=-3,mr=1,3</code> or <code>sp3-1,sp3-3</code> -- two specific sp\\(^{3}\\) hybrids Multiple states may be specified by separating with '<code>;</code>', e.g., <code>sp3;l=0</code> or <code>l=-3;l=0</code> -- four sp\\(^{3}\\) hybrids and one s orbital</p> <p><code>zaxis</code> (optional): <code>z=1,1,1</code> -- set the \\(z\\)-axis to be in the (1,1,1) direction. Default is <code>z=0,0,1</code></p> <p><code>xaxis</code> (optional): <code>x=1,1,1</code> -- set the \\(x\\)-axis to be in the (1,1,1) direction. Default is <code>x=1,0,0</code></p> <p><code>radial</code> (optional): <code>r=2</code> -- use a radial function with one node (ie second highest pseudostate with that angular momentum). Default is <code>r=1</code>. Radial functions associated with different values of <code>r</code> should be orthogonal to each other.</p> <p><code>zona</code> (optional): <code>zona=2.0</code> -- the value of \\(\\frac{Z}{a}\\) for the radial part of the atomic orbital (controls the diffusivity of the radial function). Units always in reciprocal Angstrom. Default is <code>zona=1.0</code>.</p>"},{"location":"user_guide/wannier90/projections/#examples","title":"Examples","text":"<ul> <li> <p>CuO, s,p and d on all Cu; sp\\(^3\\) hybrids on O:</p> <p><code>Cu:l=0;l=1;l=2</code></p> <p><code>O:l=-3</code> or <code>O:sp3</code></p> </li> <li> <p>A single projection onto a p\\(_z\\) orbital orientated in the (1,1,1) direction:</p> <p><code>c=0,0,0:l=1,mr=1:z=1,1,1</code> or <code>c=0,0,0:pz:z=1,1,1</code></p> </li> <li> <p>Project onto s, p and d (with no radial nodes), and s and p (with one radial node) in silicon:</p> Input file<pre><code>Si:l=0;l=1;l=2\nSi:l=0;l=1:r=2\n</code></pre> </li> </ul>"},{"location":"user_guide/wannier90/projections/#spinor-projections","title":"Spinor Projections","text":"<p>When <code>spinors=.true.</code> it is possible to select a set of localised functions to project onto 'up' states and a set to project onto 'down' states where, for complete flexibility, it is also possible to set the local spin quantisation axis.</p> <p>Note, however, that this feature requires a recent version of the interface between the ab-initio code and Wannier90 (i.e., written after the release of the 2.0 version, in October 2013) supporting spinor projections.</p> Input file<pre><code>Begin Projections\n[units]\nsite:ang_mtm:zaxis:xaxis:radial:zona(spin)[quant_dir]\n    \u22ee\nEnd Projections\n</code></pre> <p><code>spin</code> (optional): Choose projection onto 'up' or 'down' states <code>u</code> -- project onto 'up' states. <code>d</code> -- project onto 'down' states. Default is <code>u,d</code></p> <p><code>quant_dir</code> (optional): <code>1,0,0</code> -- set the spin quantisation axis to be in the (1,0,0) direction. Default is <code>0,0,1</code></p>"},{"location":"user_guide/wannier90/projections/#spinor-examples","title":"Spinor Examples","text":"<ul> <li> <p>18 projections on an iron site</p> <p><code>Fe:sp3d2;dxy;dxx;dyz</code></p> </li> <li> <p>same as above</p> <p><code>Fe:sp3d2;dxy;dxx;dyz(u,d)</code></p> </li> <li> <p>same as above</p> <p><code>Fe:sp3d2;dxy;dxz;dyz(u,d)[0,0,1]</code></p> </li> <li> <p>same as above but quantisation axis is now x</p> <p><code>Fe:sp3d2;dxy;dxz;dyz(u,d)[1,0,0]</code></p> </li> <li> <p>now only 9 projections onto up states</p> <p><code>Fe:sp3d2;dxy;dxz;dyz(u)</code></p> </li> <li> <p>9 projections onto up-states and 3 on down</p> Input file<pre><code>Fe:sp3d2;dxy;dxz;dyz(u)\nFe:dxy;dxz;dyz(d)\n</code></pre> </li> <li> <p>projections onto alternate spin states for two lattice sites (Cr1,     Cr2)</p> Input file<pre><code>Cr1:d(u)\nCr2:d(d)\n</code></pre> </li> </ul>"},{"location":"user_guide/wannier90/projections/#short-cuts","title":"Short-Cuts","text":""},{"location":"user_guide/wannier90/projections/#random-projections","title":"Random projections","text":"<p>It is possible to specify the projections, for example, as follows:</p> Input file<pre><code>Begin Projections\nrandom\nC:sp3\nEnd Projections\n</code></pre> <p>in which case <code>wannier90</code>\u00a0uses four sp\\(^3\\) orbitals centred on each C atom and then chooses the appropriate number of randomly-centred s-type Gaussian functions for the remaining projection functions. If the block only consists of the string <code>random</code> and no specific projection centres are given, then all of the projection centres are chosen randomly.</p>"},{"location":"user_guide/wannier90/projections/#bloch-phases","title":"Bloch phases","text":"<p>Setting <code>use_bloch_phases = true</code> in the input file absolves the user of the need to specify explicit projections. In this case, the Bloch wave-functions are used as the projection orbitals, namely \\(A_{mn}^{(\\mathbf{k})} = \\langle\\psi_{m\\mathbf{k}}|\\psi_{n\\mathbf{k}}\\rangle = \\delta_{mn}\\).</p>"},{"location":"user_guide/wannier90/projections/#orbital-definitions","title":"Orbital Definitions","text":"<p>The angular functions \\(\\Theta_{lm_{\\mathrm{r}}}(\\theta,\\varphi)\\) associated with particular values of \\(l\\) and \\(m_{\\mathrm{r}}\\) are given in Tables\u00a0Angular functions and Hybrids.</p> <p>The radial functions \\(R_{\\mathrm{r}}(r)\\) associated with different values of \\(r\\) should be orthogonal. One choice would be to take the set of solutions to the radial part of the hydrogenic Schr\u00f6dinger equation for \\(l=0\\), i.e., the radial parts of the 1s, 2s, 3s...\u00a0orbitals, which are given in Table\u00a0Radial functions.</p>"},{"location":"user_guide/wannier90/projections/#angular-functions","title":"Angular functions","text":"\\(l\\) \\(m_{\\mathrm{r}}\\) Name \\(\\Theta_{lm_{\\mathrm{r}}}(\\theta,\\varphi)\\) 0 1 <code>s</code> \\(\\frac{1}{\\sqrt{4\\pi}}\\) 1 1 <code>pz</code> \\(\\sqrt{\\frac{3}{4\\pi}}\\cos\\theta\\) 1 2 <code>px</code> \\(\\sqrt{\\frac{3}{4\\pi}}\\sin\\theta\\cos\\varphi\\) 1 3 <code>py</code> \\(\\sqrt{\\frac{3}{4\\pi}}\\sin\\theta\\sin\\varphi\\) 2 1 <code>dz2</code> \\(\\sqrt{\\frac{5}{16\\pi}}(3\\cos^{2}\\theta -1)\\) 2 2 <code>dxz</code> \\(\\sqrt{\\frac{15}{4\\pi}}\\sin\\theta\\cos\\theta\\cos\\varphi\\) 2 3 <code>dyz</code> \\(\\sqrt{\\frac{15}{4\\pi}}\\sin\\theta\\cos\\theta\\sin\\varphi\\) 2 4 <code>dx2-y2</code> \\(\\sqrt{\\frac{15}{16\\pi}}\\sin^{2}\\theta\\cos2\\varphi\\) 2 5 <code>dxy</code> \\(\\sqrt{\\frac{15}{16\\pi}}\\sin^{2}\\theta\\sin2\\varphi\\) 3 1 <code>fz3</code> \\(\\frac{\\sqrt{7}}{4\\sqrt{\\pi}}(5\\cos^{3}\\theta-3\\cos\\theta)\\) 3 2 <code>fxz2</code> \\(\\frac{\\sqrt{21}}{4\\sqrt{2\\pi}}(5\\cos^{2}\\theta-1)\\sin\\theta\\cos\\varphi\\) 3 3 <code>fyz2</code> \\(\\frac{\\sqrt{21}}{4\\sqrt{2\\pi}}(5\\cos^{2}\\theta-1)\\sin\\theta\\sin\\varphi\\) 3 4 <code>fz(x2-y2)</code> \\(\\frac{\\sqrt{105}}{4\\sqrt{\\pi}}\\sin^{2}\\theta\\cos\\theta\\cos2\\varphi\\) 3 5 <code>fxyz</code> \\(\\frac{\\sqrt{105}}{4\\sqrt{\\pi}}\\sin^{2}\\theta\\cos\\theta\\sin2\\varphi\\) 3 6 <code>fx(x2-3y2)</code> \\(\\frac{\\sqrt{35}}{4\\sqrt{2\\pi}}\\sin^{3}\\theta(\\cos^{2}\\varphi-3\\sin^{2}\\varphi)\\cos\\varphi\\) 3 7 <code>fy(3x2-y2)</code> \\(\\frac{\\sqrt{35}}{4\\sqrt{2\\pi}}\\sin^{3}\\theta(3\\cos^{2}\\varphi-\\sin^{2}\\varphi)\\sin\\varphi\\) <p>Angular functions \\(\\Theta_{lm_{\\mathrm{r}}}(\\theta,\\varphi)\\) associated with particular values of \\(l\\) and \\(m_{\\mathrm{r}}\\) for \\(l\\ge0\\).</p>"},{"location":"user_guide/wannier90/projections/#hybrids","title":"Hybrids","text":"\\(l\\) \\(m_{\\mathrm{r}}\\) Name \\(\\Theta_{lm_{\\mathrm{r}}}(\\theta,\\varphi)\\) -1 1 <code>sp-1</code> \\(\\frac{1}{\\sqrt{2}}\\)<code>s</code> \\(+\\frac{1}{\\sqrt{2}}\\)<code>px</code> -1 2 <code>sp-2</code> \\(\\frac{1}{\\sqrt{2}}\\)<code>s</code> \\(-\\frac{1}{\\sqrt{2}}\\)<code>px</code> -2 1 <code>sp2-1</code> \\(\\frac{1}{\\sqrt{3}}\\)<code>s</code> \\(-\\frac{1}{\\sqrt{6}}\\)<code>px</code> \\(+\\frac{1}{\\sqrt{2}}\\)<code>py</code> -2 2 <code>sp2-2</code> \\(\\frac{1}{\\sqrt{3}}\\)<code>s</code> \\(-\\frac{1}{\\sqrt{6}}\\)<code>px</code> \\(-\\frac{1}{\\sqrt{2}}\\)<code>py</code> -2 3 <code>sp2-3</code> \\(\\frac{1}{\\sqrt{3}}\\)<code>s</code> \\(+\\frac{2}{\\sqrt{6}}\\)<code>px</code> -3 1 <code>sp3-1</code> \\(\\frac{1}{2}\\)(<code>s</code> \\(+\\) <code>px</code> \\(+\\) <code>py</code> -3 2 <code>sp3-2</code> \\(\\frac{1}{2}\\)(<code>s</code> \\(+\\) <code>px</code> \\(-\\) <code>py</code> \\(-\\) <code>pz</code>) -3 3 <code>sp3-3</code> \\(\\frac{1}{2}\\)(<code>s</code> \\(-\\) <code>px</code> \\(+\\) <code>py</code> \\(-\\) <code>pz</code>) -3 4 <code>sp3-4</code> \\(\\frac{1}{2}\\)(<code>s</code> \\(-\\) <code>px</code> \\(-\\) <code>py</code> \\(+\\) <code>pz</code>) -4 1 <code>sp3d-1</code> \\(\\frac{1}{\\sqrt{3}}\\)<code>s</code> \\(-\\frac{1}{\\sqrt{6}}\\)<code>px</code> \\(+\\frac{1}{\\sqrt{2}}\\)<code>py</code> -4 2 <code>sp3d-2</code> \\(\\frac{1}{\\sqrt{3}}\\)<code>s</code> \\(-\\frac{1}{\\sqrt{6}}\\)<code>px</code> \\(-\\frac{1}{\\sqrt{2}}\\)<code>py</code> -4 3 <code>sp3d-3</code> \\(\\frac{1}{\\sqrt{3}}\\)<code>s</code> \\(+\\frac{2}{\\sqrt{6}}\\)<code>px</code> -4 4 <code>sp3d-4</code> \\(\\frac{1}{\\sqrt{2}}\\)<code>pz</code> \\(+\\frac{1}{\\sqrt{2}}\\)<code>dz2</code> -4 5 <code>sp3d-5</code> \\(-\\frac{1}{\\sqrt{2}}\\)<code>pz</code> \\(+\\frac{1}{\\sqrt{2}}\\)<code>dz2</code> -5 1 <code>sp3d2-1</code> \\(\\frac{1}{\\sqrt{6}}\\)<code>s</code>-\\(\\frac{1}{\\sqrt{2}}\\)<code>px</code>-\\(\\frac{1}{\\sqrt{12}}\\)<code>dz2</code>+\\(\\frac{1}{2}\\)<code>dx2-y2</code> -5 2 <code>sp3d2-2</code> \\(\\frac{1}{\\sqrt{6}}\\)<code>s</code>+\\(\\frac{1}{\\sqrt{2}}\\)<code>px</code>-\\(\\frac{1}{\\sqrt{12}}\\)<code>dz2</code>+\\(\\frac{1}{2}\\)<code>dx2-y2</code> -5 3 <code>sp3d2-3</code> \\(\\frac{1}{\\sqrt{6}}\\)<code>s</code>-\\(\\frac{1}{\\sqrt{2}}\\)<code>py</code>-\\(\\frac{1}{\\sqrt{12}}\\)<code>dz2</code>-\\(\\frac{1}{2}\\)<code>dx2-y2</code> -5 4 <code>sp3d2-4</code> \\(\\frac{1}{\\sqrt{6}}\\)<code>s</code>+\\(\\frac{1}{\\sqrt{2}}\\)<code>py</code>-\\(\\frac{1}{\\sqrt{12}}\\)<code>dz2</code>-\\(\\frac{1}{2}\\)<code>dx2-y2</code> -5 5 <code>sp3d2-5</code> \\(\\frac{1}{\\sqrt{6}}\\)<code>s</code>-\\(\\frac{1}{\\sqrt{2}}\\)<code>pz</code>+\\(\\frac{1}{\\sqrt{3}}\\)<code>dz2</code> -5 6 <code>sp3d2-6</code> \\(\\frac{1}{\\sqrt{6}}\\)<code>s</code>+\\(\\frac{1}{\\sqrt{2}}\\)<code>pz</code>+\\(\\frac{1}{\\sqrt{3}}\\)<code>dz2</code> <p>Angular functions \\(\\Theta_{lm_{\\mathrm{r}}}(\\theta,\\varphi)\\) associated with particular values of \\(l\\) and \\(m_{\\mathrm{r}}\\) for \\(l&lt;0\\), in terms of the orbitals defined in Table\u00a0Angular functions.</p>"},{"location":"user_guide/wannier90/projections/#radial-functions","title":"Radial functions","text":"\\(r\\) \\(R_{\\mathrm{r}}(r)\\) 1 \\(2 \\alpha^{3/2}\\exp(-\\alpha r)\\) 2 \\(\\frac{1}{2\\sqrt{2}}\\alpha^{3/2}(2-\\alpha r)\\exp(-\\alpha r/2)\\) 3 \\(\\sqrt{\\frac{4}{27}}\\alpha^{3/2}(1-2\\alpha r/3+2\\alpha^{2}r^{2}/27)\\exp(-\\alpha r/3)\\) <p>One possible choice for the radial functions \\(R_{\\mathrm{r}}(r)\\) associated with different values of \\(r\\): the set of solutions to the radial part of the hydrogenic Schr\u00f6dinger equation for \\(l=0\\), i.e., the radial parts of the 1s, 2s, 3s\u2026\u00a0orbitals, where \\(\\alpha=Z/a=\\)<code>zona</code>.</p>"},{"location":"user_guide/wannier90/projections/#projections-via-the-scdm-k-method-in-pw2wannier90","title":"Projections via the SCDM-k method in pw2wannier90","text":"<p>For many systems, such as aperiodic systems, crystals with defects, or novel materials with complex band structure, it may be extremely hard to identify a-priori a good initial guess for the projection functions used to generate the \\(A_{mn}^{(\\mathbf{k})}\\) matrices. In these cases, one can use a different approach, known as the SCDM-k method<sup>1</sup>, based on a QR factorization with column pivoting (QRCP) of the density matrix from the self-consistent field calculation, which allows one to avoid the tedious step of specifying a projection block altogether, hence to avoid . This method is robust in generating well localised function with the correct spatial orientations and in general in finding the global minimum of the spread functional \\(\\Omega\\). Any electronic-structure code should in principle be able to implement the SCDM-k method within their interface with Wannier90, however at the moment (develop branch on the GitHub repository July 2019) only the Quantum ESPRESSO package has this capability implemented in the <code>pw2wannier90</code> interface program. Moreover, the <code>pw2wannier90</code> interface program supports also the SCDM-k method for spin-noncollinear systems. The SCDM-k can operate in two modes:</p> <ol> <li> <p>In isolation, i.e., without performing a subsequent Wannier90     optimisation (not recommended). This can be achieved by setting     <code>num_iter=0</code> and <code>dis_num_iter=0</code> in the <code>&lt;seedname&gt;.win</code> input     file. The rationale behind this is that in general the projection     functions obtained with the SCDM-k are already well localised     with the correct spatial orientations. However, the spreads of the     resulting functions are usually larger than the MLWFs ones.</p> </li> <li> <p>In combination with the Marzari-Vanderbilt (recommended option). In     this case, the SCDM-k is only used to generate the initial     \\(A_{mn}^{(\\mathbf{k})}\\) matrices as a replacement scheme for the     projection block.</p> </li> </ol> <p>The following keywords need to be specified in the <code>pw2wannier90.x</code> input file <code>&lt;seedname&gt;.pw2wan</code>:</p> Input file<pre><code>scdm_proj\nscdm_entanglement\nscdm_mu\nscdm_sigma\n</code></pre>"},{"location":"user_guide/wannier90/projections/#projections-via-pseudo-atomic-orbitals-in-pw2wannier90","title":"Projections via pseudo-atomic orbitals in pw2wannier90","text":"<p>When generating pseudopotentials, often the atomic wavefunctions of isolated atom are pseudized and bundled together with the pseudopotential files. These orbitals are often used for computing the projectabilities, for instance, measuring orbital contributions to band structures. Instead of manually specifying the initial projections in the <code>projections</code> block, one can use these pseudo-atomic orbitals to automate the initial projection process.</p> <p>Currently (July 2023), this functionality is implemented in the [quantum-espresso]{.smallcaps} interface, but in principle it can be done in any other interface as well. In the following, we will use the [quantum-espresso]{.smallcaps} interface as an example to illustrate the whole procedure.</p> <p>To activate pseudo-atomic orbital projection, one needs to set <code>auto_projections = .true.</code> in the <code>win</code> file, and remove the <code>projections</code> block.</p> <p>Then in the <code>pw2wannier90</code> input file, one needs to add an additional tag <code>atom_proj = .true.</code>. This will ask <code>pw2wannier90</code> to read the pseudo-atomic orbitals from the pseudopotential files, and use them to compute the <code>amn</code> file.</p> <p>Some times, one may want to exclude semi-core states from Wannierisation, for such cases, one can inspect the stdout of <code>pw2wannier90</code>, which will print the orbitals used for computing <code>amn</code>, e.g.,</p> Output file<pre><code>-------------------------------------\n*** Compute A with atomic projectors\n-------------------------------------\nUse atomic projectors from UPF\n\n(read from pseudopotential files):\nstate # 1: atom 1 (C ), wfc 1 (l=0 m= 1)\nstate # 2: atom 1 (C ), wfc 2 (l=1 m= 1)\nstate # 3: atom 1 (C ), wfc 2 (l=1 m= 2)\nstate # 4: atom 1 (C ), wfc 2 (l=1 m= 3)\nstate # 5: atom 2 (C ), wfc 1 (l=0 m= 1)\nstate # 6: atom 2 (C ), wfc 2 (l=1 m= 1)\nstate # 7: atom 2 (C ), wfc 2 (l=1 m= 2)\nstate # 8: atom 2 (C ), wfc 2 (l=1 m= 3)\n</code></pre> <p>Here it shows that there are two carbon atoms, each with one \\(s\\) and three \\(p\\) orbitals. If one wants to exclude specific orbital(s), there is an additional input <code>atom_proj_exclude</code>, which accept a list of integers, e.g.,</p> Input file<pre><code>atom_proj_exclude = 1 5\n</code></pre> <p>which will exclude the two \\(s\\) orbitals from computing <code>amn</code>.</p>"},{"location":"user_guide/wannier90/projections/#advanced-usage","title":"Advanced usage","text":"<p>If the pseudopotential orbitals are not enough, one could also generate a custom set of orbitals, and ask <code>pw2wannier90</code> to use them for computing <code>amn</code>. This can be done by setting</p> Input file<pre><code>atom_proj_dir = './ext_proj'`\n</code></pre> <p>where the directory <code>ext_proj</code> contains the orbitals for all the atomic species used in the calculation. For example, for a silicon calculation, the directory <code>ext_proj</code> should contain a file named <code>Si.dat</code>. The format of the file is:</p> <ol> <li> <p>The first line contains two integers: the number of radial grid     points (\\(n_g\\)) and the number of projectors (\\(n_p\\)), e.g.,</p> Input file<pre><code>1141 2\n</code></pre> <p>which means the radial grid has \\(n_g = 1141\\) points, and there are \\(n_p = 3\\) projectors.</p> </li> <li> <p>The second line contains \\(n_p\\) integers specifying the angular     momentums of all the projectors, e.g.,</p> Input file<pre><code>0 1\n</code></pre> <p>standing for the two projectors having \\(s\\) and \\(p\\) characters, respectively.</p> </li> <li> <p>The rest of the file contains \\(n_g\\) rows of the radial wavefunctions     of the projectors. There are \\(2+n_p\\) columns: the first column is     the \\(x\\)-grid, the second column is the \\(r\\)-grid in Bohr unit, and     they are related by \\(r = \\exp(x)\\). The rest are \\(n_p\\) columns of the     radial wavefunctions of the projectors,</p> Input file<pre><code>-9.639057329615259 0.000065134426111 3.32211124436945e-05 1.86840239681223e-09\n-9.626557329615258 0.000065953716334 3.363898259696903e-05 1.915701228607072e-09\n-9.614057329615258 0.000066783311958 3.406210890972733e-05 1.964197436025957e-09\n...\n</code></pre> <p>Inside <code>pw2wannier90.x</code>, the radial wavefunction will be read and multiplied by spherical harmonics to form the actual projectors.</p> <p>For a practical example of extracting pseudo-atomic orbitals from UPF file and writing to a <code>pw2wannier90</code>-recognizable <code>.dat</code> file, see the script <code>utility/write_pdwf_projectors.py</code>.</p> <p>For an actual example of a <code>Si.dat</code> file for silicon, see the file <code>tutorials/tutorial35/ext_proj/Si.dat</code>. </p> </li> </ol> <ol> <li> <p>A. Damle and L. Lin. Disentanglement via entanglement: A unified method for Wannier localization. ArXiv e-prints, March 2017. URL: http://adsabs.harvard.edu/abs/2017arXiv170306958D, arXiv:1703.06958.\u00a0\u21a9</p> </li> </ol>"},{"location":"user_guide/wannier90/sample_inputs/","title":"Sample Input Files","text":""},{"location":"user_guide/wannier90/sample_inputs/#master-input-file-seednamewin","title":"Master input file: <code>seedname.win</code>","text":"Input file<pre><code>num_wann          : 4 \nmp_grid           : 4 4 4\nnum_iter          : 100\npostproc_setup    : true\n\nbegin unit_cell_cart\nang\n-1.61 0.00 1.61\n 0.00 1.61 1.61\n-1.61 1.61 0.00\nend unit_cell_cart\n\nbegin atoms_frac\nC   -0.125  -0.125  -0.125\nC    0.125   0.125   0.125\nend atoms_frac\n\nbands_plot        : true\nbands_num_points  : 100\nbands_plot_format : gnuplot\n\nbegin kpoint_path\nL 0.50000 0.50000 0.50000 G 0.00000 0.00000 0.00000\nG 0.00000 0.00000 0.00000 X 0.50000 0.00000 0.50000\nX 0.50000 0.00000 0.50000 K 0.62500 0.25000 0.62500\nend kpoint_path\n\nbegin projections\nC:l=0,l=1\nend projections\n\nbegin kpoints\n0.00 0.00 0.00\n0.00 0.00 0.25\n0.00 0.50 0.50\n .\n .\n .\n0.75 0.75 0.50\n0.75 0.75 0.75\nend kpoints\n</code></pre>"},{"location":"user_guide/wannier90/sample_inputs/#seednamennkp","title":"<code>seedname.nnkp</code>","text":"<p>Running <code>wannier90</code>\u00a0on the above input file would generate the following <code>nnkp</code> file:</p> Output file<pre><code>File written on  9Feb2006 at 15:13: 9 \n\ncalc_only_A   :  F\n\nbegin real_lattice\n  -1.612340   0.000000   1.612340\n   0.000000   1.612340   1.612340\n  -1.612340   1.612340   0.000000\nend real_lattice\n\nbegin recip_lattice\n  -1.951300  -1.951300   1.951300\n   1.951300   1.951300   1.951300\n  -1.951300   1.951300  -1.951300\nend recip_lattice\n\nbegin kpoints\n     64\n  0.00000   0.00000   0.00000   \n  0.00000   0.25000   0.00000   \n  0.00000   0.50000   0.00000   \n  0.00000   0.75000   0.00000   \n  0.25000   0.00000   0.00000   \n  .\n  .\n  .\n  0.50000   0.75000   0.75000   \n  0.75000   0.00000   0.75000   \n  0.75000   0.25000   0.75000   \n  0.75000   0.50000   0.75000   \n  0.75000   0.75000   0.75000     \nend kpoints\n\nbegin projections\n   8\n  -0.12500   -0.12500   -0.12500     0  1  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n  -0.12500   -0.12500   -0.12500     1  1  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n  -0.12500   -0.12500   -0.12500     1  2  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n  -0.12500   -0.12500   -0.12500     1  3  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n   0.12500    0.12500    0.12500     0  1  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n   0.12500    0.12500    0.12500     1  1  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n   0.12500    0.12500    0.12500     1  2  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \n   0.12500    0.12500    0.12500     1  3  1 \n     0.000  0.000  1.000   1.000  0.000  0.000   2.00 \nend projections\n\nbegin nnkpts\n    8\n  1     2      0   0   0\n  1     4      0  -1   0\n  1     5      0   0   0\n  1    13     -1   0   0\n  1    17      0   0   0\n  1    22      0   0   0\n  1    49      0   0  -1\n  1    64     -1  -1  -1\n  2     1      0   0   0\n  2     3      0   0   0\n  2     6      0   0   0\n  2    14     -1   0   0\n  2    18      0   0   0\n  2    23      0   0   0\n  2    50      0   0  -1\n  2    61     -1   0  -1\n  .\n  .\n  .\n 64     1      1   1   1\n 64    16      0   0   1\n 64    43      0   0   0\n 64    48      0   0   0\n 64    52      1   0   0\n 64    60      0   0   0\n 64    61      0   1   0\n 64    63      0   0   0\nend nnkpts\n\nbegin exclude_bands \n   4 \n   1 \n   2 \n   3\n   4\nend exclude_bands\n</code></pre>"},{"location":"user_guide/wannier90/transport/","title":"Transport Calculations with <code>wannier90</code>","text":"<p>By setting <code>transport = TRUE</code>, <code>wannier90</code>\u00a0will calculate the quantum conductance and density of states of a one-dimensional system. The results will be written to files <code>seedname_qc.dat</code> and <code>seedname_dos.dat</code>, respectively.</p> <p>The system for which transport properties are calculated is determined by the keyword <code>transport_mode</code>.</p>"},{"location":"user_guide/wannier90/transport/#transport_mode-bulk","title":"<code>transport_mode = bulk</code>","text":"<p>Quantum conductance and density of states are calculated for a perfectly periodic one-dimensional conductor. If <code>tran_read_ht = FALSE</code> the transport properties are calculated using the Hamiltonian in the Wannier function basis of the system found by <code>wannier90</code>. Setting <code>tran_read_ht = TRUE</code> allows the user to provide an external Hamiltonian matrix file <code>seedname_htB.dat</code>, from which the properties are found. See Section\u00a0Post-Processing for more details of the keywords required for such calculations.</p>"},{"location":"user_guide/wannier90/transport/#transport_mode-lcr","title":"<code>transport_mode = lcr</code>","text":"<p>Quantum conductance and density of states are calculated for a system where semi-infinite, left and right leads are connected through a central conductor region. This is known as the lcr system. Details of the method is described in Ref. <sup>1</sup>.</p> <p>In <code>wannier90</code>\u00a0two options exist for performing such calculations:</p> <ul> <li> <p>If <code>tran_read_ht = TRUE</code> the external Hamiltonian files     <code>seedname_htL.dat, seedname_htLC.dat, seedname_htC.dat, seedname_htCR.dat, seedname_htR.dat</code>     are read and used to compute the transport properties.</p> </li> <li> <p>If <code>tran_read_ht = FALSE</code>, then the transport     calculation is performed automatically using the Wannier functions     as a basis and the 2c2 geometry described in Section     Automated lcr Transport Calculations: The 2c2 Geometry.</p> </li> </ul>"},{"location":"user_guide/wannier90/transport/#automated-lcr-transport-calculations-the-2c2-geometry","title":"Automated lcr Transport Calculations: The 2c2 Geometry","text":"<p>Calculations using the 2c2 geometry provide a method to calculate the transport properties of an lcr system from a single <code>wannier90</code>\u00a0calculation. The Hamiltonian matrices which the five external files provide in the <code>tran_read_ht = TRUE</code> case are instead built from the Wannier function basis directly. As such, strict rules apply to the system geometry, which is shown in Figure\u00a0below. These rules are as follows:</p> <ul> <li> <p>Left and right leads must be identical and periodic.</p> </li> <li> <p>Supercell must contain two principal layers (PLs) of lead on the     left, a central conductor region and two principal layers of lead on     the right.</p> </li> <li> <p>The conductor region must contain enough lead such that the disorder     does not affect the principal layers of lead either side.</p> </li> <li> <p>A single k-point (Gamma) must be used.</p> </li> </ul> Schematic illustration of the supercell required for 2c2 lcr calculations, showing where each of the Hamiltonian matrices are derived from. Four principal layers (PLs) are required plus the conductor region. <p>In order to build the Hamiltonians, Wannier functions are first sorted according to position and then type if a number of Wannier functions exist with a similar centre (eg. d-orbital type Wannier functions centred on a Cu atom). Next, consistent parities of Wannier function are enforced. To distingiush between different types of Wannier function and assertain relative parities, a signature of each Wannier function is computed. The signature is formed of 20 integrals which have different spatial dependence. They are given by:</p> \\[ I=\\frac{1}{V}\\int_V g(\\mathbf{r})w(\\mathbf{r})d\\mathbf{r} \\label{eq:sig_ints} \\] <p>where \\(V\\) is the volume of the cell, \\(w(\\mathbf{r})\\) is the Wannier function and \\(g(\\mathbf{r})\\) are the set of functions:</p> \\[ \\begin{aligned} g(\\mathbf{r})=&amp;\\left\\lbrace1,\\sin\\left(\\frac{2\\pi (x-x_c)}{L_x}\\right),             \\sin\\left(\\frac{2\\pi (y-y_c)}{L_y}\\right),             \\sin\\left(\\frac{2\\pi (z-z_c)}{L_z}\\right),             \\sin\\left(\\frac{2\\pi (x-x_c)}{L_x}\\right)             \\sin\\left(\\frac{2\\pi (y-y_c)}{L_y}\\right),\\right.\\nonumber \\\\              &amp;\\left.\\sin\\left(\\frac{2\\pi (x-x_c)}{L_x}\\right)             \\sin\\left(\\frac{2\\pi (z-z_c)}{L_z}\\right),             ... \\right\\rbrace \\label{eq:g(r)} \\end{aligned} \\] <p>upto third order in powers of sines. Here, the supercell has dimension \\((L_x,L_y,L_z)\\) and the Wannier function has centre \\(\\mathbf{r}_c=(x_c,y_c,z_c)\\). Each of these integrals may be written as linear combinations of the following sums:</p> \\[ S_n(\\mathbf{G})=\\displaystyle{e^{i\\mathbf{G.r}_{c}}\\sum_{m}U_{mn}\\tilde{u}_{m\\Gamma}^{*}(\\mathbf{G})} \\] <p>where \\(n\\) and \\(m\\) are the Wannier function and band indexes, \\(\\mathbf{G}\\) is a G-vector, \\(U_{mn}\\) is the unitary matrix that transforms from the Bloch representation of the system to the maximally-localised Wannier function basis and \\(\\tilde{u}_{m\\Gamma}^{*}(\\mathbf{G})\\) are the conjugates of the Fourier transforms of the periodic parts of the Bloch states at the \\(\\Gamma\\!\\) -point. The complete set of \\(\\tilde{u}_{m\\mathbf{k}}(\\mathbf{G})\\) are often outputted by plane-wave DFT codes. However, to calculate the 20 signature integrals, only 32 specific \\(\\tilde{u}_{m\\mathbf{k}}(\\mathbf{G})\\) are required. These are found in an additional file (<code>seedname.unkg</code>) that should be provided by the interface between the DFT code and <code>wannier90</code>\u00a0. A detailed description of this file may be found in Section\u00a0<code>seedname.unkg</code>.</p> <p>Additionally, the following keywords are also required in the input file:</p> <ul> <li> <p><code>tran_num_ll</code> : The number of Wannier functions in a principal     layer.</p> </li> <li> <p><code>tran_num_cell_ll</code> : The number of unit cells in one principal layer     of lead</p> </li> </ul> <p>A further parameter related to these calculations is <code>tran_group_threshold</code>.</p> <p>Tutorial of how 2c2 calculations are preformed can be found in the <code>wannier90</code>\u00a0Tutorial.</p> <ol> <li> <p>Marco Buongiorno Nardelli. Electronic transport in extended systems: application to carbon nanotubes. Phys. Rev. B, 60:7828, 1999.\u00a0\u21a9</p> </li> </ol>"}]}